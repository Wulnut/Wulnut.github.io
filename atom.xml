<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wulnut`s space</title>
  <icon>https://www.wulnut.top/img/main/panda.png</icon>
  <subtitle>垃圾桶轮到你介绍了</subtitle>
  <link href="https://www.wulnut.top/atom.xml" rel="self"/>
  
  <link href="https://www.wulnut.top/"/>
  <updated>2020-12-23T13:34:26.619Z</updated>
  <id>https://www.wulnut.top/</id>
  
  <author>
    <name>Wulnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述数据库连接池</title>
    <link href="https://www.wulnut.top/2020/12/23/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://www.wulnut.top/2020/12/23/%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2020-12-23T13:06:28.840Z</published>
    <updated>2020-12-23T13:34:26.619Z</updated>
    
    <content type="html"><![CDATA[<p>简介数据库连接池</p><a id="more"></a><h1 id="一般怎么链接数据库"><a href="#一般怎么链接数据库" class="headerlink" title="一般怎么链接数据库"></a>一般怎么链接数据库</h1><p>一般来说，Java应用程序访问数据库的过程是：</p><ol><li>装载数据库驱动程序</li><li>通过Jdbc链接数据库链接</li><li>访问数据库，执行sql语句</li><li>断开数据库连接</li></ol><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 声明Connection对象</span>        Connection connection;        <span class="hljs-comment">// 驱动程序名</span>        String driver = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;        <span class="hljs-comment">// URL指向要访问的数据库名也就是那张表 student</span>        String url  = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/student?serverTimezone=UTC&quot;</span>;        <span class="hljs-comment">// MySQL配置时的用户名</span>        String user = <span class="hljs-string">&quot;root&quot;</span>;        <span class="hljs-comment">// MySQL配置时的密码</span>        String pwd  = <span class="hljs-string">&quot;233333333&quot;</span>;        <span class="hljs-comment">// 加载驱动</span>        <span class="hljs-comment">// 防止没有该驱动</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 1.加载驱动</span>            Class.forName(driver);            System.out.println(<span class="hljs-string">&quot;驱动连接成功&quot;</span>);            <span class="hljs-comment">// 2.创建连接</span>            connection = DriverManager.getConnection(url, user, pwd);            <span class="hljs-keyword">if</span> (!connection.isClosed()) &#123;                System.out.println(<span class="hljs-string">&quot;\n\t\t成功以 &quot;</span> + user + <span class="hljs-string">&quot; 身份连接到数据库！！！&quot;</span>);            &#125;            <span class="hljs-comment">// 3.创建Statement</span>            Statement statement = connection.createStatement();            <span class="hljs-comment">// PreparedStatement 安全性更高</span><span class="hljs-comment">//            PreparedStatement st = connection.createStatement();</span>            <span class="hljs-comment">// 4.执行sql</span>            String sql_1 = <span class="hljs-string">&quot;insert into student.info values(&#x27;6&#x27;, &#x27;ash-bin&#x27;, &#x27;数学&#x27;, 40000)&quot;</span>;            <span class="hljs-keyword">int</span> n = statement.executeUpdate(sql_1);            System.out.println(n);            String sql_2 = <span class="hljs-string">&quot;select * from student.info&quot;</span>;            <span class="hljs-comment">// 5.ResultSet类，用来存放获取的结果集！！</span>            ResultSet rs = statement.executeQuery(sql_2);            System.out.println(<span class="hljs-string">&quot;\n\t\t执行结果如下所示:&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t-----------------------------------------------------&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t|\t&quot;</span> + <span class="hljs-string">&quot;ID&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;姓名&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;专业&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;薪水\t|&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t-----------------------------------------------------&quot;</span>);            <span class="hljs-keyword">int</span> ID  = <span class="hljs-number">0</span>;            String name      = <span class="hljs-keyword">null</span>;            String salary    = <span class="hljs-keyword">null</span>;            String dept_name = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 查询</span>            <span class="hljs-keyword">while</span> (rs.next()) &#123;            <span class="hljs-comment">// 获取 ID 这列数据</span>            ID = rs.getInt(<span class="hljs-string">&quot;ID&quot;</span>);            <span class="hljs-comment">// 获取 Name 这列数据</span>            name = rs.getString(<span class="hljs-string">&quot;Name&quot;</span>);            <span class="hljs-comment">// 获取 dept_name 这列数据</span>            dept_name = rs.getString(<span class="hljs-string">&quot;dept_name&quot;</span>);            <span class="hljs-comment">// 获取 salary 这列数据</span>            salary = rs.getString(<span class="hljs-string">&quot;salary&quot;</span>);            <span class="hljs-comment">// 输出结果</span>            System.out.println(<span class="hljs-string">&quot;\t\t|\t&quot;</span> + ID + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + dept_name + <span class="hljs-string">&quot;\t&quot;</span> + salary + <span class="hljs-string">&quot;\t|\t\t&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 这个异常是驱动异常</span>            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;没有该驱动&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123; <span class="hljs-comment">// 这个异常是getConnection的异常</span>            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;创建数据库连接失败&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;\t\t\t\t获取数据库数据完毕！&quot;</span>);        &#125;    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="连接池"></p><p>程序开发过程中，存在很多问题：</p><ol><li>首先，每一次web请求都要建立一次数据库连接。建立连接是一个费时的活动，每次都得花费0.05s～1s的时间，而且系统还要分配内存资源。这个时间对于一次或几次数据库操作，或许感觉不出系统有多大的开销。</li><li><p>可是对于现在的web应用，尤其是大型电子商务网站，同时有几百人甚至几千人在线是很正常的事。在这种情况下，频繁的进行数据库连接操作势必占用很多的系统资源，网站的响应速度必定下降，严重的甚至会造成服务器的崩溃。不是危言耸听，这就是制约某些电子商务网站发展的技术瓶颈问题。其次，对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将不得不重启数据库</p><p>通过上面的分析，我们可以看出来，“数据库连接”是一种稀缺的资源，为了保障网站的正常使用，应该对其进行妥善管理。其实我们查询完数据库后，如果不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。就避免了一次建立数据库连接和断开的操作时间消耗。</p><p>数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。</p><p>创建数据库连接池大概有3个步骤：</p><ol><li>创建ConnectionPool实例，并初始化创建10个连接，保存在Vector中（线程安全）</li><li>实现getConnection()从连接库中获取一个可用的连接</li><li>returnConnection(conn) 提供将连接放回连接池中方法</li></ol></li></ol><p> 数据库连接池类 ConnectionPool.java<br> <pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DatabaseMetaData;<span class="hljs-keyword">import</span> java.sql.Driver;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.sql.Statement;<span class="hljs-keyword">import</span> java.util.Enumeration;<span class="hljs-keyword">import</span> java.util.Vector; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123; <span class="hljs-keyword">private</span> String jdbcDriver = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库驱动</span><span class="hljs-keyword">private</span> String dbUrl = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据 URL</span><span class="hljs-keyword">private</span> String dbUsername = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库用户名</span><span class="hljs-keyword">private</span> String dbPassword = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库用户密码</span><span class="hljs-keyword">private</span> String testTable = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 测试连接是否可用的测试表名，默认没有测试表</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> initialConnections = <span class="hljs-number">10</span>; <span class="hljs-comment">// 连接池的初始大小</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> incrementalConnections = <span class="hljs-number">5</span>;<span class="hljs-comment">// 连接池自动增加的大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxConnections = <span class="hljs-number">50</span>; <span class="hljs-comment">// 连接池最大的大小</span><span class="hljs-keyword">private</span> Vector connections = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 存放连接池中数据库连接的向量 , 初始时为 null</span><span class="hljs-comment">// 它中存放的对象为 PooledConnection 型</span> <span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造函数</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> jdbcDriver</span><span class="hljs-comment"> *            String JDBC 驱动类串</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbUrl</span><span class="hljs-comment"> *            String 数据库 URL</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbUsername</span><span class="hljs-comment"> *            String 连接数据库用户名</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbPassword</span><span class="hljs-comment"> *            String 连接数据库用户的密码</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String jdbcDriver, String dbUrl, String dbUsername,</span></span><span class="hljs-function"><span class="hljs-params">String dbPassword)</span> </span>&#123;<span class="hljs-keyword">this</span>.jdbcDriver = jdbcDriver;<span class="hljs-keyword">this</span>.dbUrl = dbUrl;<span class="hljs-keyword">this</span>.dbUsername = dbUsername;<span class="hljs-keyword">this</span>.dbPassword = dbPassword;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池的初始大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 初始连接池中可获得的连接数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getInitialConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.initialConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池的初始大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 用于设置初始连接池中连接的数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInitialConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.initialConnections = initialConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池自动增加的大小 、</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 连接池自动增加的大小</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIncrementalConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.incrementalConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池自动增加的大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 连接池自动增加的大小</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIncrementalConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> incrementalConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.incrementalConnections = incrementalConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池中最大的可用连接数量</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 连接池中最大的可用连接数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.maxConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池中最大可用的连接数量</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 设置连接池中最大可用的连接数量值</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaxConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.maxConnections = maxConnections;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取测试数据库表的名字</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 测试数据库表的名字</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTestTable</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.testTable;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置测试表的名字</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> testTable</span><span class="hljs-comment"> *            String 测试表的名字</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTestTable</span><span class="hljs-params">(String testTable)</span> </span>&#123;<span class="hljs-keyword">this</span>.testTable = testTable;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 创建一个数据库连接池，连接池中的可用连接的数量采用类成员 initialConnections 中设置的值</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">// 确保连接池没有创建</span><span class="hljs-comment">// 如果连接池己经创建了，保存连接的向量 connections 不会为空</span><span class="hljs-keyword">if</span> (connections != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果己经创建，则返回</span>&#125;<span class="hljs-comment">// 实例化 JDBC Driver 中指定的驱动类实例</span>Driver driver = (Driver) (Class.forName(<span class="hljs-keyword">this</span>.jdbcDriver).newInstance());DriverManager.registerDriver(driver); <span class="hljs-comment">// 注册 JDBC 驱动程序</span><span class="hljs-comment">// 创建保存连接的向量 , 初始时有 0 个元素</span>connections = <span class="hljs-keyword">new</span> Vector();<span class="hljs-comment">// 根据 initialConnections 中设置的值，创建连接。</span>createConnections(<span class="hljs-keyword">this</span>.initialConnections);<span class="hljs-comment">// System.out.println(&quot; 数据库连接池创建成功！ &quot;);</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建由 numConnections 指定数目的数据库连接 , 并把这些连接 放入 connections 向量中</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> numConnections</span><span class="hljs-comment"> *            要创建的数据库连接的数目</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numConnections)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 循环创建指定数目的数据库连接</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; numConnections; x++) &#123;<span class="hljs-comment">// 是否连接池中的数据库连接的数量己经达到最大？最大值由类成员 maxConnections</span><span class="hljs-comment">// 指出，如果 maxConnections 为 0 或负数，表示连接数量没有限制。</span><span class="hljs-comment">// 如果连接数己经达到最大，即退出。</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.maxConnections &gt; <span class="hljs-number">0</span>&amp;&amp; <span class="hljs-keyword">this</span>.connections.size() &gt;= <span class="hljs-keyword">this</span>.maxConnections) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">// add a new PooledConnection object to connections vector</span><span class="hljs-comment">// 增加一个连接到连接池中（向量 connections 中）</span><span class="hljs-keyword">try</span> &#123;connections.addElement(<span class="hljs-keyword">new</span> PooledConnection(newConnection()));&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 创建数据库连接失败！ &quot;</span> + e.getMessage());<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException();&#125;<span class="hljs-comment">// System.out.println(&quot; 数据库连接己创建 ......&quot;);</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建一个新的数据库连接并返回它</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个新创建的数据库连接</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">newConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 创建一个数据库连接</span>Connection conn = DriverManager.getConnection(dbUrl, dbUsername,dbPassword);<span class="hljs-comment">// 如果这是第一次创建数据库连接，即检查数据库，获得此数据库允许支持的</span><span class="hljs-comment">// 最大客户连接数目</span><span class="hljs-comment">// connections.size()==0 表示目前没有连接己被创建</span><span class="hljs-keyword">if</span> (connections.size() == <span class="hljs-number">0</span>) &#123;DatabaseMetaData metaData = conn.getMetaData();<span class="hljs-keyword">int</span> driverMaxConnections = metaData.getMaxConnections();<span class="hljs-comment">// 数据库返回的 driverMaxConnections 若为 0 ，表示此数据库没有最大</span><span class="hljs-comment">// 连接限制，或数据库的最大连接限制不知道</span><span class="hljs-comment">// driverMaxConnections 为返回的一个整数，表示此数据库允许客户连接的数目</span><span class="hljs-comment">// 如果连接池中设置的最大连接数量大于数据库允许的连接数目 , 则置连接池的最大</span><span class="hljs-comment">// 连接数目为数据库允许的最大数目</span><span class="hljs-keyword">if</span> (driverMaxConnections &gt; <span class="hljs-number">0</span>&amp;&amp; <span class="hljs-keyword">this</span>.maxConnections &gt; driverMaxConnections) &#123;<span class="hljs-keyword">this</span>.maxConnections = driverMaxConnections;&#125;&#125;<span class="hljs-keyword">return</span> conn; <span class="hljs-comment">// 返回创建的新的数据库连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过调用 getFreeConnection() 函数返回一个可用的数据库连接 , 如果当前没有可用的数据库连接，并且更多的数据库连接不能创</span><span class="hljs-comment"> * 建（如连接池大小的限制），此函数等待一会再尝试获取。</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接对象</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池己被创建</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 连接池还没创建，则返回 null</span>&#125;Connection conn = getFreeConnection(); <span class="hljs-comment">// 获得一个可用的数据库连接</span><span class="hljs-comment">// 如果目前没有可以使用的连接，即所有的连接都在使用中</span><span class="hljs-keyword">while</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 等一会再试</span><span class="hljs-comment">// System.out.println(&quot;Wait&quot;);</span>wait(<span class="hljs-number">250</span>);conn = getFreeConnection(); <span class="hljs-comment">// 重新再试，直到获得可用的连接，如果</span><span class="hljs-comment">// getFreeConnection() 返回的为 null</span><span class="hljs-comment">// 则表明创建一批连接后也不可获得可用连接</span>&#125;<span class="hljs-keyword">return</span> conn;<span class="hljs-comment">// 返回获得的可用的连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 本函数从连接池向量 connections 中返回一个可用的的数据库连接，如果 当前没有可用的数据库连接，本函数则根据</span><span class="hljs-comment"> * incrementalConnections 设置 的值创建几个数据库连接，并放入连接池中。 如果创建后，所有的连接仍都在使用中，则返回 null</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">getFreeConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 从连接池中获得一个可用的数据库连接</span>Connection conn = findFreeConnection();<span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 如果目前连接池中没有可用的连接</span><span class="hljs-comment">// 创建一些连接</span>createConnections(incrementalConnections);<span class="hljs-comment">// 重新从池中查找是否有可用连接</span>conn = findFreeConnection();<span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 如果创建连接后仍获得不到可用的连接，则返回 null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-keyword">return</span> conn;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 查找连接池中所有的连接，查找一个可用的数据库连接， 如果没有可用的连接，返回 null</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">findFreeConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;Connection conn = <span class="hljs-keyword">null</span>;PooledConnection pConn = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 获得连接池向量中所有的对象</span>Enumeration enumerate = connections.elements();<span class="hljs-comment">// 遍历所有的对象，看是否有可用的连接</span><span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-keyword">if</span> (!pConn.isBusy()) &#123;<span class="hljs-comment">// 如果此对象不忙，则获得它的数据库连接并把它设为忙</span>conn = pConn.getConnection();pConn.setBusy(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 测试此连接是否可用</span><span class="hljs-keyword">if</span> (!testConnection(conn)) &#123;<span class="hljs-comment">// 如果此连接不可再用了，则创建一个新的连接，</span><span class="hljs-comment">// 并替换此不可用的连接对象，如果创建失败，返回 null</span><span class="hljs-keyword">try</span> &#123;conn = newConnection();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 创建数据库连接失败！ &quot;</span> + e.getMessage());<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;pConn.setConnection(conn);&#125;<span class="hljs-keyword">break</span>; <span class="hljs-comment">// 己经找到一个可用的连接，退出</span>&#125;&#125;<span class="hljs-keyword">return</span> conn;<span class="hljs-comment">// 返回找到到的可用连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试一个连接是否可用，如果不可用，关掉它并返回 false 否则可用返回 true</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> conn</span><span class="hljs-comment"> *            需要测试的数据库连接</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回 true 表示此连接可用， false 表示不可用</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">testConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 判断测试表是否存在</span><span class="hljs-keyword">if</span> (testTable.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<span class="hljs-comment">// 如果测试表为空，试着使用此连接的 setAutoCommit() 方法</span><span class="hljs-comment">// 来判断连接否可用（此方法只在部分数据库可用，如果不可用 ,</span><span class="hljs-comment">// 抛出异常）。注意：使用测试表的方法更可靠</span>conn.setAutoCommit(<span class="hljs-keyword">true</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 有测试表的时候使用测试表测试</span><span class="hljs-comment">// check if this connection is valid</span>Statement stmt = conn.createStatement();stmt.execute(<span class="hljs-string">&quot;select count(*) from &quot;</span> + testTable);&#125;&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<span class="hljs-comment">// 上面抛出异常，此连接己不可用，关闭它，并返回 false;</span>closeConnection(conn);<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// 连接可用，返回 true</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 此函数返回一个数据库连接到连接池中，并把此连接置为空闲。 所有使用连接池获得的数据库连接均应在不使用此连接时返回它。</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 需返回到连接池中的连接对象</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-comment">// 确保连接池存在，如果连接没有创建（不存在），直接返回</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法返回此连接到连接池中 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-comment">// 遍历连接池中的所有连接，找到这个要返回的连接对象</span><span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 先找到连接池中的要返回的连接对象</span><span class="hljs-keyword">if</span> (conn == pConn.getConnection()) &#123;<span class="hljs-comment">// 找到了 , 设置此连接为空闲状态</span>pConn.setBusy(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 刷新连接池中所有的连接对象</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshConnections</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池己创新存在</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法刷新 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;<span class="hljs-comment">// 获得一个连接对象</span>pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 如果对象忙则等 5 秒 ,5 秒后直接刷新</span><span class="hljs-keyword">if</span> (pConn.isBusy()) &#123;wait(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 等 5 秒</span>&#125;<span class="hljs-comment">// 关闭此连接，用一个新的连接代替它。</span>closeConnection(pConn.getConnection());pConn.setConnection(newConnection());pConn.setBusy(<span class="hljs-keyword">false</span>);&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 关闭连接池中所有的连接，并清空连接池。</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnectionPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池存在，如果不存在，返回</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法关闭 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 如果忙，等 5 秒</span><span class="hljs-keyword">if</span> (pConn.isBusy()) &#123;wait(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 等 5 秒</span>&#125;<span class="hljs-comment">// 5 秒后直接关闭它</span>closeConnection(pConn.getConnection());<span class="hljs-comment">// 从连接池向量中删除它</span>connections.removeElement(pConn);&#125;<span class="hljs-comment">// 置连接池为空</span>connections = <span class="hljs-keyword">null</span>;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 关闭一个数据库连接</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 需要关闭的数据库连接</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;conn.close();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 关闭数据库连接出错： &quot;</span> + e.getMessage());&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使程序等待给定的毫秒数</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 给定的毫秒数</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mSeconds)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(mSeconds);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 内部使用的用于保存连接池中连接对象的类 此类中有两个成员，一个是数据库的连接，另一个是指示此连接是否 正在使用的标志。</span><span class="hljs-comment"> */</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PooledConnection</span> </span>&#123;Connection connection = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 数据库连接</span><span class="hljs-keyword">boolean</span> busy = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 此连接是否正在使用的标志，默认没有正在使用</span> <span class="hljs-comment">// 构造函数，根据一个 Connection 构告一个 PooledConnection 对象</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PooledConnection</span><span class="hljs-params">(Connection connection)</span> </span>&#123;<span class="hljs-keyword">this</span>.connection = connection;&#125; <span class="hljs-comment">// 返回此对象中的连接</span><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> connection;&#125; <span class="hljs-comment">// 设置此对象的，连接</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnection</span><span class="hljs-params">(Connection connection)</span> </span>&#123;<span class="hljs-keyword">this</span>.connection = connection;&#125; <span class="hljs-comment">// 获得对象连接是否忙</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBusy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> busy;&#125; <span class="hljs-comment">// 设置对象的连接正在忙</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBusy</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> busy)</span> </span>&#123;<span class="hljs-keyword">this</span>.busy = busy;&#125;&#125; &#125;</code></pre></p><p>ConnectionPoolUtils.java</p><pre><code class="hljs java"><span class="hljs-comment">/*连接池工具类，返回唯一的一个数据库连接池对象,单例模式*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPoolUtils</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPoolUtils</span><span class="hljs-params">()</span></span>&#123;&#125;;<span class="hljs-comment">//私有静态方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool poolInstance = <span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">GetPoolInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(poolInstance == <span class="hljs-keyword">null</span>) &#123;poolInstance = <span class="hljs-keyword">new</span> ConnectionPool( <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/student?serverTimezone=UTC&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;233333333&quot;</span>);<span class="hljs-keyword">try</span> &#123;poolInstance.createPool();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-comment">// TODO Auto-generated catch block</span>e.printStackTrace();&#125;&#125;<span class="hljs-keyword">return</span> poolInstance;&#125;&#125;</code></pre><p>ConnectionPoolTest.java<br><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.sql.Statement;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionTest</span> </span>&#123; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">/*使用连接池创建100个连接的时间*/</span>        <span class="hljs-comment">/*// 创建数据库连接库对象</span><span class="hljs-comment">       ConnectionPool connPool = new ConnectionPool(&quot;com.mysql.jdbc.Driver&quot;,&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);</span><span class="hljs-comment">       // 新建数据库连接库</span><span class="hljs-comment">           connPool.createPool();*/</span>       ConnectionPool  connPool=ConnectionPoolUtils.GetPoolInstance();<span class="hljs-comment">//单例模式创建连接池对象</span>            <span class="hljs-comment">// SQL测试语句</span>       String sql = <span class="hljs-string">&quot;Select * from pet&quot;</span>;       <span class="hljs-comment">// 设定程序运行起始时间</span>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();             <span class="hljs-comment">// 循环测试100次数据库连接</span>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                  Connection conn = connPool.getConnection(); <span class="hljs-comment">// 从连接库中获取一个可用的连接</span>                  Statement stmt = conn.createStatement();                  ResultSet rs = stmt.executeQuery(sql);                  <span class="hljs-keyword">while</span> (rs.next()) &#123;                      String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);                   <span class="hljs-comment">//  System.out.println(&quot;查询结果&quot; + name);</span>                  &#125;                  rs.close();                  stmt.close();                  connPool.returnConnection(conn);<span class="hljs-comment">// 连接使用完后释放连接到连接池</span>              &#125;              System.out.println(<span class="hljs-string">&quot;经过100次的循环调用，使用连接池花费的时间:&quot;</span>+ (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;ms&quot;</span>);              <span class="hljs-comment">// connPool.refreshConnections();//刷新数据库连接池中所有连接，即不管连接是否正在运行，都把所有连接都释放并放回到连接池。注意：这个耗时比较大。</span>             connPool.closeConnectionPool();<span class="hljs-comment">// 关闭数据库连接池。注意：这个耗时比较大。</span>              <span class="hljs-comment">// 设定程序运行起始时间</span>              start = System.currentTimeMillis();                            <span class="hljs-comment">/*不使用连接池创建100个连接的时间*/</span>             <span class="hljs-comment">// 导入驱动</span>              Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                  <span class="hljs-comment">// 创建连接</span>                 Connection conn = DriverManager.getConnection(                          <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);                  Statement stmt = conn.createStatement();                  ResultSet rs = stmt.executeQuery(sql);                 <span class="hljs-keyword">while</span> (rs.next()) &#123;                  &#125;                 rs.close();                 stmt.close();                 conn.close();<span class="hljs-comment">// 关闭连接</span>             &#125;             System.out.println(<span class="hljs-string">&quot;经过100次的循环调用，不使用连接池花费的时间:&quot;</span>                     + (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;ms&quot;</span>);         &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();         &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;             e.printStackTrace();        &#125;&#125;</code></pre></p><p>注：关于对连接池深度的思考，对于一般的连接池最多10个就够了，基本可以应付一般的小项目。但是连接池开大过大，是不是就可以理解成没有连接池，因为缓存太多了就和没开连接池一样呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简介数据库连接池&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.wulnut.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈script标签的defer和async</title>
    <link href="https://www.wulnut.top/2020/11/28/%E6%B5%85%E8%B0%88script%E6%A0%87%E7%AD%BE/"/>
    <id>https://www.wulnut.top/2020/11/28/%E6%B5%85%E8%B0%88script%E6%A0%87%E7%AD%BE/</id>
    <published>2020-11-28T12:44:47.862Z</published>
    <updated>2020-12-23T13:36:09.171Z</updated>
    
    <content type="html"><![CDATA[<p>有点意思</p><a id="more"></a><h1 id="1-什么鬼"><a href="#1-什么鬼" class="headerlink" title="1.什么鬼"></a>1.什么鬼</h1><p>今天在做一个小玩意的时候看到一句吊炸天的代码<br><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;#link(&quot;</span>xxxx/xx/home/home.js<span class="hljs-string">&quot;)&quot;</span> type=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-keyword">async</span> defer&gt;&lt;/script&gt;</code></pre></p><p>卧槽，竟然同时有async和defer属性，这尼玛是什么操作，赶快学习一下</p><h1 id="2-调查一番"><a href="#2-调查一番" class="headerlink" title="2.调查一番"></a>2.调查一番</h1><p>先看看<code>async</code>和<code>defer</code>各自的定义吧，翻开红宝书望远镜，是这么介绍的</p><h2 id="2-1-defer"><a href="#2-1-defer" class="headerlink" title="2.1 defer"></a>2.1 defer</h2><blockquote><p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置<code>defer</code>属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于<code>DOMContentLoaded</code>事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在<code>DOMContentLoad</code>时间触发前执行，因此最好只包含一个延迟脚本。</p></blockquote><h2 id="2-2-async"><a href="#2-2-async" class="headerlink" title="2.2 async"></a>2.2 async</h2><blockquote><p>这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p></blockquote><p>概括来讲，就是这两个属性都会使script标签异步加载，然而执行的时机是不一样的。引用segmentfault上的一个回答中的一张图<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1443517782-57c6928b20b56_articlex.jpg" alt=" "></p><p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p><p>也就是说<code>async</code>是乱序的，而defer是顺序执行，这也就决定了<code>async</code>比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。从图中可以看到一个普通的<code>&lt;script&gt;</code>标签的加载和解析都是同步的，会阻塞DOM的渲染，这也就是我们经常会把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部的原因之一，为了防止加载资源而导致的长时间的白屏，另一个原因是js可能会进行DOM操作，所以要在DOM全部渲染完后再执行。</p><h2 id="2-3-really？"><a href="#2-3-really？" class="headerlink" title="2.3 really？"></a>2.3 really？</h2><p><strong>然而</strong>，这张图（几乎是百度搜到的唯一答案）是不严谨的，这只是规范的情况，大多数浏览器在实现的时候会作出优化。</p><p>来看看chrome是怎么做的:</p><blockquote><p>《WebKit技术内幕》：</p><ol><li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li><li>加载器依赖网络模块建立连接，发送请求并接受答复。</li><li>WebKit接收到各种网页或者资源的数据，其中某些资源可能是同步或异步获取的。</li><li>网页被交给HTML解释器转变成一系列的词语（Token）。</li><li>解释器根据词语构建节点（Node），形成DOM树。</li><li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li><li>JavaScript代码可能会修改DOM树的结构。</li><li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载他们，但是他们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol></blockquote><p>所以，通俗来讲，chrome浏览器首先会请求HTML文档，然后对其中的各种资源调用相应的资源加载器进行异步网络请求，同时进行DOM渲染，直到遇到<code>&lt;script&gt;</code>标签的时候，主进程才会停止渲染等待此资源加载完毕然后调用V8引擎对js解析，继而继续进行<code>DOM</code>解析。我的理解如果加了async属性就相当于单独开了一个进程去独立加载和执行，而defer是和将<code>&lt;script&gt;</code>放到<code>&lt;body&gt;</code>底部一样的效果。</p><h1 id="3-实验一发"><a href="#3-实验一发" class="headerlink" title="3. 实验一发"></a>3. 实验一发</h1><h2 id="3-1-demo"><a href="#3-1-demo" class="headerlink" title="3.1 demo"></a>3.1 demo</h2><p>为了验证上面的结论我们来测试一下</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://cdn.staticfile.org/foundation/6.0.1/css/foundation.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://lib.sinaapp.com/js/angular.js/angular-1.2.19/angular.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/backbone/0.9.2/backbone.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    ul&gt;li&#123;这是第$个节点&#125;*1000<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>一个简单的demo，从各个CDN上引用了2个CSS3个JS，在body里面创建了1000个li。通过调整外部引用资源的位置和加入相关的属性利用chrome的Timeline进行验证。</p><h2 id="放置在内"><a href="#放置在内" class="headerlink" title="放置在内"></a>放置在<head>内</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/2699686611-57c6929ae4e60_articlex.jpg" alt=""><br>异步加载资源，但会阻塞<code>&lt;body&gt;</code>的渲染会出现白屏，按照顺序立即执行脚本</p><h2 id="3-3-放置在底部"><a href="#3-3-放置在底部" class="headerlink" title="3.3 放置在底部"></a>3.3 放置在<body>底部</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/2025377632-57c692a8e1d80_articlex.jpg" alt=""><br>异步加载资源，等<body>中的内容渲染完毕后且加载完按顺序执行JS</p><h2 id="3-3-放置在头部并使用async"><a href="#3-3-放置在头部并使用async" class="headerlink" title="3.3 放置在头部并使用async"></a>3.3 放置在<head>头部并使用async</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/1609828464-57c692b36943c_articlex.jpg" alt=""><br>异步加载资源，且加载完JS资源立即执行，并不会按顺序，谁快谁先上</p><h2 id="3-4-放置在头部并使用defer"><a href="#3-4-放置在头部并使用defer" class="headerlink" title="3.4 放置在头部并使用defer"></a>3.4 放置在<head>头部并使用defer</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/3039840796-57c692be0062f_articlex.jpg" alt=""><br>异步加载资源，在DOM渲染后之后再按顺序执行JS</p><h2 id="3-5-放置在头部并同时使用async和defer"><a href="#3-5-放置在头部并同时使用async和defer" class="headerlink" title="3.5 放置在头部并同时使用async和defer"></a>3.5 放置在<head>头部并同时使用async和defer</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/3802019618-57c692c9d447e_articlex.jpg" alt=""><br>表现和async一致，开了个脑洞，把这两个属性交换一下位置，看会不会有覆盖效果，结果发现是一致的 = =、</p><p>综上，在webkit引擎下，建议的方式仍然是把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部，如果需要使用百度谷歌分析或者不蒜子等独立库时可以使用async属性，若你的<code>&lt;script&gt;</code>标签必须写在<code>&lt;head&gt;</code>头部内可以使用defer属性</p><h1 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h1><p>那么，同时写上的原因是什么呢，兼容性?</p><p>上caniuse，async在IE&lt;=9时不支持，其他浏览器OK；defer在IE&lt;=9时支持但会有bug，其他浏览器OK；现象在这个issue里有描述，这也就是“望远镜”里建议只有一个defer的原因。所以两个属性都指定是为了在async不支持的时候启用defer，但defer在某些情况下还是有bug。</p><blockquote><p>The defer attribute may be specified even if the async attribute is specified, to cause legacy Web browsers that only support defer (and not async) to fall back to the defer behavior instead of the synchronous blocking behavior that is the default.</p></blockquote><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><p>其实这么讲来，最稳妥的办法还是把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部，没有兼容性问题，没有白屏问题，没有执行顺序问题，高枕无忧，不要搞什么defer和async的花啦~<br>目前只研究了chrome的webkit的渲染机制，Firefox和IE的有待继续研究，图片和CSS以及其他外部资源的渲染有待研究</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点意思&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="js" scheme="https://www.wulnut.top/tags/js/"/>
    
    <category term="学习" scheme="https://www.wulnut.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Cache地址映射与计算方式</title>
    <link href="https://www.wulnut.top/2020/11/01/cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.wulnut.top/2020/11/01/cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-11-01T11:38:54.289Z</published>
    <updated>2020-11-02T08:30:00.673Z</updated>
    
    <content type="html"><![CDATA[<p>Cache地址映射</p><a id="more"></a><h1 id="什么是Cache地址映射"><a href="#什么是Cache地址映射" class="headerlink" title="什么是Cache地址映射"></a>什么是Cache地址映射</h1><p>&emsp;&emsp;主存的容量比Cache要大的多，所以我们得采用多个主存块映射到同一个Cache行中的方法，将要访问的局部主存区域取到Cache中。映射方法有：直接映射，全相联映射，组相链映射</p><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>直接映射是最简单粗暴的办法：</p><blockquote><p>(块地址)mod(cache中的块数)</p></blockquote><p>&emsp;&emsp;一个内存块地址始终映射到一个固定的Cache 地址。下图中主存被分为了0-2047个内存块，缓存块或者说cache line有16块。那么第0，16，n*16块因为mod16都为0，所以他们对应到的Cache行号都为0。如果我们要访问第16号内存块(内存块从0开始计数的)，只要它在缓存块里面，那么它必定是在0号缓存块，也就是行号为0.<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162001890-759184579.png" alt=""></p><p>&emsp;&emsp;知道了映射方法，那么如何规定主存地址呢？其实对于取模运算，我们只需要取低位字节就可以了。在十进制里面如果对16取余，那么结果定是两位数以内，并且不会大于15。比如说Cache有16行，16是2的4次方，那么我们就可以直接取主存块号的低四位作为Cache行号。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162127959-1713738037.png" alt=""></p><p>&emsp;&emsp;17对应的cache行号就是1.但当我们读取某一个缓存行时，我们怎么知道他是0块群的还是其他块群的呢？其实正如主存块号中包含了Cache行号一样，其低四位之前的高位就可以作为区分的Tag(主存标记)使用。最后一点就是，CPU读取数据只是要读取它需要的字(Word)而已，那么这个字具体是在Cache line的哪里，我们还需要一个偏移量来纪录它。所以直接映射的主存地址应该由三部分组成：主存子块标记，Cache子块标记，字块内地址。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162153262-921590979.png" alt=""></p><blockquote><p>现在我们来自己动手做一做：假设数据在主存和Cache间的传送单位为512B，Cache大小为$2^{13}$B，主存大小为$2^{20}$B。</p></blockquote><p>&emsp;&emsp;因为主存大小为$2^{20}$B,且以512B为传送单位。那么$2^{20}$B=2048块$ \times $512B/块，主存可以划分为2048块，主存地址为20位二进制数。因为我们需要确定要取的是块中的哪个字，又$512=2^9$，所以需要9位作为偏移量，或者说字块内地址。 Cache可以划分出16行($2^{13}$=16行 $\times$ 512B/行)，也就是说划出4位作为行号标记，或者说Cache字块地址。剩下的7位自然就作为主存字块标记啦。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162214235-403548343.png" alt=""></p><p>优缺点：</p><ul><li>电路实现简单，命中时间短</li><li>无需考虑替换问题</li><li>Cache的存储空间没有得到充分使用，命中率低</li></ul><h2 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h2><p>&emsp;&emsp;针对直接映射Cache空间利用率低的问题，我们有一种简单粗暴的办法提升空间的利用率。那就是主存中的任意一块都可以映射到Cache中的任意一个位置。有空位置你就坐下，随意，映射位置不在固定。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162229663-269157985.png" alt=""></p><p>&emsp;&emsp;那么我们唯一要做的就是知道Cache中是对应主存中的哪一块和字块内地址就行。因为是随便映射，所以我们把直接映射中的Cache字块标记合并到主存字块标记中。</p><p><code>全相联映射主存地址只有两部分：主存字块标记，字块内地址。</code></p><p>优缺点：</p><ul><li>不存在冲突缺失，命中率高</li><li>电路复杂，速度慢</li></ul><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p>&emsp;&emsp;综合前两种方法的就是组相联映射，具体做法是：将Cache中的行分组，主存块映射到固定的行中，但行中的位置可以随意。也就是组间直接映射，组内全相联映射。</p><blockquote><p>Cache组号=主存块号 mod Cache组数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162251696-1669819464.png" alt=""></p><p>&emsp;&emsp;那么问题来了怎么确定Cache中的字块是对应主存的那一块呢？首先我们仍需要字块内地址，需要区分组号，那么剩下的地址就可以作为主存字块标记使用。</p><blockquote><p>容量为64块的Cache，采用组相联方式映像，字块大小为128字，每4块为一组。若主存容量为4096块，且以字编址，那么主存地址该如何划分？</p></blockquote><p>&emsp;&emsp;因为$4096=2^{19}$，所以主存地址应该为19位，Cache总共有16组，所以需要4位确定组号。又字块大小为$128$字，$128=2^7$，所有字块内地址为7位，剩下的$19-7-4=8$位作为主存字块标记。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162305856-386316918.png" alt=""></p><p>优缺点：</p><ul><li>电路较简单，速度较快，命中率较高，属于比较理想的方式</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Cache地址映射&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://www.wulnut.top/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟地址和物理地址</title>
    <link href="https://www.wulnut.top/2020/10/16/virtual_address/"/>
    <id>https://www.wulnut.top/2020/10/16/virtual_address/</id>
    <published>2020-10-16T12:38:23.976Z</published>
    <updated>2020-11-02T06:55:06.308Z</updated>
    
    <content type="html"><![CDATA[<p>计算机中虚拟地址与物理地址</p><a id="more"></a><h1 id="一、了解基本概念"><a href="#一、了解基本概念" class="headerlink" title="一、了解基本概念"></a>一、了解基本概念</h1><h2 id="1-地址空间"><a href="#1-地址空间" class="headerlink" title="1.地址空间"></a>1.地址空间</h2><p>&emsp;&emsp;我们最开始接触地址的时候，应该是在我们学习数组的时候。地址空间其实是一个比较抽象的概念，我们可以把它想象成一个长的数组，每个数组元素占一个字节。那么这个数组的长度就由地址空间长度来决定。例如：我们32位的系统的地址空间就是我们的$2^{32}$字节(4GB),而64位的地址空间大小就是$2^{64}$个字节。这也就解释了在我们32位的操作系统，为什么最大只能支持4GB的有效内存。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/15774762-3a7d9d5ef4e0d886.webp" alt=" "></p><h2 id="2-虚拟地址的由来"><a href="#2-虚拟地址的由来" class="headerlink" title="2.虚拟地址的由来"></a>2.虚拟地址的由来</h2><p>&emsp;&emsp;在早期的计算机中，程序是直接运行到物理内存（可以理解为内存条上的内存）上的。也就是说，程序运行的时候直接访问的就是物理地址。如果，我们的一个计算机只运行一个程序，那么只有这个程序所需要的内存空间不超过物理内存空间的大小，就不会有问题。但是，我们正在希望的是在某个时候同时运行多个程序。那么这个时候，就会有个一个问题，计算机如何把有限的物理内存分配给多个程序使用呢？<br>&emsp;&emsp;某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A,接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。<br>&emsp;&emsp;问题1：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。<br>&emsp;&emsp;问题2：内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。<br>&emsp;&emsp;问题3：程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。但是我们的某些硬件是需要在固定的地址上去开始运行的，但是如果这个地址后边被我们的程序占有，那么我们对这块内存的修改，就可能导致某些硬件不可用了。<br>&emsp;&emsp;为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><h1 id="二、虚拟地址和物理地址映射"><a href="#二、虚拟地址和物理地址映射" class="headerlink" title="二、虚拟地址和物理地址映射"></a>二、虚拟地址和物理地址映射</h1><p>&emsp;&emsp;了解了我们的虚拟地址和物理地址的由来，下面我们来总结一下，他们的概念.<br>&emsp;&emsp;物理地址：物理地址空间是实在的存在于计算机中的一个实体，在每一台计算机中保持唯一独立性。我们可以称它为物理内存；如在32位的机器上，物理空间的大小理论上可以达到$2^{32}$字节(4GB)，但如果实际装了512的内存，那么其物理地址真正的有效部分只有$512MB = 512 \times 1024 KB = = 512 \times 1024 \times 1024 B (0x00000000\sim0x1fffffff)$。其他部分是无效的。<br>&emsp;&emsp;虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是$0x00000000\sim0xFFFFFFFF$.每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，<br>这样做到了有效的隔离。<br>&emsp;&emsp;在上面我们提到了合理的内存管理机制。我们这里虚拟地址和物理地址之间的映射是通过MMU（内存管理单元）来完成的。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/15774762-b0ec5de9cf127f27.webp" alt=" "><br>&emsp;&emsp;我们平时操作的内存其实都是通过操作虚拟地址的内存单元。通过通过MMU的映射来间接的操作我们的物理地址。</p><h1 id="对虚地址的理解"><a href="#对虚地址的理解" class="headerlink" title="对虚地址的理解"></a>对虚地址的理解</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><ol><li>每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。</li><li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。</li><li>每个进程已经分配的内存空间，都与对应的磁盘空间映射。<br><br><br>问题：计算机明明没有那么多内存（n个进程的话就需要$n\times4$G）内存建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</li></ol><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><ol><li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li><li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li><li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。</li><li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。</li><li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处。</li><li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。</li><li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li></ol><p>&emsp;&emsp;另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码<br>（比如.text .data段）.拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）,等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，<br>要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机中虚拟地址与物理地址&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="杂谈" scheme="https://www.wulnut.top/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>超级源点与超级汇点</title>
    <link href="https://www.wulnut.top/2020/09/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(3)/"/>
    <id>https://www.wulnut.top/2020/09/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(3)/</id>
    <published>2020-09-27T15:57:36.269Z</published>
    <updated>2020-10-04T12:10:36.968Z</updated>
    
    <content type="html"><![CDATA[<p>超级源点与超级汇点<br><a id="more"></a></p><h1 id="背景1"><a href="#背景1" class="headerlink" title="背景1"></a>背景1</h1><p>给出题目，在一张图中有多个点起点，一个终点，求所有起点到终点的最短距离。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>跑N边单源最短路，但是这样是不行的肯定超时。</li><li>floyd求出所有最短路，枚举每个起点到终点的距离，这个似乎比法1更慢。</li><li>反向建边，反向跑一遍Dijkstra，或者SPFA，这样就能求到终点到起点的距离，在枚举最小的一个即可，时间复杂度为一遍最短路加枚举N。</li><li>建立超级源点，虚拟出一个点作为源点，源点到所有起点的距离都是0，那么这样求超级源点到终点的最短距离就是所有起点到终点的距离的最短一个，时间复杂度为一遍最短路。</li></ol><h1 id="背景2"><a href="#背景2" class="headerlink" title="背景2"></a>背景2</h1><p>给出一张图中有一个起点，有多个终点，求一个起点到所有终点的最短距离。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ol><li>直接忽略floyd</li><li>一遍最短路（SPFA或Dijkstra），枚举N。</li><li>建立超级汇点，所有终点到汇点的距离为0，一遍最短路即可的出答案。</li></ol><h1 id="背景3"><a href="#背景3" class="headerlink" title="背景3"></a>背景3</h1><p>给出一张图，图中有若干起点与若干终点，在所有终点到起点的距离中的最短距离。</p><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ol><li>跑若干遍最短路，找到所有最短距离，比较得出最小值</li><li>建立超级源点，建立超级汇点，一遍Dijkstra或SPFA即可。</li></ol><p>通过上面我们大致知道超级源点超级汇点的建立的条件，而且通过超级源点（汇点）可以极大的减少题目的时间复杂度，在图论中用的比较多。最后我们用图的方式表示源点及汇点的建立。</p><p><img src="/img/short-path/super1.png" alt="如图"></p><p><img src="/img/short-path/super2.png" alt="如图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;超级源点与超级汇点&lt;br&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.wulnut.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>最短路径之Dijkstra</title>
    <link href="https://www.wulnut.top/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/"/>
    <id>https://www.wulnut.top/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/</id>
    <published>2020-09-20T14:50:12.851Z</published>
    <updated>2020-09-27T15:58:50.063Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><p>&emsp;&emsp;在上一篇文章当中我们讲解了bellman-ford算法和spfa算法，其中spfa算法是我个人比较常用的算法，比赛当中几乎没有用过其他的最短路算法。但是spfa也是有缺点的，我们之前说过它的复杂度是<br>$O(kE)$，这里的E是边的数量。但有的时候边的数量很多，E最多能够达到$V^2$，这会导致超时，所以我们会更换其他的算法。这里说的其他的算法就是Dijkstra。</p><h1 id="Dijkstra算法的前提："><a href="#Dijkstra算法的前提：" class="headerlink" title="Dijkstra算法的前提："></a>Dijkstra算法的前提：</h1><ol><li>首先，Dijkstra处理的是带正权值的<code>有权图</code>，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达(边)的权值大小。<code>(邻接矩阵或者邻接表存储)</code></li><li>其次，还需要一个<code>bool数组</code>判断那些点已经确定最短长度，那些点没有确定。<code>int数组</code>记录距离<code>(在算法执行过程可能被多次更新)</code>。</li><li>需要<code>优先队列</code>加入<code>已经确定点的周围点</code>。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。(优化后)</li></ol><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>&emsp;&emsp;在上一篇文章当中我们曾经说过Bellman-ford算法本质上其实是动态规划算法，我们的状态就是每个点的最短距离，策略就是可行的边，由于一共最多要松弛V-1次，所以整体的算法复杂度很高。当我们用队列维护可以松弛的点之后，就将复杂度降到了<br>$O(kE)$，也就是spfa算法。<br>&emsp;&emsp;Dijkstra算法和Bellman-ford算法虽然都是最短路算法，但是核心的逻辑并不相同。Dijkstra算法的底层逻辑是贪心，也可以理解成贪心算法在图论当中的使用。<br>&emsp;&emsp;其实Dijstra算法和Bellman-ford算法类似，也是一个松弛的过程。即一开始的时候除了源点s之外，其他的点的距离都设置成无穷大，我们需要遍历这张图对这些距离进行松弛。所谓的松弛也就是要将这些距离变小。假设我们已经求到了两个点u和v的距离，我们用<br>dis[u]表示u到s的距离，dis[v]表示v的距离。</p><p>&emsp;&emsp;假设我们有dis[u] &lt; dis[v]，也就是说u离s更近，那么我们接下来要用一个新的点去搜索松弛的可能，u和v哪一个更有可能获得更好的结果呢？当然是u，所以我们选择u去进行新的松弛，这也就是贪心算法的体现。如果这一层理解了，算法的整个原理也就差不多<br>了。</p><p>我们来整理一下思路来看下完整的算法流程：</p><ol><li>我们用一个数组dis记录源点s到其他点的最短距离，起始时dis[s] = 0，其他值设为无穷大</li><li>我们从未访问过的点当中选择距离最小的点u，将它标记为已访问</li><li>遍历u所有可以连通的点v，如果dis[v] &lt; dis[u] + l[u] [v]，那么更新dis[v]</li><li>重复上述2，3两个步骤，直到所有可以访问的点都已经访问过</li></ol><p>怎么样，其实核心步骤只有两步，应该很好理解吧？我找到了一张不错的动图，大家可以根据上面的流程对照一下动图加深一下理解。</p><p><img src="/img/short-path/dijkstra.gif" alt="如图"><br>我们根据原理不难写出代码：<br>C++版本：<br><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> g[N][N];<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">int</span> st[N];<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);        dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp;(t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j])) &#123;                t = j;            &#125;        &#125;        st[t] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            dis[j] = min(dis[j], dis[t] + g[t][j]);        &#125;    &#125;        <span class="hljs-keyword">if</span>(dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dis[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);    <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        g[a][b] = min(g[a][b], c);    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dijkstra());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><p>Pyhon版本：<br><pre><code class="hljs Python">INF = sys.maxsizeedges = [[]] <span class="hljs-comment"># 邻接表存储边</span>dis = [] <span class="hljs-comment"># 记录s到其他点的距离</span>visited = &#123;&#125; <span class="hljs-comment"># 记录访问过的点</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    mini = INF    u = <span class="hljs-number">0</span>    flag = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 遍历所有未访问过点当中距离最小的</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V):        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited <span class="hljs-keyword">and</span> dis[i] &lt; mini:            mini, u = dis[i], i            flag = <span class="hljs-literal">True</span>                <span class="hljs-comment"># 如果没有未访问的点，则退出</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:        <span class="hljs-keyword">break</span>         visited[u] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        dis[v] = <span class="hljs-built_in">min</span>(dis[v], dis[u] + l)</code></pre></p><p>&emsp;&emsp;虽然我们已经知道算法没有反例了，但是还是可以思考一下。主要的点在于我们每次都选择未访问的点进行松弛，有没有可能我们松弛了一个已经访问的点，由于它已经被松弛过了，导致后面没法拿来松弛其他的点呢？<br>&emsp;&emsp;其实是不可能的，因为我们每次选择的都是距离最小的未访问过的点。假设当前的点是u，我们找到了一个已经访问过的点v，是不可能存在dis[u] + l &lt; dis[v]的，因为dis[v]必然要小于dis[u]，v才有可能先于u访问。但是这有一个前提，就是每条边的长度不<br>能是负数。</p><h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><p>&emsp;&emsp;和Bellman-ford算法一样，Dijkstra算法最大的问题同样是复杂度。我们每次选择一个点进行松弛，选择的时候需要遍历一遍所有的点，显然这是非常耗时的。复杂度应该是$O(V^2 + E)$，这里的E是边的数量，Dijkstra中每个点只会松弛一次，也就意味着每条<br>边最多遍历一次。<br>&emsp;&emsp;我们观察一下会发现，外面这层循环也就算了，里面这层循环很没有必要，我们只是找了一个最值而已。完全可以使用数据结构来代替循环查询，维护最值的场景我们也已经非常熟悉了，当然是使用优先队列。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>一般从选定点开始抛入优先队列。（路径一般为0），<code>bool数组</code>标记0的位置(最短为0) , 然后0周围连通的点抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内<code>(如果小于就更新，大于就不动，初始第一次是无穷肯定会更新)</code>，第一次就结束了</li><li>从队列中抛出距离最近的那个点B（第一次就是0周围邻居）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为true，<code>并且将这个点的邻居加入队列</code>(下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过B点计算各个位置的<br>长度，如果小于则更新！<br><img src="/img/short-path/dijkstra1.png" alt="如图"></li><li>重复二的操作，直到所有点都确定。<br><img src="/img/short-path/dijkstra2.png" alt="如图"></li></ul><p><a class="btn" href="https://www.acwing.com/problem/content/description/852/" title="title">参考题目</a></p><p>C++版本：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;<span class="hljs-keyword">int</span> dist[N], heap[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span> (heap.size())    &#123;        PII t = heap.top();        heap.pop();        <span class="hljs-keyword">int</span> ver = t.second; <span class="hljs-comment">//distance = t.first;</span>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;        st[ver] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])        &#123;            <span class="hljs-keyword">int</span> j = e[i];            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] = dist[ver] + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dist[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dijkstra());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Pyhon版本：</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> heapq<span class="hljs-keyword">import</span> sys<span class="hljs-comment"># 优先队列</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, item, priority</span>):</span>        <span class="hljs-comment"># 传入两个参数，一个是存放元素的数组，另一个是要存储的元素，这里是一个元组。</span>        <span class="hljs-comment"># 由于heap内部默认由小到大排，所以对priority取负数</span>        heapq.heappush(self._queue, (-priority, self._index, item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[-<span class="hljs-number">1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self._queue) == <span class="hljs-number">0</span>que = PriorityQueue()INF = sys.maxsizeedges = [[], [[<span class="hljs-number">2</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">14</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">15</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">11</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]] <span class="hljs-comment"># 邻接表存储边</span>dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)] <span class="hljs-comment"># 记录s到其他点的距离</span>s = <span class="hljs-number">1</span>que.push(s, <span class="hljs-number">0</span>)dis[s] = <span class="hljs-number">0</span>visited = &#123;&#125;<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():    u, d = que.pop()    <span class="hljs-keyword">if</span> d != dis[u]:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            que.push(v, dis[v])print(dis)</code></pre><p>Java版本：<br><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-keyword">import</span> java.util.PriorityQueue;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dijkstra</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">int</span> x; <span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> lenth;<span class="hljs-comment">//长度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> lenth)</span> </span>&#123;<span class="hljs-keyword">this</span>.x=x;<span class="hljs-keyword">this</span>.lenth=lenth;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//记录权值，顺便记录链接情况，可以考虑附加邻接表</span>initmap(map);<span class="hljs-comment">//初始化</span><span class="hljs-keyword">boolean</span> bool[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//判断是否已经确定</span><span class="hljs-keyword">int</span> len[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//长度</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;len[i]=Integer.MAX_VALUE;&#125;Queue&lt;node&gt;q1=<span class="hljs-keyword">new</span> PriorityQueue&lt;node&gt;(com);len[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//从0这个点开始</span>q1.add(<span class="hljs-keyword">new</span> node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//计算执行了几次dijkstra</span><span class="hljs-keyword">while</span> (!q1.isEmpty()) &#123;node t1=q1.poll();<span class="hljs-keyword">int</span> index=t1.x;<span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> length=t1.lenth;<span class="hljs-comment">//节点当前点距离</span>bool[index]=<span class="hljs-keyword">true</span>;<span class="hljs-comment">//抛出的点确定</span>count++;<span class="hljs-comment">//其实执行了6次就可以确定就不需要继续执行了  这句可有可无，有了减少计算次数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;map[index].length;i++)&#123;<span class="hljs-keyword">if</span>(map[index][i]&gt;<span class="hljs-number">0</span>&amp;&amp;!bool[i])&#123;node node=<span class="hljs-keyword">new</span> node(i, length+map[index][i]);<span class="hljs-keyword">if</span>(len[i]&gt;node.lenth)<span class="hljs-comment">//需要更新节点的时候更新节点并加入队列</span>&#123;len[i]=node.lenth;q1.add(node);&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;System.out.println(len[i]);&#125;&#125;<span class="hljs-keyword">static</span> Comparator&lt;node&gt;com=<span class="hljs-keyword">new</span> Comparator&lt;node&gt;() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(node o1, node o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o1.lenth-o2.lenth;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initmap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] map)</span> </span>&#123;map[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;&#125;&#125;</code></pre></p><p>&emsp;&emsp;这里用visited来判断是否之前访问过的主要目的是为了防止负环的产生，这样程序会陷入死循环，如果确定程序不存在负边的话，其实可以没必要判断。因为先出队列的一定更优，不会存在之后还被更新的情况。如果想不明白这点加上判断也没有关系。<br>&emsp;&emsp;我们最后分析一下复杂度，每个点最多用来松弛其他点一次，加上优先队列的调整耗时，整体的复杂度是$O(V \log V+E)$，比之前$O(V^2+E)$的复杂度要提速了很多，非常适合边很多，点相对较少的图。有时候spfa卡时间了，我们会选择Dijkstra。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最短路径算法&lt;/p&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.wulnut.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>最短路径之bellman-ford&amp;SPFA</title>
    <link href="https://www.wulnut.top/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/"/>
    <id>https://www.wulnut.top/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/</id>
    <published>2020-09-17T10:33:31.039Z</published>
    <updated>2020-09-27T15:58:46.618Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>&emsp;&emsp;最短路问题也属于图论算法之一，解决的是在一张有向图当中点与点之间的最短距离问题。最短路算法有很多，比较常用的有bellman-ford、dijkstra、floyd、spfa等等。这些算法当中主要可以分成两个分支，其中一个是<br>bellman-ford及其衍生出来的spfa，另外一个分支是dijkstra以及其优化版本。floyd复杂度比较高，一般不太常用。<br>&emsp;&emsp;这次就先简单说一下bellman-ford和SPFA算法。</p><h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>我们要对一张有向图计算最短路，那么我们首先要做的就是将一张图存储下来。关于图的存储的数据结构，常用的方法有很多种。最简单的是邻接矩阵，所谓的邻接矩阵就是用一个二维矩阵存储每两个点之间的距离。如果两个点之间没有边相连，那么设为无穷大。</p><p><img src="/img/short-path/save-Graph.png" alt="如图"></p><p>&emsp;&emsp;这种方法的好处就是<code>非常直观</code>，实现也很简单，但是这中方法所消耗的时间复杂度也是很高的 $V^2$,这里的V指的是顶点的数量当顶点的数量稍稍大一些之后，带来的开销是非常庞大的。一般情况下我们的图的边的密集程度是不高<br>的，也就是说大量点和点之间没有边相连，我们浪费了很多空间。<code>一般情况下当边是顶点的10倍时(也就是稠密图)我们选择这种存图方式,此外我们就选择邻接表的方式来存储稀疏图</code></p><p>&emsp;&emsp;所谓的邻接表也就是说我们把顶点一字排开存入数组当中，每个顶点对应一条链表。这条链表当中存储了这个点可以到达的其他点的信息。邻接表的好处是可以最大化利用空间，有多少条边存储多少信息。但是也有缺点，除了实现稍稍复<br>杂一点之外，另外一个明显的缺点就是我们<code>没办法直接判断两点之间是否有边存在</code>，必须要遍历链表才可以。除了邻接矩阵和邻接表之外，还有一些其他的数据结构可以完成图的存储。比如前向星、边集数组、链式前向星等等。这些数据结构并没有<br>比邻接表有质的突破，对于非算法竞赛同学来说，能够熟练用好邻接表也就足够了。</p><h2 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman-ford算法"></a>bellman-ford算法</h2><p>&emsp;&emsp;刚才上面描述当中提到的算法除了floyd算法是计算的所有点对之间的最短距离之外，其他算法解决的都是单源点最短路的问题。所谓的单源点可以简单理解成单个的出发点，也就是说我们求的是从图上的一个点出发去往其他每个点的最短<br>距离。既然如此，我们的出发点以及到达点都是确定的，不确定的只是它们之间的距离而已。</p><p>&emsp;&emsp;为什么我们会将bellman-ford算法和dijkstra算法区分开呢？因为两者的底层逻辑是不同的，bellman-ford算法的底层逻辑是动态规划， 而dijkstra算法的底层逻辑是贪心。</p><p>&emsp;&emsp;bellman-ford算法的得名也和人有关，我们之前在介绍KMP算法的时候曾经说过。由于英文表意能力不强，所以很多算法和公式都是以人名来取名。bellman-ford是Richard Bellman 和 Lester Ford 分别发表的，实际上还有一个<br>叫Edward F. Moore也发表了这个算法，所以有的地方会称为是Bellman-Ford-Moore 算法。</p><p>&emsp;&emsp;算法的原理非常简单，利用了动态规划的思想来维护源点出发到各个点的最短距离。</p><p>&emsp;&emsp;它的核心思维是松弛，所谓的松弛可以理解成找到了更短的路径对原路径进行更新。对于一个有V个节点的有向图进行V-1轮松弛，从而找到源点到所有点的最短距离。</p><p>&emsp;&emsp;初始的时候我们会用一个数组记录源点到其他所有点的距离，对于与源点直接相连的点来说，这个距离就是它和源点的距离否则则是无穷大。对于第一轮松弛来说，我们寻找的是源点出发经过一个点到达其他点的最短距离。我们用s代表源<br>点，我们寻找的就是s经过点a到达点b，使得距离小于s直接到b的距离。</p><p>&emsp;&emsp;第二轮松弛就是寻找的s经过两个点到达第三个点的最短距离，同理，对于一个有V个点的图来说，两个点之间最多经过V-1个点，所以我们需要V-1轮松弛操作。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;    <span class="hljs-keyword">for</span> (var j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;//对m条边进行循环      var edge = edges[j];      // 松弛操作      <span class="hljs-keyword">if</span> (distance[edge.to] &gt; distance[edge.<span class="hljs-keyword">from</span>] + edge.weight )&#123;         distance[edge.to] = distance[edge.<span class="hljs-keyword">from</span>] + edge.weight;      &#125;    &#125;&#125;</code></pre><p>&emsp;&emsp;Bellman-ford的算法很好理解，实现也不难，但是它有一个缺点就是复杂度很高。我们前面说了一共需要V-1轮松弛，每一轮松弛我们都需要遍历E条边，所以整体的复杂度是$O(VE)$，E指的是边的数量。想想看，假设对于一个有1w个顶点，10w条边的<br>图来说，这个算法是显然无法得出结果的。</p><p>&emsp;&emsp;所以为了提高算法的可用性，我们必须对这个算法进行优化。我们来分析一下复杂度巨大的原因，主要在两个地方，一个地方是我们松弛了V-1次，另外一个地方是我们枚举了所有的边。松弛V-1次是不可避免的，因为可能存在极端的情况需要V-1次松弛<br>才可以达成。但我们每次都枚举了所有的边感觉有点浪费，因为其中大部分的边是不可能达成新的松弛的。那有没有办法我们筛选出来可能构成新的松弛的边呢？</p><p>&emsp;&emsp;针对这个问题的思考和优化引出了新的算法——spfa。</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>&emsp;&emsp;SPFA算法的英文全称是Shortest Path Faster Algorithm，从名字上我们就看得出来这个算法的最大特点就是快。它比Bellman-ford要快上许多倍，它的复杂度是$O(kE)$，这里的k是一个小于等于2的常数。</p><p>&emsp;&emsp;SPFA的核心原理和Bellman-ford算法是一样的，也是对点的松弛。只不过它优化了复杂度，优化的方法也很简单，用一个队列维护了可能存在新的松弛的点。这样我们每次从这些点出发去寻找其他可以松弛的点加入队列，这里面的原理<br>很简单，只有被松弛过的点才有可能去松弛其他的点。</p><p>&emsp;&emsp;SPFA的代码也很短，实现起来难度很低，单单从代码上来看和普通的宽搜区别并不大。</p><p>Python版本：<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queueque = Queue()<span class="hljs-comment"># 邻接表存储边</span>edges = [[]]<span class="hljs-comment"># 维护是否在队列当中</span>visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V)]dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V)]dis[s] = <span class="hljs-number">0</span>que.put(s)visited[s] = <span class="hljs-literal">True</span><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.emtpy():    u = que.get()    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:                que.add(v)                visited[v] = <span class="hljs-literal">True</span>                    visited[u] = <span class="hljs-literal">False</span></code></pre></p><p><a class="btn" href="https://www.acwing.com/problem/content/853/" title="title">参考题目</a></p><p>C++版本：<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], e[N], ne[N], w[N], idx;<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    q.push(<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> ( !q.empty() ) &#123;        <span class="hljs-keyword">int</span> t = q.front();        q.pop();                st[t] = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;            <span class="hljs-keyword">int</span> j = e[i];                        <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i]) &#123;                dis[j] = dis[t] + w[i];                st[j] = <span class="hljs-literal">true</span>;                q.push(j);            &#125;        &#125;    &#125;        <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[n];    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);        <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;        <span class="hljs-keyword">int</span> t = spfa();        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, t);&#125;</code></pre></p><p>Python版；<br><pre><code class="hljs python">n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<span class="hljs-comment">## 用一个list 记录所有边的信息即可</span>g = []dist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    g.append([a, b, w])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bellman_ford</span>():</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>    <span class="hljs-comment">## 循环几次代表最多用几条边</span>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):        <span class="hljs-comment">## 必须backup 防止在过程中会更新dist里面的数据导致并不是最多k条边</span>        backup = dist[:]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            a, b, w = g[i][<span class="hljs-number">0</span>], g[i][<span class="hljs-number">1</span>], g[i][<span class="hljs-number">2</span>]            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w)bellman_ford()print(dist[n] <span class="hljs-keyword">if</span> dist[n] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;impossible&quot;</span>)</code></pre></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最短路径算法&lt;/p&gt;</summary>
    
    
    
    <category term="图论" scheme="https://www.wulnut.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>公告 | 🔊 置顶</title>
    <link href="https://www.wulnut.top/2020/09/15/%E7%BD%AE%E9%A1%B6/"/>
    <id>https://www.wulnut.top/2020/09/15/%E7%BD%AE%E9%A1%B6/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-10-04T12:13:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;</p><a id="more"></a><style>section {    width: 100%;    height: 100px;    /*border: 1px solid red;*/    display: flex;    justify-content: space-around;    align-items: center;}section .section_item {    /*border: 1px solid blue;*/    position: relative;    display: flex;    justify-content: center;    align-items: center;    transition: filter 0.5s, transform 0.5s;}section .section_item .a {    color: #ffffff;    font-size: 2vw;    top: 0;    opacity: 1;    transition: top 0.5s, opacity 0.5s;}section .section_item .a:nth-child(1) {    position: absolute;    clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%);}section .section_item .a:nth-child(2) {    position: relative;    clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%);}/*出发景深效果*/section:hover .section_item {    filter: blur(10px);    transform: scale(0.8);    transition: filter 0.5s, transform 0.5s;}/*对应取消景深效果*/section .section_item:hover {    filter: blur(0px);    transform: scale(1.1);    transition: filter 0.5s, transform 0.5s;}section .section_item:hover .a:nth-child(1) {    top: -40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item:hover .a:nth-child(2) {    top: 40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item a {    position: absolute;    color: #fff;    text-decoration: none;    opacity: 0;    transition: opacity 0.5s;}section .section_item a:hover {    text-decoration: underline;}section .section_item:hover a {    opacity: 1;    transition: opacity 0.5s;}.Photo img{    border-radius:25px;    box-shadow: 10px 10px 10px rgba(0,0,0,.5);    -moz-box-shadow: 10px 10px 10px rgba(0,0,0,.5) outset;    -webkit-box-shadow: 10px 10px 10px rgba(0,0,0,.5);}</style>  <!-- <section>        <div class="section_item">            <div class="a">Before.</div>            <div class="a">Before.</div>            <a class="btn" href="" title="title">六级</a>        </div>        <div class="section_item">            <div class="a">Now.</div>            <div class="a">Now.</div>            <a class="btn" href="" title="title">六级</a>        </div>        <div class="section_item">            <div class="a">After.</div>            <div class="a">After.</div>            <a class="btn" href="" title="title">六级</a>        </div></section> --><div class = "Photo"><center>    <img src = "https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/Top-2.jpg" alt = "photo" /></center><br><br><br><center><!-- 生老病死，衣食住行，这是我的奋斗，也是你的奋斗 -->一旦你决定好职业，你必须全心投入工作中，你必须爱你的工作，千万不要有怨言，你必须穷尽一生磨练技能，这就是成功的秘诀，也是让大家尊敬你的关键。</center></div><script>$(window).resize(function () {    resizeList();})function resizeList(){    var s_width=$(window).width();        //console.log("s_width:"+s_width);        if(s_width>600 && s_width <=1280)        {            $(".list-table1 li").css("width","25%");        }else if(s_width>400 && s_width <=600){            $(".list-table1 li").css("width","33.3%");        }else if(s_width>200 && s_width <=400){            $(".list-table1 li").css("width","50%");        }else if(s_width<=200){             $(".list-table1 li").css("width","100%");        }}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何配置与安装maven</title>
    <link href="https://www.wulnut.top/2020/07/11/maven%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.wulnut.top/2020/07/11/maven%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-11T09:30:47.941Z</published>
    <updated>2020-07-11T10:34:52.668Z</updated>
    
    <content type="html"><![CDATA[<p>介绍以下如何安装与配置maven</p><a id="more"></a><h1 id="一、-安装本地Maven"><a href="#一、-安装本地Maven" class="headerlink" title="一、 安装本地Maven"></a>一、 安装本地Maven</h1><ol><li><p>进入<a href="https://maven.apache.org/download.cgi">Apache maven官网</a>下载maven</p></li><li><p>点击左侧Download </p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_download.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">下载</div></center><ol><li><p>点击这个连接然后下载</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_download2.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">下载</div></center></li><li><p>下载完成之后，任意找一个文件夹存入然后解压</p></li><li>然后就开始配置环境变量了<ul><li>系统变量：MAVEN_HOME = ..\apache-maven-3.63</li><li>系统变量：path: %MAVEN_HOME%\bin</li></ul></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path3.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><h1 id="二、配置settings文件"><a href="#二、配置settings文件" class="headerlink" title="二、配置settings文件"></a>二、配置settings文件</h1><ol><li>在你放置maven文件的文件夹里找到conf文件夹然后可以在conf文件夹中找到setting文件</li><li>找到第52行，这里是设置maven默认的默认本地仓库。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li></ol><ol><li>我们复制第53行</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/path/to/local/repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>将它拿到注释外并将中间的内容改成你需要的路径，如图</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>F:/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>注意这个repository需要自己建,这里的路径随便设置，注意这里是正斜杠</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning)</li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阿里云仓库 --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-comment">&lt;!--或者--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><ol><li><p>如图，要夹在两个mirrors标签之间</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo3.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li><li><p>在最后配置jdk，也要夹在两个profiles标签之间</p></li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- java版本 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo4.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功</li></ol><p>最后，如果你使用的idea作为Java的IDE， 我们是可以将idea的maven仓库设置为本地仓库。<br>File -&gt; Build, Execution, Deployment -&gt; Maven修在下面两个参数就可以了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_idea.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍以下如何安装与配置maven&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://www.wulnut.top/categories/Notes/"/>
    
    
    <category term="Java" scheme="https://www.wulnut.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>半年记</title>
    <link href="https://www.wulnut.top/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    <id>https://www.wulnut.top/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/</id>
    <published>2020-07-02T14:43:33.527Z</published>
    <updated>2020-07-03T09:16:38.621Z</updated>
    
    <content type="html"><![CDATA[<p>简单的总结一下这荒废的半个学期</p><a id="more"></a><h1 id="一切都是要从蝙蝠说起"><a href="#一切都是要从蝙蝠说起" class="headerlink" title="一切都是要从蝙蝠说起"></a>一切都是要从蝙蝠说起</h1><p>&emsp;&emsp;由于2019年起的一只蝙蝠，我们的生活出现了天翻地覆的变化。在家隔离遵守防疫要求，争取不给国家添乱。在家度过了我最为魔幻的一个寒假，虽然在家但是我丝毫没感受到无聊，相反还发生了很多有趣的事情，我觉得我有必要对期间发生的经过找时间好好记录一下。</p><h2 id="这可能是高中时所期盼的"><a href="#这可能是高中时所期盼的" class="headerlink" title="这可能是高中时所期盼的"></a>这可能是高中时所期盼的</h2><p>&emsp;&emsp;上高中的时候总想着能在大学过的舒服，还能有超长的假期，每次在寒暑假结束的时候大家总会调侃：“嗯你假期余额已不足请及时充值”。不过很对不这个恐怖故事真的出现了.</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear2.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><p>&emsp;&emsp;虽然没有上图那么恐怖，但是我寒假确实涨了不少这一涨就是一个学期。线下教学也随之敲定转为线上。刚开始上网课，还每天幻想<br>嗯等等3月份学校就会要我们回去了。但是在一次和周老师的聊天中得知广东那边的学校可能会在6月底开学，一开始对这个差异的消息还是还保持着<br>怀疑态度，每天上课老师也在和我们预测学校会在什么时候开学，武汉什么时候解封这样的话题。但是慢慢的，随着北师大说今年上半年不开学、听<br>到华科的朋友说他们辅导员发长文警告那些期待等回学校再补课的同学要好好学习的截图，时我才意识到今年武汉上边年不开学，可能是真的了做好打持久战的准备是一定的了。<br>&emsp;&emsp;果然随着所有课程全部转入线上教学的开始，上半年在家学习也就真的出现了。但是我对线上教学有着强烈的抵触情绪，根本没有想跟着老师的节奏好好在家里学习本学期既定的课程，“我上不了985，我看985的网课还不行么”这句话虽然搞笑，但确十分真实。线上上课老师和学校也是绞尽脑汁，督促学生好好在线上学习，不要逃课。可是呢？有些老师总喜欢用着骗三岁小孩的话来骗我们，制定了一些十分好笑的条条框框，什么早自习打卡啊、晚自习打卡啊等等吧。打完卡再去睡觉然后等到开课在起床这样操作，不用说也有人会做。但是有些人就是爱与面子，说自己按时打卡学习早读，晚自习。当然我也认识真正这样做的人。为此我也背上了逃早自这样的搞笑的名号。嗯大三了我看大家谁，睡得香~<br>&emsp;&emsp;虽然说我不想听老师线上的讲课，但是我又害怕错过一些知识。说白了就是“贱”，上网课就挂在那里假惺惺的听老师的讲课然后把声音调到最小，自己看各大名校的网课视频。这也算是我在名校学习了吧Hhhh。不得不说中科大概率真香，听课真如醍醐灌顶一样，想我基础这么差的，在学习玩之后也能明白个八九不离十，还有翁恺的程序课，不说了质量真的高，比上课讲所谓的算法题要实在的多，带你一步一步实现一个小小的项目，并学习其中的一些关键词和用法。比上课听理论，缺乏实践要来的实在的多，虽然不能说我做题一定能做对，但是我用一定用的恰到好处。<br>&emsp;&emsp;当然也是由于课程安排的原因周么也就只能休息一天，不过我大部分时间也是花在了学习网课上了，其实去完成自己的兴趣也是极少<br>并没有我想的那种可以搞搞别的事情，学习一下新的知识。也不知道该怎么形容，新的看的眼馋，旧也不想丢。两手抓，最终还是没干成一样。</p><h2 id="在家时间过的真的很快"><a href="#在家时间过的真的很快" class="headerlink" title="在家时间过的真的很快"></a>在家时间过的真的很快</h2><p>&emsp;&emsp;不得不说在家学习的时间过的真的很快虽然天天在上课，但是循环往复时间也就一下没了。到了5月份参加了一些无聊的比赛，每天熬夜到深夜，感觉自己很充实每天都很忙，要做好多事情。但是呢其实我啥也没干成，自己还累的够呛。感觉那段时间自己写了7、8万字，每天都在对着键盘打字。因为时间紧迫，外加上学长的催促。就想机器一样每天都在赶工期完成以下我都不知道我在干什么的东西。(退坑了退坑了，后面不能再参加了)<br>&emsp;&emsp;晃一晃这个学期就没几周了，扫清了比赛的事情之后就是专心的学习，我尝试认真的听老师上课，但是我还是放弃了。上一次课3、4<br>个小时的煎熬，虽然老师讲的很拖沓，但是知识含量太高一下子真的接受不了。还是自己看吧….</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear3.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;当然这🐕学习通，真是想个毒瘤一样。学习通上的成堆的视频，都要计入平时分今年平时分还是55开(上香)。我也就开始了疯狂的补补课模式，可能是我高估了学校期末考试的难度。总感觉自己的掌握程度不够，在文库找题做，针对知识点练习一下。我也很离奇的开始梳理知识结构因为我是真的觉得学的知识很乱，感觉没有形成知识体系。但是目前来说到现在我都没有形成知识体系。</p><h2 id="都是大佬"><a href="#都是大佬" class="headerlink" title="都是大佬"></a>都是大佬</h2><p>&emsp;&emsp;也就预习了尽一个月吧，中途周末实在是不行听课，就开车出去玩了一下。还是很开心的~然后就开始期末考试了，有人就喜欢🐕叫</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear4.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>当然我也是个儒雅随和的人，不和他计较。有冇搞错，管你咩事。我也在每次出成绩之后问了一下谁是最高分，我也没有听到你的名字呀。还专门买课本，在我这种垃圾面前卖弄自己了解到的知识。知识也分高低贵贱？</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear5.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;我也很庆幸我有一些很要好的朋友，和三个优秀的室友。虽然各有专攻但是大家在一起交流总是很快乐的。在不断学习的过程中，有人愿你和你解释交流，我觉得是一件很美好的事情。而不是自己守着自己所谓的优势，谦卑谦卑再谦卑。这也是我慢慢明白的，不是因为你知道的有多少，懂得有多少。我才会说你牛逼是大佬，你出来溜溜交流一下，光说不练假把式嘛，这一下子便高判立下。这个月我也感觉自己实在是浮躁，以前都说我浮躁，但是我总是不明白浮躁到是为什么。这个假期我也好像慢慢明白理解所谓的浮躁。脚踏实地，似乎才是最难实现的东西。为了一些论文<br>每天忙活，似乎还不如早点开始学习专业方向。认真学习一下什么是机器学习。复制百度百科我们谁都会。</p><p>&emsp;&emsp;先就说到这吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的总结一下这荒废的半个学期&lt;/p&gt;</summary>
    
    
    
    <category term="day" scheme="https://www.wulnut.top/categories/day/"/>
    
    
    <category term="day" scheme="https://www.wulnut.top/tags/day/"/>
    
  </entry>
  
  <entry>
    <title>SQL入门训练题</title>
    <link href="https://www.wulnut.top/2020/05/25/sql%E8%AE%AD%E7%BB%83/"/>
    <id>https://www.wulnut.top/2020/05/25/sql%E8%AE%AD%E7%BB%83/</id>
    <published>2020-05-25T13:43:06.477Z</published>
    <updated>2020-07-02T14:40:47.568Z</updated>
    
    <content type="html"><![CDATA[<p>sql训练题</p><p><a href="https://www.jianshu.com/p/476b52ee4f1b">https://www.jianshu.com/p/476b52ee4f1b</a></p><a id="more"></a><h2 id="数据表介绍"><a href="#数据表介绍" class="headerlink" title="数据表介绍"></a>数据表介绍</h2><p>—1.学生表<br>Student(SId,Sname,Sage,Ssex)<br>—SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别</p><p>—2.课程表<br>Course(CId,Cname,TId)<br>—CId 课程编号,Cname 课程名称,TId 教师编号</p><p>—3.教师表<br>Teacher(TId,Tname)<br>—TId 教师编号,Tname 教师姓名</p><p>—4.成绩表<br>SC(SId,CId,score)<br>—SId 学生编号,CId 课程编号,score 分数</p><h2 id="学生表-Student"><a href="#学生表-Student" class="headerlink" title="学生表 Student"></a>学生表 Student</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sname <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sage datetime,Ssex <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-12-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-12-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;09&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span> , <span class="hljs-string">&#x27;2017-12-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;10&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2017-12-25&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;11&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2012-06-06&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span> , <span class="hljs-string">&#x27;赵六&#x27;</span> , <span class="hljs-string">&#x27;2013-06-13&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;13&#x27;</span> , <span class="hljs-string">&#x27;孙七&#x27;</span> , <span class="hljs-string">&#x27;2014-06-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);</code></pre><h2 id="科目表-Course"><a href="#科目表-Course" class="headerlink" title="科目表 Course"></a>科目表 Course</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),CId <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),score <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);</code></pre><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><ol><li>查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数<br>1.1 查询同时存在” 01 “课程和” 02 “课程的情况</li></ol><p>1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</p><p>1.3 查询不存在” 01 “课程但存在” 02 “课程的情况</p><ol><li><p>查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p></li><li><p>查询在 SC 表存在成绩的学生信息</p></li><li><p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</p></li></ol><p>4.1 查有成绩的学生信息</p><ol><li><p>查询「李」姓老师的数量</p></li><li><p>查询学过「张三」老师授课的同学的信息</p></li><li><p>查询没有学全所有课程的同学的信息</p></li><li><p>查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息</p></li><li><p>查询和” 01 “号的同学学习的课程 完全相同的其他同学的信息</p></li><li><p>查询没学过”张三”老师讲授的任一门课程的学生姓名</p></li><li><p>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p></li><li><p>检索” 01 “课程分数小于 60，按分数降序排列的学生信息</p></li><li><p>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p></li><li><p>查询各科成绩最高分、最低分和平均分：</p></li><li><p>以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</p></li><li><p>及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p></li><li><p>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时合并名次</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时保留名次空缺</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</p></li><li><p>统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</p></li><li><p>查询各科成绩前三名的记录</p></li><li><p>查询每门课程被选修的学生数</p></li><li><p>查询出只选修两门课程的学生学号和姓名</p></li><li><p>查询男生、女生人数</p></li><li><p>查询名字中含有「风」字的学生信息</p></li><li><p>查询同名同性学生名单，并统计同名人数</p></li><li><p>查询 1990 年出生的学生名单</p></li><li><p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p></li><li><p>查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩</p></li><li><p>查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p></li><li><p>查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</p></li><li><p>查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p></li><li><p>查询不及格的课程</p></li><li><p>查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名</p></li><li><p>求每门课程的学生人数</p></li><li><p>成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p></li><li><p>查询每门功成绩最好的前两名</p></li><li><p>统计每门课程的学生选修人数（超过 5 人的课程才统计）。</p></li><li><p>检索至少选修两门课程的学生学号</p></li><li><p>查询选修了全部课程的学生信息</p></li><li><p>查询各学生的年龄，只按年份来算</p></li><li><p>按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</p></li><li><p>查询本周过生日的学生</p></li><li><p>查询下周过生日的学生</p></li><li><p>查询本月过生日的学生</p></li><li><p>查询下月过生日的学生</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;sql训练题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/476b52ee4f1b&quot;&gt;https://www.jianshu.com/p/476b52ee4f1b&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="sql" scheme="https://www.wulnut.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>逻辑规则总结</title>
    <link href="https://www.wulnut.top/2020/05/23/logist/"/>
    <id>https://www.wulnut.top/2020/05/23/logist/</id>
    <published>2020-05-23T09:25:04.972Z</published>
    <updated>2020-06-14T15:05:42.949Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结逻辑推理规则与规律</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>&emsp;&emsp;由于数字逻辑种得推理规则与离散数学中得推理规则几乎是一模一样得。<br>对此讲有关逻辑推理部分进行总结。</p><h1 id="数字逻辑与离散数学"><a href="#数字逻辑与离散数学" class="headerlink" title="数字逻辑与离散数学"></a>数字逻辑与离散数学</h1><div class="table-container"><table><thead><tr><th>数字逻辑</th><th>离散数学</th></tr></thead><tbody><tr><td>或：$A$ $\cdot$  $B$</td><td>或: A $ \and B$</td></tr><tr><td>与: $A+B$</td><td>与: A $  \or B$</td></tr><tr><td>非:   $\overline{A}$</td><td>非: $ \neg A$</td></tr></tbody></table></div><h1 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h1><h2 id="基本公理"><a href="#基本公理" class="headerlink" title="基本公理"></a>基本公理</h2><ul><li>交换律：$A + B = B + A$   $or$  $A \cdot B = B \cdot A$</li><li>结合率：$(A + B)+C = A+(A+B)$   $or$   $(A \cdot B) \cdot C = A \cdot (B \cdot C)$</li><li>分配率：$A + (B \cdot C) = (A + B) \cdot (A + C)$    $or$   $A \cdot(B + C) = A \cdot B + A \cdot C$</li><li>$0-1$律：$A + 0 = A$  $or$  $A \cdot 1 = A$  $or$  $A + 1 = 1$  $or$  $A \cdot 0 = 0$</li><li>互补律：$\overline{A} + A = 1$  $or$  $\overline{A} \cdot A = 0$</li></ul><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><ul><li>定理1： $0 + 0 = 0$ 、$0 + 1 = 1$、 $1 + 0 = 1$、 $1 + 1 = 1$、$0 \cdot 0 = 0$、$0 \cdot 1 = 0$、 $1 \cdot 0 = 0$、 $1 \cdot 1 = 1$</li><li>重叠律： $A + A = A$   $or$  $A \cdot A = A$</li><li>吸收率： $A + A \cdot B = A$  $or$  $A \cdot(A + B) = A$</li><li>消因子法: $A + \overline{A} \cdot B = A + B$  $or$  $A \cdot(\overline{A} + B) = A \cdot B$</li><li>并项法： $A \cdot B + A \cdot \overline{B} = A$  $or$  $(A + B) \cdot (A + \overline{B}) = A$</li><li>消项法： $A \cdot B + \overline{A} \cdot C + B \cdot C = A \cdot B + \overline{A} \cdot C$  $or$  $(A + B) \cdot (\overline{A} + C) \cdot(B + C) = (A + B) \cdot (\overline{A} + C)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单总结逻辑推理规则与规律&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>快读</title>
    <link href="https://www.wulnut.top/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"/>
    <id>https://www.wulnut.top/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/</id>
    <published>2020-05-12T08:50:44.853Z</published>
    <updated>2020-05-15T14:47:30.760Z</updated>
    
    <content type="html"><![CDATA[<p>快读的一些方法</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在做数据结构、算法题的时候会遇见比较大的数，有的时候数据大小已经超过了int所能储存的范围，这样的大数如果比较多情况下如果使用普通的输入或者输出，超时就可能会发生，如果出现这样的错误，在算法时间复杂度没有问题的前提下出现这样的问题是非常令人头疼的一件事情。</p><p>这里我将从Java和C++两中语言入手，在减少这样的问题出现</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一、StreamTokenizer实现快速输入</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;</code></pre><p>定义如下：</p><pre><code class="hljs java">StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));</code></pre><p>StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：!@#$%^&amp;*()[]{})无法识别，会显示null</p><p>StreamTokenizer可以<strong>获取输入</strong>流并根据空格和回车分割成Token（标记），用nextToken方法读取下一个标记 </p><p>如果标记是字符串，用st.sval获取标记，如果是数字用st.nval获取标记，st.navl是double类型</p><p>示例</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));        st.nextToken();        String s=st.sval;        System.out.println(s);        st.nextToken();        <span class="hljs-keyword">double</span> n=st.nval;        System.out.println(n);        <span class="hljs-comment">/**输入内容</span><span class="hljs-comment">         * hollow 1233</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow</span><span class="hljs-comment">         * 1233.0</span><span class="hljs-comment">         */</span>            &#125; &#125;</code></pre><p>二、BufferedReader实现快速输入读一行</p><p>需要导入的jar</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;</code></pre><p>定义：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</code></pre><p>常用方法：</p><pre><code class="hljs java">inBuff.readLine()<span class="hljs-comment">//读取一行内容，返回字符串</span></code></pre><p>实例：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        String s=inBuff.readLine();        System.out.println(<span class="hljs-string">&quot;有问题吗&quot;</span>+s+<span class="hljs-string">&quot;没有吧&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world!</span><span class="hljs-comment">         * 有问题吗hollow world!没有吧</span><span class="hljs-comment">         */</span></code></pre><p>三、PrintWriter实现快速输出</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;</code></pre><p>定义如下：</p><pre><code class="hljs java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));</code></pre><p>常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 输出分为两步：</span><span class="hljs-comment">// 1、先通过print()或println()方法把需要输出的内容放入缓冲区，</span><span class="hljs-comment">// 2、然后通过flush()将缓冲区的内容输出到控制台</span>print(需要输出的内容)<span class="hljs-comment">//不换行输出，只是把需要的内容放入缓冲，</span>println(需要输出的内容)<span class="hljs-comment">//换行输出</span>flush()<span class="hljs-comment">//刷新缓冲区，把缓冲区的内容输出到控制台，</span></code></pre><p>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> CCPC;<span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));        String s=<span class="hljs-string">&quot;hollow world&quot;</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">12344</span>;        out.print(s+<span class="hljs-string">&quot; &quot;</span>+i);        out.flush();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world 12344</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre><p>一个例子<br><strong>一般建议使用BufferedRead()</strong><br><pre><code class="hljs java"><span class="hljs-comment">// https://www.acwing.com/problem/content/790/</span><span class="hljs-comment">// 使用BufferedReader读入的方法</span><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex4</span> </span>&#123;    <span class="hljs-comment">// 全局变量</span><span class="hljs-comment">//    static int N = 100010;  // 数据规模为 10w</span><span class="hljs-comment">//    static int[] arr = new int[N];</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-comment">// parseInt将字符串转为int</span>        <span class="hljs-comment">// parseDouble将字符转为double</span>        <span class="hljs-keyword">int</span> n = Integer.parseInt(reader.readLine());        String[] arrStr = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;            arr[i] = Integer.parseInt(arrStr[i]);        &#125;        reader.close();        <span class="hljs-keyword">long</span> ans = mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        System.out.println(ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> res = mergesort(arr, l, mid) + mergesort(arr,mid + <span class="hljs-number">1</span>, r);        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k ++] = arr[i ++];            <span class="hljs-keyword">else</span> &#123;                res += mid - i + <span class="hljs-number">1</span>;                temp[k ++] = arr[j ++];            &#125;        &#125;        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = arr[i ++];        <span class="hljs-keyword">while</span> (j &lt;=   r) temp[k ++] = arr[j ++];        <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) &#123;            arr[i] = temp[j];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="getchar读入"><a href="#getchar读入" class="headerlink" title="getchar读入"></a>getchar读入</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> , ch = getchar();    <span class="hljs-keyword">while</span>( !<span class="hljs-built_in">isdigit</span>( ch ) ) ch = getchar();    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">isdigit</span>( ch ) ) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span> , ch = getchar();    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>用时28.74s</p><h3 id="fread读入优化"><a href="#fread读入优化" class="headerlink" title="fread读入优化"></a>fread读入优化</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ibuf[<span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span>] , * s;    io()    &#123;        fread( s = ibuf , <span class="hljs-number">1</span> , <span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span> , <span class="hljs-built_in">stdin</span> );    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>( * s &lt; <span class="hljs-number">48</span> ) s++;        <span class="hljs-keyword">while</span>( * s &gt; <span class="hljs-number">32</span> )            u = u * <span class="hljs-number">10</span> + * s++ - <span class="hljs-number">48</span>;        <span class="hljs-keyword">return</span> u;    &#125;&#125; ip;</code></pre><p>用时1.535s</p><h3 id="当然如果觉得以上的方法比较麻烦可以："><a href="#当然如果觉得以上的方法比较麻烦可以：" class="headerlink" title="当然如果觉得以上的方法比较麻烦可以："></a>当然如果觉得以上的方法比较麻烦可以：</h3><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::ios::sync_with_stdio(<span class="hljs-literal">false</span>);</code></pre><p>通过对cin和cout的解除绑定可以达到和scanf于printf一样的速度有时候会更快</p><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><p><strong>cout</strong></p><p>用时102.2s</p><p><strong>printf</strong></p><p>用时27.36s</p><p><strong>puts（直接当字符串输出）</strong></p><p>用时2.001s</p><h3 id="putchar输出优化"><a href="#putchar输出优化" class="headerlink" title="putchar输出优化"></a>putchar输出优化</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);        x=-x;    &#125;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)        print(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;</code></pre><p>用时3.339s</p><h3 id="fwrite输出优化"><a href="#fwrite输出优化" class="headerlink" title="fwrite输出优化"></a>fwrite输出优化</h3><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">( <span class="hljs-keyword">register</span> T u )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> * q = a;        <span class="hljs-keyword">if</span>( !u ) * t++ = <span class="hljs-number">48</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>( u &lt; <span class="hljs-number">0</span> )                * t++ = <span class="hljs-number">45</span> , u *= <span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span>( u ) * q++ = u % <span class="hljs-number">10</span> + <span class="hljs-number">48</span> , u /= <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>( q != a )                * t++ = * --q;        &#125;    &#125;</code></pre><p>用时0.6653s</p><p><strong>由此可以看出，fwrite对比其他读入方式有极大的差距</strong></p><p>不过由于一般输出量都比较小，所以输出优化意义不大</p><h2 id="inline-define-register"><a href="#inline-define-register" class="headerlink" title="inline,define,register"></a>inline,define,register</h2><p>register就是把东西放到寄存器里面</p><p>比如for( int i = 1 ; i &lt;= n ; i++ )</p><p>可以写成for( register int i = 1 ; i &lt;= n ; i++ )</p><p>但是这个不一定有用，因为这个int可能编译器会帮你放寄存器里面</p><p><strong>for register short可能比for register int慢，因为short的寄存器更少..</strong><br><strong>大家for循环里面还是int比较好</strong></p><p>register在大部分情况下（特别是开了O2的时候）并没有明显的优化效果，如果加错了反而可能负优化</p><p>如果一个简单函数调用次数很多，属于瓶颈，调用时的传参可能会大大影响程序效率</p><p>这种情况下可以把这个函数给inline掉</p><p>inline就是把一个函数内联，可以减少跳转和传参的代价</p><p>但是如果这个函数过于复杂，可能并不会inline，可以考虑<strong>attribute</strong> ( ( always_inline ) )或者手动展开，或者define掉（注意define别爆炸）</p><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/qq_40079933/article/details/79419065">https://blog.csdn.net/qq_40079933/article/details/79419065</a></li><li><a href="https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua">https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;快读的一些方法&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Text Format</title>
    <link href="https://www.wulnut.top/2020/05/05/scenes1/"/>
    <id>https://www.wulnut.top/2020/05/05/scenes1/</id>
    <published>2020-05-05T15:20:18.417Z</published>
    <updated>2020-05-05T15:48:51.728Z</updated>
    
    <content type="html"><![CDATA[<p>manim 入门</p><a id="more"></a><h1 id="Text-format"><a href="#Text-format" class="headerlink" title="Text format"></a>Text format</h1><pre><code class="hljs 注意```:">&#96;&#96;&#96;python3from big_ol_pile_of_manim_imports import *</code></pre><p>在第一行</p><h2 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h2><pre><code class="hljs python3">class WriteText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/WriteText.gif" alt=" "></p><pre><code class="hljs python3">class AddText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.add(text)        self.wait(3)</code></pre><p><img src="/img/AddText.gif" alt=" "></p><pre><code class="hljs python3">class Formula(Scene):     def construct(self):         formula &#x3D; TexMobject(&quot;This is a formula&quot;)        self.play(Write(formula))        self.wait(3)</code></pre><p><img src="/img/Formula.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $this is a formula$,            $$this is a formula$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText2(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText2.gif" alt=" "></p><pre><code class="hljs python3">class DisplayFormula(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\displaystyle\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/DisplayFormula.gif" alt=" "></p><pre><code class="hljs python3">class TextInCenter(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInCenter.gif" alt=" "></p><pre><code class="hljs python3">class TextOnTopEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnTopEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnBottomEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnBottomEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnRightEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnRightEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnLeftEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(LEFT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnLeftEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextInUpperRightCorner(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP+RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInUpperRightCorner.gif" alt=" "></p><pre><code class="hljs python3">class TextInLowerLeftCorner(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;Text&quot;)         text.to_edge(LEFT+DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInLowerLeftCorner.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(0.25*UP)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/CustomPosition1.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(1*UP+1*RIGHT)        self.play(Write(textM),Write(textC))        self.wait(1)        textM.move_to(1*UP+1*RIGHT)         self.play(Write(textM))        self.wait(3)</code></pre><p><img src="/img/CustomPosition2.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.next_to(textC,LEFT,buff&#x3D;1)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition1.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP*0.1)        self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition2.gif" alt=" "></p><pre><code class="hljs python3">class RotateObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP)        textM.rotate(PI&#x2F;4) # &lt;- Radians        # You can use .rotate(45*DEGREES) too        self.play(Write(textM),Write(textC))        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI)        self.wait(2)</code></pre><p><img src="/img/RotateObject.gif" alt=" "></p><pre><code class="hljs python3">class FlipObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textM.flip(UP)        self.play(Write(textM))        self.wait(2)</code></pre><p><img src="/img/MirrorObject.gif" alt=" "></p><pre><code class="hljs python3">class SizeTextOnLaTeX(Scene):    def construct(self):        textHuge &#x3D; TextMobject(&quot;&#123;\\Huge Huge Text 012.\\#!?&#125; Text&quot;)        texthuge &#x3D; TextMobject(&quot;&#123;\\huge huge Text 012.\\#!?&#125; Text&quot;)        textLARGE &#x3D; TextMobject(&quot;&#123;\\LARGE LARGE Text 012.\\#!?&#125; Text&quot;)        textLarge &#x3D; TextMobject(&quot;&#123;\\Large Large Text 012.\\#!?&#125; Text&quot;)        textlarge &#x3D; TextMobject(&quot;&#123;\\large large Text 012.\\#!?&#125; Text&quot;)        textNormal &#x3D; TextMobject(&quot;&#123;\\normalsize normal Text 012.\\#!?&#125; Text&quot;)        textsmall &#x3D; TextMobject(&quot;&#123;\\small small Text 012.\\#!?&#125; Texto normal&quot;)        textfootnotesize &#x3D; TextMobject(&quot;&#123;\\footnotesize footnotesize Text 012.\\#!?&#125; Text&quot;)        textscriptsize &#x3D; TextMobject(&quot;&#123;\\scriptsize scriptsize Text 012.\\#!?&#125; Text&quot;)        texttiny &#x3D; TextMobject(&quot;&#123;\\tiny tiny Texto 012.\\#!?&#125; Text normal&quot;)        textHuge.to_edge(UP)        texthuge.next_to(textHuge,DOWN,buff&#x3D;0.1)        textLARGE.next_to(texthuge,DOWN,buff&#x3D;0.1)        textLarge.next_to(textLARGE,DOWN,buff&#x3D;0.1)        textlarge.next_to(textLarge,DOWN,buff&#x3D;0.1)        textNormal.next_to(textlarge,DOWN,buff&#x3D;0.1)        textsmall.next_to(textNormal,DOWN,buff&#x3D;0.1)        textfootnotesize.next_to(textsmall,DOWN,buff&#x3D;0.1)        textscriptsize.next_to(textfootnotesize,DOWN,buff&#x3D;0.1)        texttiny.next_to(textscriptsize,DOWN,buff&#x3D;0.1)        self.add(textHuge,texthuge,textLARGE,textLarge,textlarge,textNormal,textsmall,textfootnotesize,textscriptsize,texttiny)        self.wait(3)</code></pre><p><img src="/img/SizeTextOnLaTeX.gif" alt=" "></p><pre><code class="hljs python3">class TextFonts(Scene):    def construct(self):        textNormal &#x3D; TextMobject(&quot;\\textrm&#123;Roman serif text 012.\\#!?&#125; Text&quot;)        textItalic &#x3D; TextMobject(&quot;\\textit&#123;Italic text 012.\\#!?&#125; Text&quot;)        textTypewriter &#x3D; TextMobject(&quot;\\texttt&#123;Typewritter text 012.\\#!?&#125; Text&quot;)        textBold &#x3D; TextMobject(&quot;\\textbf&#123;Bold text 012.\\#!?&#125; Text&quot;)        textSL &#x3D; TextMobject(&quot;\\textsl&#123;Slanted text 012.\\#!?&#125; Text&quot;)        textSC &#x3D; TextMobject(&quot;\\textsc&#123;Small caps text 012.\\#!?&#125; Text&quot;)        textNormal.to_edge(UP)        textItalic.next_to(textNormal,DOWN,buff&#x3D;.5)        textTypewriter.next_to(textItalic,DOWN,buff&#x3D;.5)        textBold.next_to(textTypewriter,DOWN,buff&#x3D;.5)        textSL.next_to(textBold,DOWN,buff&#x3D;.5)        textSC.next_to(textSL,DOWN,buff&#x3D;.5)        self.add(textNormal,textItalic,textTypewriter,textBold,textSL,textSC)        self.wait(3)</code></pre><p><img src="/img/TextFonts.gif" alt=" "></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;manim 入门&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="python" scheme="https://www.wulnut.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>第一期半月谈</title>
    <link href="https://www.wulnut.top/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/"/>
    <id>https://www.wulnut.top/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/</id>
    <published>2020-05-02T14:42:30.941Z</published>
    <updated>2020-05-04T04:40:24.463Z</updated>
    
    <content type="html"><![CDATA[<p>这是是我对现在的简单思考</p><a id="more"></a><p>&emsp;&emsp;现在是5月1号，距离上次更新博客已经很久了。因为在家上课，所以时间非常自由。因为想参加一下蓝桥杯，来看看自己的专业水平到底怎么样。所以就慢慢开始准备学习算法起来了。</p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>&emsp;&emsp;在学习算法的过程种，我慢慢的对我自己的真实能有了比较全面的了解。从简单的基本算法开始到数据结构到图论</p><script type="math/tex; mode=display">基本算法\rightarrow 数据结构 \rightarrow 图论 \rightarrow \dots</script><p>说实话没得一步是简单的，是真的举步维艰。基本算法中的枚举、模拟、递归、分治$\dots$ 我感觉我到现在都没有真正学会其中的思想，每天坚持通过训练的方式来提高自己的对一些算法的理解，但是半天下来可能也就做了一两个题目，有时候思路开阔可能也就三四个，但是大部分时间也就是一两个的样子。可能是在家的原因，调板子没啥效率。但是这种挫败感是太真实了，随着渐渐对这种方向的深入了解。也就慢慢的明白自己知道东西实在是太少了，不断的从一些教学视频里面慢慢的学习前人总结出的经验。</p><p>但是这确实很可笑，你感觉你学会了一种算法，但是题目给你变一变，你就立马懵逼了。如果说做算法题可以类比成你高中的数学题的话，可能就是你题型见的不够多，总结的很少导致的。但这也是困难所在，虽然算法就那么多你这么能正真理解一个题目到底想怎么考你去使用这个算法是十分困难的。就拿前缀和为例</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> arr[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i], arr[i] += arr[i - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>前缀和就是那样很简单，就是一个arr[i] = arr[i - 1] + arr[i];的一个公式，在仔细看看其实是就是前$N$项求和，但是它有什么用？怎么用？可以干啥一般都是怎么处理的。</p><p>完完全全就需要你自己去总结思考，但是可能这种小技巧也只会出现在你解决某个题目中的一个小步骤中，但是有些人总是能把这种小技巧玩的出神入化，来降低时间复杂度。这就要看各位对这种技巧的理解了，没人能帮助你。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在知乎上经常能看到有人发这样的问题，“大神都是如何刷leetcode的”。我才这样的问这样问题的人都是一些为了找工作而去刷题的人。因为正真的大佬早已经在ACM类比赛中把算法这东西玩的炉火纯青了，你可能还在第一层，人家已经到了第五层了。其中有个人的回答很是亮眼，他说：你把打好的青春都浪费在刷LeetCode上那你为什么不把那些时间去研究一下新技术，学习一下技术的底层实现呢？看到一个题目思考了10分钟还没思路那就去看题解理解这个题目，花费那么长时间浪费在这上面不那么值得。就像郭杰瑞那期视频一样老郭做了江苏高考英语试卷但是到最后结果和大家想的一样，错了很多，是他英语差吗不是，那是人家的母语那是什么是缺乏这方面的训练。也就是说为什么我们刚开始学算法的时候为什么会那么痛苦，没有接收相关的训练很难一开始就上手完成的很好，针对的训练是至关重要的。</p><p>但是我反观一下自己，把大把的时间花在学习这些东西上是否也是一种浪费？当然不是，那是我以后吃饭的东西花费时间在这上面怎么算是浪费呢？但是我觉得我缺走上了歧途，什么歧途？</p><p>C++:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span>;&#125;</code></pre><p>Java:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">public</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;&#125;</code></pre><p>Python:</p><pre><code class="hljs python">print(<span class="hljs-string">&quot;Hello World&quot;</span>)</code></pre><p>JavaScript:</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello World&quot;</span>);</code></pre><p>我现在会四种语言来写出Hello World这个词，说明我了解了很多不同种类的编程语言但是，我确实不明白为什么我们要一开始去写一个Hello World。是因为他简单？其实并不是，学习编程每个人的目的是不同的，为什么现在社会上有那么多培训班，在短短是几个星期里面就能教出一个人去公司里面上班每个月拿着一两万的工资？因为现在很多东西被模式化了，</p><p>UADC(update, add, delete, create)这样的模式几乎符合任何情况，并不是人们想的通过编程来改变世界。如果说你被这种混口饭吃的想法所束缚，那你的发展也就那样的。那科班生和培训班的人也就没什么两样的了，科班生不只是有很多时间去打磨自己的能力，更多的是有时间去创造。这些语言归根到底是一种我们所特有的一种工具，而这种工具用来帮助我们把现实生活中的一些常见问题给抽象出来我们通过算法来反复重复的解决这种问题来方便我们。这才是我们的学习的正真目的，为什么说各个行业都需要会写程序的人，但是这些领域有时候又和计算机专业完全不沾边。但是就有人能去创造它方便行业快速发展，而这就是创造力。而不是仅仅的为了那一两行算法代码。这也是为什么说我<strong>没趣、死板、不懂审美</strong>$\dots$ 的原因。</p><p>被这种看起来死板的东西所束缚了，不能走出这种圈子，去学习了解更多的东西来正真成就自己。</p><p>$未完\dots$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是是我对现在的简单思考&lt;/p&gt;</summary>
    
    
    
    <category term="半月谈" scheme="https://www.wulnut.top/categories/%E5%8D%8A%E6%9C%88%E8%B0%88/"/>
    
    
    <category term="回忆，杂谈" scheme="https://www.wulnut.top/tags/%E5%9B%9E%E5%BF%86%EF%BC%8C%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://www.wulnut.top/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://www.wulnut.top/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-04-01T09:10:36.287Z</published>
    <updated>2020-09-17T10:34:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>快快快~</p><a id="more"></a><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>问题描述：</p><p>&emsp;&emsp;求$A^B$的最后三位数的整数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果我们直接通过循环的方法来解决我们会发现</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;            result = result * base;      &#125;        <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>如果给出$base = 2$ $power = 100$ 的时候我们就就会发现函数$f(x) = a^{b}$是一个指数函数后期的增长速度是非常快的所以我们需要对此进行优化。</p><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p>取模运算有以下 性质：</p><ol><li><p>$(a + b)\%c = ((a\%c) + (b\%c))\%c$</p></li><li><p>$(a \times b)\%c = ((a\%c) \times (b\%c))\%c$</p></li><li><p>$(a - b)\%c = ((a\%c)-(b\%c))\%c$</p><p>总成依据话就是，在取模运算的时候我们在中间过程每次都取模，在得出答案之后我们再取一次模。</p><p>我们通过性质性质2来优化我们的代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;        result *= base;        result %= <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>通过这样的运算优化，我们发现这种取模运算中如果我们中间进行取模的话是可以防止出现溢出的情况的。</p></li></ol><h2 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h2><p>&emsp;&emsp;快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。从而达到快速计算的目的。</p><p>例如：</p><p>$3^{10} = 3\times3\times3\times3\times3\times3\times3\times3\times3\times3$</p><p>我们可以尽可能的将其指数降下来，来简化运算。</p><p>$3^{10} = (3\times3)\times(3\times3)\times(3\times3)\times(3\times3)\times(3\times3)$</p><p>$3^{10} = (3\times3)^5$</p><p>其实这种方法也在平常也是十分常见的，比如我们向计算$2^4$我们肯定不会一个一个的乘$2$我们一般都会去直接计算$4\times4$从而快速的计算出结果，其实两者的关系是一样的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = base;        whlie (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果指数为偶数</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//把指数缩小为一半</span>            base = base * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//底数变大成原来的平方</span>        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">//如果指数为奇数</span>            power = power - <span class="hljs-number">1</span>;<span class="hljs-comment">//把指数减去1，使其变成一个偶数</span>            result = result * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//此时记得要把指数为奇数时分离出来的底数的一次方收集好</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//此时指数为偶数，可以继续执行操作</span>            base = base * base % <span class="hljs-number">1000</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最终优化"><a href="#最终优化" class="headerlink" title="最终优化"></a>最终优化</h2><p>&emsp;&emsp;我们知到判断奇偶性除了使用 $\%$看其余数是否为$0$ $or$ $1$来进行判断之外，我们还可以通过位运算来进行计算，例如：power&amp;1。因为如果power为偶数，则其二进制表示的最后一位一定是0；如果power是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是power二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1=1；而6是偶数，则6&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p>&emsp;&emsp;同样对于除以$2$的运算我们也可以使用位运算来进行优化power /= 2可以使用右移power = power &gt;&gt; 1实现，右移动1就是除以2，如果右移2就是除以4，同理左移就是乘，左移1就是乘以2左移2就是乘以4；</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>求$m^k$ $\% $ $p$ 时间复杂度为$O(logk)$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p, t = m;        <span class="hljs-keyword">while</span> (k) &#123;                <span class="hljs-comment">//如果为奇数</span>        <span class="hljs-keyword">if</span> (k &amp;  <span class="hljs-number">1</span>) res = res * t % p;                t = t * t % p;        k &gt;&gt; <span class="hljs-number">1</span>;    &#125;        <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;快快快~&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>双向BFS</title>
    <link href="https://www.wulnut.top/2020/03/28/%E5%8F%8C%E5%90%91BFS/"/>
    <id>https://www.wulnut.top/2020/03/28/%E5%8F%8C%E5%90%91BFS/</id>
    <published>2020-03-28T13:31:36.632Z</published>
    <updated>2020-03-28T14:48:53.630Z</updated>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="搜索-双向BFS"><a href="#搜索-双向BFS" class="headerlink" title="搜索-双向BFS"></a>搜索-双向BFS</h1><ul><li>双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率。</li><li>同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案</li><li><font color="red">但是双向BFS在针对于小型数据范围时就会退化成BFS,如果双向BFS的两个端点完全没有连接，时间复杂度也会和BFS相同</font></li></ul><p><img src="/img/BFS.png" alt=" "></p><p>当两种颜色相遇的时候，说明两个方向的搜索树遇到一起，这个时候就搜到了答案。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>简单理入门：</p><p><strong>问题描述</strong>：<br>一个迷宫由$R$行$C$列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。<br>给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。</p><p><strong>输入</strong></p><p>第一行是两个整数，$Ｒ$和$Ｃ$，代表迷宫的长和宽。$（1≤R，C≤40)$<br>接下来是$Ｒ$行，每行$Ｃ$个字符，代表整个迷宫。<br>空地格子用‘.’表示，有障碍物的格子用‘#’表示。<br>迷宫左上角和右下角都是‘.’。</p><p><strong>输出</strong></p><p>输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点</p><p><strong>输入样例</strong></p><pre><code class="hljs clean"><span class="hljs-number">5</span> <span class="hljs-number">5</span>..####....#.#.##.#.##.#..</code></pre><p><strong>输出样例</strong></p><pre><code class="hljs plain">9</code></pre><p><strong>普通BFS：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">100000</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[MAX][MAX];<span class="hljs-keyword">int</span> d[MAX][MAX];<span class="hljs-comment">//表示起点到各个位置的最短距离 </span><span class="hljs-keyword">int</span> sx, sy, gx, gy;<span class="hljs-comment">//表示起点和终点坐标 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,- <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; d[x][y]==INF &amp;&amp; <span class="hljs-built_in">map</span>[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">queue</span>&lt;P&gt; que;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)d[i][j] = INF;que.push(P(sx, sy));d[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!que.empty()) &#123;P p = que.front(); que.pop();<span class="hljs-keyword">if</span>(p.first == gx &amp;&amp; p.second == gy)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = p.first + dx[i];<span class="hljs-keyword">int</span> ny = p.second + dy[i];<span class="hljs-keyword">if</span>(Check(nx, ny)) &#123;que.push(P(nx,ny));d[nx][ny] = d[p.first][p.second] + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> d[gx][gy]; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];sx = <span class="hljs-number">0</span>, sy = <span class="hljs-number">0</span>;gx = n<span class="hljs-number">-1</span>, gy = m<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> res = bfs(); <span class="hljs-built_in">cout</span> &lt;&lt; res+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>双向BFS</strong>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//记录下当前状态, 从前往后搜索值为1，从后往前搜索值为2，如果某状态下，当前节点和准备扩展节点的状态相加为3，说明相遇</span><span class="hljs-built_in">queue</span> &lt;P&gt; q1, q2; <span class="hljs-keyword">int</span> r, c, ans, dis[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>], vst[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">char</span> m[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dbfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">bool</span> flag;q1.push(P(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), dis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, vst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//从前搜</span>q2.push(P(r, c)), dis[r][c] = <span class="hljs-number">1</span>, vst[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">//从后搜</span><span class="hljs-keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;<span class="hljs-keyword">int</span> x0, y0;<span class="hljs-keyword">if</span>(q1.size() &gt; q2.size()) &#123; <span class="hljs-comment">//每次扩展搜索树小的队列 flag=1扩展前搜的队列，flag=0扩展后搜的队列</span>x0 = q2.front().first, y0 = q2.front().second;q2.pop();flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;x0 = q1.front().first, y0 = q1.front().second;q1.pop();flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = x0 + dx[i];<span class="hljs-keyword">int</span> ny = y0 + dy[i];<span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; m[nx][ny] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(!dis[nx][ny]) &#123;dis[nx][ny] = dis[x0][y0] + <span class="hljs-number">1</span>;vst[nx][ny] = vst[x0][y0];<span class="hljs-keyword">if</span>(flag) q1.push(P(nx, ny));<span class="hljs-keyword">else</span> q2.push(P(nx, ny));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(vst[x0][y0] + vst[nx][ny]== <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//相遇</span>ans = dis[nx][ny] + dis[x0][y0];<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; r &gt;&gt; c;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++)<span class="hljs-built_in">cin</span> &gt;&gt; m[i][j];dbfs(); <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a herf = "https://leetcode-cn.com/problems/word-ladder/">力扣第127题：单词接龙</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code class="hljs clean">输入:beginWord = <span class="hljs-string">&quot;hit&quot;</span>,endWord = <span class="hljs-string">&quot;cog&quot;</span>,wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]输出: <span class="hljs-number">5</span>解释: 一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>,     返回它的长度 <span class="hljs-number">5</span>。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>beginWord = <span class="hljs-string">&quot;hit&quot;</span>endWord = <span class="hljs-string">&quot;cog&quot;</span>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<span class="hljs-section">输出: 0</span><span class="hljs-section">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span></code></pre><p>&emsp;&emsp;如果只是单纯的使用BFS经行操作那么时间复杂度将会为$O(M\times N)$ $M$表示单词的长度, $N$表示单词列表中单词的个数.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;      <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s; <span class="hljs-comment">// 可以块数查找</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : wordList) s.insert(i);      <span class="hljs-comment">// first 表示字符</span>      <span class="hljs-comment">// second 表示走过的路长</span>      <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;      q.push(<span class="hljs-built_in">make_pair</span>(beginWord, <span class="hljs-number">1</span>));      <span class="hljs-built_in">string</span> temp;      <span class="hljs-keyword">int</span> step; <span class="hljs-comment">// 表示用暂时存贮走过的步子</span>      <span class="hljs-keyword">while</span> (!q.empty()) &#123;          <span class="hljs-keyword">if</span> (q.front().first == endWord) <span class="hljs-keyword">return</span> q.front().second;          temp = q.front().first;          step = q.front().second;          q.pop();          <span class="hljs-keyword">char</span> ch;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= temp.size(); ++ i) &#123;              ch = temp[i];              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                  <span class="hljs-keyword">if</span> (ch == a) <span class="hljs-keyword">continue</span>;                  temp[i] = a;                  <span class="hljs-keyword">if</span> (s.find(temp) != s.end()) &#123; <span class="hljs-comment">// 这里表示如果找到了可以转换的两个单词，就把该数存放入队列里</span>                      q.push(<span class="hljs-built_in">make_pair</span>(temp, step + <span class="hljs-number">1</span>));                      s.erase(temp); <span class="hljs-comment">// 删掉结点的意思防止找到重复</span>                  &#125;                  temp[i] = ch;              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>如果使用双向BFS：</p><ul><li>$O(M \times N)$，其中 MM 是单词的长度 $N$是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 $M \times N$ 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</li></ul><p>算法：</p><ul><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p></li></ul><blockquote><p> 双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote><ul><li>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dbfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;       <span class="hljs-function"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">dict</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;       <span class="hljs-keyword">if</span> (dict.find(beginWord) != dict.end()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//初始化</span>       <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; beginSet, endSet, tmp, visited;       beginSet.insert(beginWord);       endSet.insert(endWord);       <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (!beginSet.empty() &amp;&amp; !endSet.empty()) &#123;           <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;               tmp = beginSet;               beginSet = endSet;               endSet = tmp;           &#125;           tmp.clear();           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> word : beginSet) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.size(); ++ i) &#123;                   <span class="hljs-keyword">char</span> old = word[i];                   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                       <span class="hljs-keyword">if</span> (old == a) <span class="hljs-keyword">continue</span>;                       word[i] = a;                       <span class="hljs-keyword">if</span> (endSet.find(word) != endSet.end()) &#123;                           <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;                       &#125;                       <span class="hljs-keyword">if</span> (visited.find(word) == visited.end() &amp;&amp; dict.find(word) != dict.end()) &#123;                           tmp.insert(word);                           visited.insert(word);                       &#125;                   &#125;                   word[i] = old;               &#125;           &#125;           beginSet = tmp;           ++ len;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于set与unordered-set"><a href="#关于set与unordered-set" class="headerlink" title="关于set与unordered_set"></a>关于set与unordered_set</h3><ul><li><strong>set函数(集合)</strong>：这里的set表示集合的意思，和数学中的集合是一个意思，集合中不允许有重复出现的元素，由于set函数底层通常以红黑树实现，红黑树具有自动排序的功能，因此set内部所有的数据，在任何时候，都是有序的。</li><li><strong>unordered_set函数</strong>： 是含有 Key 类型唯一对象集合的关联容器，依赖于哈希表。搜索、插入和移除拥有平均常数时间复杂度。在内部，元素并不以任何特别顺序排序，而是组织进桶中，元素被放进哪个桶完全依赖其值的哈希。允许对单独元素的快速访问，因为一旦哈希，就能够准确指代元素被放入的桶。不可修改容器元素（即使通过非 const 迭代器），因为修改可能更改元素的哈希，并破坏容器。代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</li></ul><h4 id="下面几种情况一般使用set："><a href="#下面几种情况一般使用set：" class="headerlink" title="下面几种情况一般使用set："></a>下面几种情况一般使用set：</h4><ol><li>需要有序的数据(元素不同)。</li><li>需要按顺序打印/访问数据。</li><li>需要元素的前任或后继。</li></ol><h4 id="下面几种情况一般使用unordered-set："><a href="#下面几种情况一般使用unordered-set：" class="headerlink" title="下面几种情况一般使用unordered_set："></a>下面几种情况一般使用unordered_set：</h4><ol><li>需要保留一组不同的元素，不需要排序。</li><li>需要访问单个元素，不要遍历。</li></ol><h3 id="关于map与unordered-map"><a href="#关于map与unordered-map" class="headerlink" title="关于map与unordered_map"></a>关于map与unordered_map</h3><ul><li><strong>map函数（映射）</strong>： map函数在缺省下，按照递增的排序顺序，并且内部采用了自平衡的BST（二叉搜索树）的数据结构，实现了数据排序。所以在搜索的时候时间复杂度为$Olog(n)$</li><li><strong>unordered_map函数</strong>：unordered_map函数不进行排序二内部采用了哈希表的数据结构在搜索的时候时间复杂度为$O(1)$，但是在特殊情况下时间复杂度就会退化为$O(n)$</li></ul><p>因此如果你想要一个具有排序后的数据的话，通常可以选择map这种类型。或者想要打印具有一定顺序的元素。如果你只想记录数据而不是想要将数据进行排序的话，那么就可以选择unordered_map这种数据结构。</p><p><a herf="https://blog.csdn.net/weixin_43501684/article/details/90147421">.</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;值得思考的实现&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
    <category term="数据结构" scheme="https://www.wulnut.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>cellular automata</title>
    <link href="https://www.wulnut.top/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/"/>
    <id>https://www.wulnut.top/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-27T12:14:28.375Z</published>
    <updated>2020-03-27T13:02:22.497Z</updated>
    
    <content type="html"><![CDATA[<p>STL函数，内部用二分查找实现</p><a id="more"></a><h1 id="有关lower-bound-函数的使用"><a href="#有关lower-bound-函数的使用" class="headerlink" title="有关lower_bound()函数的使用"></a>有关lower_bound()函数的使用</h1><p>lower_bound()函数需要加载头文件#include<algorithm>,其基本用途是查找有序区间中第一个大于或等于某给定值的元素的位置，其中排序规则可以通过二元关系来表示。</p><pre><code class="hljs C++">函数原型：<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span>   <span class="hljs-function">ForwardIterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _First, </span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _Last,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">const</span> Type&amp; _Val</span></span><span class="hljs-function"><span class="hljs-params">   )</span></span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;</span>   <span class="hljs-function">ForwardIterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _First, </span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _Last,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">const</span> Type&amp; _Val,</span></span><span class="hljs-function"><span class="hljs-params">      BinaryPredicate _Comp</span></span><span class="hljs-function"><span class="hljs-params">   )</span></span>;传入参数说明：   _First 要查找区间的起始位置_Last 要查找区间的结束位置_Val 给定用来查找的值_Comp 自定义的表示小于关系的函数对象，根据某个元素是否满足小于关系而返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span></code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>例如，有如下序列：<br>$a[i]={12,15,17,19,20,22,23,26,29,35,40,51}$;<br>用值21调用lower_bound(),返回一个指向22的iterator。用值22调用lower_bound(),也返回一个指向22的iterator。第一个版本使用底层 &lt; (小于)操作符，第二个版本根据comp进行排序和比较。</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>调用lower_bound之前必须确定序列为有序序列，否则调用出错。第一个版本排序根据底层的 &lt;(小于)操作符，第二个版本根据comp进行排序。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/sdtc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);   <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p>上面的例子是针对容器的，注意返回的是距离元素3最近的指针it，输出的是*it结果为元素4，假如我想得到位置而非具体的元素应该怎么办呢？这里有一个指针偏移的技巧，只需要减去起始位置的指针即可，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)          v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的  </span>    <span class="hljs-comment">//vector&lt;int&gt;::iterator it = lower_bound(v.begin(), v.end(), 3);  </span>    <span class="hljs-keyword">int</span> pos = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>)-v.begin();      <span class="hljs-built_in">cout</span> &lt;&lt; pos&lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>结果和容器的时候是一样的。</p><p>对于4个参数的情形，最后一个参数的自己定义的表示大小关系函数的对象，常用的逆序可以加载头文件#include<functional>,里边有一个greater<int>()函数即可对逆序求最近位置。假如说像上边一样元素为2 4 6 8，逆序则是8 6 4 2，那么求距离3最近表示的是与3最近的小于等于3的元素，输出结果则是元素2了，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &gt;<span class="hljs-number">0</span>; i--)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());     <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们知道map容器是根据键值进行排序的</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><p>这两个函数常用于multimap容器，用来获取某个键对应的所有元素</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; m;    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">2</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">3</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">2</span>));    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = m.begin();    <span class="hljs-keyword">while</span>(it != m.end())    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;        it++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it1 = m.lower_bound(<span class="hljs-string">&quot;China&quot;</span>),it2 = m.upper_bound(<span class="hljs-string">&quot;China&quot;</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;it1-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it1-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;it2-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it2-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;STL函数，内部用二分查找实现&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
    <category term="泛型编程" scheme="https://www.wulnut.top/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>杂题选讲</title>
    <link href="https://www.wulnut.top/2020/03/26/AC%E9%80%89%E8%AE%B2/"/>
    <id>https://www.wulnut.top/2020/03/26/AC%E9%80%89%E8%AE%B2/</id>
    <published>2020-03-26T07:29:20.986Z</published>
    <updated>2020-03-27T13:08:42.969Z</updated>
    
    <content type="html"><![CDATA[<p>最近AC题目的分析</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><blockquote><p>示例1：</p></blockquote><pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><blockquote><p>示例2:</p></blockquote><pre><code>输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;<strong>这种在数组空间上进行各种操作的题目，一般可以利用双指针进行解决。</strong><br>&emsp;&emsp;这个题目比较困难的地方再于各种边界的判定于操作，以及如何快速高效的进行合并。<br>&emsp;&emsp;双指针再解决这类问题的时候总有着很清晰的思路，首先我们要减少复杂情况，所以先排序形成一个有序的状态。我们先设双指针<br>第一个$save$用于保留和扩展另一个用$scan$来进行扫描</p><p>&emsp;&emsp;因为我们排序之后这个序列肯定是有序的所以我们就可以不用考虑左边界所有就剩下三种情况了</p><ul><li>eg:  $\overbrace{[1,3],[4,5]}^{save}$这种情况最为简单，两个区间不相交，因此我们就可以把$save$指针所指向的数据压入result数组种，然后再将$save$移动到<br>scan指针所指的地方：$[1,3],\overbrace{[4,5]}^{save}, \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save}, \overbrace{[2,3]}^{scan}$,这种是一种不被包含的情况，因此我们呢不需要操作$save$指针，$scan$ 指针继续往后移动即可：$\overbrace{[1,4]}^{save}, [2,3], \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save},\overbrace{[3,5]}^{scan}$,这种情况是相对比较复杂的情况，即我们需要对于$save$指针指向的数组进行扩展，所以我们需要修改数组为$\overbrace{[1,4]}^{save} \rightarrow \overbrace{[1,5]}^{save}$, 然后将$scan$指向下一个,也就是:  $\overbrace{[1,5]}^{save}, [3,5], \overbrace{[X,X]}^{scan}$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;        <span class="hljs-comment">// 对于特殊情况的特判</span>        <span class="hljs-keyword">if</span> (intervals.size() == <span class="hljs-number">0</span> || intervals.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;        <span class="hljs-comment">// 双指针</span>        <span class="hljs-keyword">int</span> save = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于保存的数组</span>        <span class="hljs-keyword">int</span> scan = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用户扫描的数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;        sort (intervals.begin(), intervals.end());        <span class="hljs-keyword">while</span> (scan &lt; intervals.size()) &#123;            <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">0</span>] &gt; intervals[save][<span class="hljs-number">1</span>]) &#123;                result.emplace_back(intervals[save]);                save = scan;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">1</span>] &lt;= intervals[save][<span class="hljs-number">1</span>]) &#123;                ++ scan;            &#125; <span class="hljs-keyword">else</span> &#123;                intervals[save][<span class="hljs-number">1</span>] = intervals[scan][<span class="hljs-number">1</span>]; <span class="hljs-comment">//将数组扩充</span>                ++ scan;            &#125;        &#125;        result.emplace_back(intervals[save]); <span class="hljs-comment">// 当scan扫描到最后一个区间之后会跳出循环也就是说还有一个区间没有压入向量</span>        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;三种情况种第一种情况是一般情况，后面两种是特殊情况，我们只需要对特殊情况经行处理称一般情况，然后让一般情况操就行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近AC题目的分析&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="https://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Largest Rectangle in Histogram</title>
    <link href="https://www.wulnut.top/2020/03/21/MaximalRectangle/"/>
    <id>https://www.wulnut.top/2020/03/21/MaximalRectangle/</id>
    <published>2020-03-21T07:42:00.000Z</published>
    <updated>2020-03-23T08:30:06.106Z</updated>
    
    <content type="html"><![CDATA[<p>Largest Rectangle in Histogram解析</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/img/rectangle2.png" alt=" "></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="/img/rectangle1.png" alt=" "></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>示例:</p><p>输入: [2,1,5,6,2,3]</p><p>输出: 10</p></blockquote><h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p><img src="/img/rectangle.png" alt=" "></p><p>height的内容是 [5,6,7,8,3]，特点是除了最后一个，前面全部保持递增，且最后一个立柱的高度小于前面所有立柱高度。对于<br>这种特点的柱状图，如果使用上面所说的“挨个使用每一个柱状图的高度作为矩形的高度，求面积”的方法，还需要用嵌套循环吗？</p><p>&emsp;&emsp;我们知道除了最后一个，从第一个到倒数第二个立柱的高度都在升高，那么如果挨个使用每一个柱的高度作为矩形的<br>高度，那么依次能得到的矩形的宽度就可以直接算出来：使用5作为高度可以使用前四个立柱组成 $4\times5$的矩形，高度6可以<br>组成$3\times6$的矩形… 因此只需要遍历一次，选出最大面积即可。对于这种类型的柱状图，最大矩形面积的时间复杂度是O(n)。我们将这种特点的柱状图称为“波峰图”。</p><p>从而算法设计步骤：</p><p>(1) 在height尾部添加一个0，也就是一个高度为0的立柱。作用是在最后也能凑成上面提的那种“波峰图”。</p><p>(2) 定义了一个stack，然后遍历时如果height[i] 大于stack.top()，进栈。反之，出栈直到栈顶元素小于height[i]。</p><p>由于出栈的这些元素高度都是递增的，我们可以求出这些立柱中所围成的最大矩形。更妙的是，由于这些被弹出的立柱处于“波峰”之上(比如弹出i 到 i+k，那么所有这些立柱的高度都高于 i-1和 i+k+1的高度)，因此，如果我们使用之前所提的“左右延伸找立<br>柱”的思路解，以这些立柱的高度作为整个矩形的高度时，左右延伸出的矩形所包含的立柱不会超出这段“波峰”，因为波峰外的立柱<br>高度都比他们低。“波峰图”其实就是求解最大矩形的“孤岛”，它不会干扰到外部。</p><p>(3) 由于比height[i]大的元素都出完了，height[i]又比栈顶元素大了，因此再次进栈。如此往复，直到遍历到最后那个高度为0的柱，触发最后的弹出以及最后一次面积的计算，此后stack为空。</p><p>(4) 返回面积最大值。</p><p>&emsp;&emsp;栈中存的不是高度，而是height的索引，这样做的好处是不会影响宽度的计算，索引值相减 = 宽度。</p><h2 id="但是对于面积的计算，还需要再多少几句"><a href="#但是对于面积的计算，还需要再多少几句" class="headerlink" title="但是对于面积的计算，还需要再多少几句"></a>但是对于面积的计算，还需要再多少几句</h2><p><img src="/img/rectangle3.png" alt=" "></p><p>矩形的面积=高*宽。<br>我们的发现，在这个分支情况下，我们已经知道高为2了，那么宽度如何求呢？<br>通过观察，我们发现矩形的左边沿是左边第一个高比2小的柱子，右边沿是右边第一个高比2小的柱子（将高为3的柱子的右面看作还<br>有一个高为0的柱子）如此它的宽度是$6 -（1+1）=4$</p><h2 id="如何寻找柱子的左右边"><a href="#如何寻找柱子的左右边" class="headerlink" title="如何寻找柱子的左右边"></a>如何寻找柱子的左右边</h2><p>我们已经说了，左边沿是左边第一小与本柱子高的柱子的右边，右边沿也是同理。<br>这正好可以用单调栈。<br>当第i个柱子进栈时，如果栈顶柱子（此处记作柱子A）的高度低于或等于第i个柱子，则第i个柱子进栈；<br>如果高于第i个柱子，则出栈，并计算以柱子A为高的矩形最大面积。</p><ul><li>高度：就是柱子A的高度</li><li>右边沿：正好是i（由于单调栈的性质，第i个柱子就是右边第一个矮于A的柱子）</li><li>左边沿：单调栈中紧邻A的柱子。（如果A已经出栈，那么左边沿就是A出栈后的栈顶）而且是该柱子的右边，所以要+1.</li></ul><p>因此，完全覆盖第index个柱子的最大矩形的面积如下（stk是单调栈）</p><pre><code>maxArea = heights[index] * (i - (stk.top() +1))</code></pre><p>还有一种情况。当A出栈后，单调栈为空时，那就是说明，A的左边没有比它矮的。左边沿就可以到0.</p><pre><code>maxArea = heights[index] * (stk.empty() ? i : (i - stk.top() -1)))</code></pre><p>可能你还有点不明白就是，那实际代码是怎么计算的？其实自习想一下就明白了，因为是取得top元素进行计算所以计算是从右边逐<br>渐往左边延伸。所以当整个栈排空的时候也就计算了距离右边最远的边界。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>栈实现：</strong></p><pre><code>int largeRectangleArea(vector&lt;int&gt;&amp; h) &#123;    stack&lt;int&gt; s;    h.push_back(0);    int sum = 0;    for (int i = 0; i &lt; h.size(); ++ i) &#123;        if (s.empty() || h[i] &gt; h[s.top()]) s.push(i);        else &#123;            int tmp = s.top();            s.pop();            sum = max(sum, h[tmp] * (s.empty() ? i : i - s.top() - 1));            i --;        &#125;    &#125;    return sum;&#125;</code></pre><p><strong>分治解法：</strong></p><pre><code>    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        if(heights.empty()) return 0;        return maxArea(heights,0,(int)heights.size()-1);    &#125;    int maxArea(vector&lt;int&gt;&amp; heights,int start, int end)&#123;        if(start &gt; end)            return 0;        int minIndex=start;        bool sorted = true;        for(int i=start+1;i&lt;=end;++i)&#123;            if(heights[i]&lt;heights[i-1])                sorted=false;            if(heights[i] &lt; heights[minIndex])&#123;                minIndex=i;            &#125;         &#125;        if(sorted)&#123;//如果有序则不需要再作进一步的分治            int mx=0;            for(int i=start;i&lt;=end;++i)            mx = max(mx,(end-i+1)*heights[i]);            return mx;        &#125;        return max( (end-start+1)*heights[minIndex],                max( maxArea(heights,start, minIndex-1),maxArea(heights,minIndex+1, end) ) );//分治    &#125;</code></pre><h1 id="算01-矩阵中包含最多1-的矩形"><a href="#算01-矩阵中包含最多1-的矩形" class="headerlink" title="算01 矩阵中包含最多1 的矩形"></a>算01 矩阵中包含最多1 的矩形</h1><p>接下来还有道Maximal Rectangle 的题，这道题的实用价值很大：算01 矩阵中包含最多1 的矩形。</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>有了上一题的基础，这道题就可等效为上一题，对于矩阵每一行，我们将其看作直方图，立柱的高度就是行中元素往上数包含的连续1的个数。</p><p>因此每一行都可以利用上一题方法计算最大矩形，最后求出各行结果的最大值就好了。时间复杂度 O(n2)</p><pre><code>    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;                if(matrix.size() == 0 || matrix[0].size() == 0) return 0;        int H = matrix.size(), W = matrix[0].size();        int height[W+1];        int i, j , MAX = 0, leftarea = 0, rightarea = 0;        stack&lt;int&gt; st;        for(i = 0; i &lt;= W; height[i] = 0, ++i);        for(i = 0; i &lt; H; ++i)&#123;            while(!st.empty()) st.pop();            for(j = 0; j &lt; W; ++j)&#123;                if(matrix[i][j] == &#39;1&#39;) height[j]++;                else height[j] = 0;            &#125;            for(int j = 0; j &lt;= W; ++j)&#123;                while(!st.empty() &amp;&amp; height[st.top()] &gt; height[j])&#123;                    int tmp = st.top();                    st.pop();                    leftarea = (st.empty() ? tmp + 1 : tmp - st.top()) * height[tmp];                    rightarea = (j - tmp - 1) * height[tmp];                    if((leftarea + rightarea) &gt; MAX) MAX = (leftarea + rightarea);                &#125;                st.push(j);            &#125;        &#125;        return MAX;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Largest Rectangle in Histogram解析&lt;/p&gt;</summary>
    
    
    
    <category term="训练题" scheme="https://www.wulnut.top/categories/%E8%AE%AD%E7%BB%83%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
