<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wulnut`s space</title>
  <icon>http://www.wulnut.top/themes/fluid/source/img/panda.png</icon>
  <subtitle>垃圾桶轮到你介绍了</subtitle>
  <link href="http://www.wulnut.top/atom.xml" rel="self"/>
  
  <link href="http://www.wulnut.top/"/>
  <updated>2020-09-20T15:34:33.126Z</updated>
  <id>http://www.wulnut.top/</id>
  
  <author>
    <name>Wulnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最短路径之Dijkstra</title>
    <link href="http://www.wulnut.top/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/"/>
    <id>http://www.wulnut.top/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/</id>
    <published>2020-09-20T14:50:12.851Z</published>
    <updated>2020-09-20T15:34:33.126Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><p>&emsp;&emsp;在上一篇文章当中我们讲解了bellman-ford算法和spfa算法，其中spfa算法是我个人比较常用的算法，比赛当中几乎没有用过其他的最短路算法。但是spfa也是有缺点的，我们之前说过它的复杂度是<br>$O(kE)$，这里的E是边的数量。但有的时候边的数量很多，E最多能够达到$V^2$，这会导致超时，所以我们会更换其他的算法。这里说的其他的算法就是Dijkstra。</p><h1 id="Dijkstra算法的前提："><a href="#Dijkstra算法的前提：" class="headerlink" title="Dijkstra算法的前提："></a>Dijkstra算法的前提：</h1><ol><li>首先，Dijkstra处理的是带正权值的<code>有权图</code>，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达(边)的权值大小。<code>(邻接矩阵或者邻接表存储)</code></li><li>其次，还需要一个<code>bool数组</code>判断那些点已经确定最短长度，那些点没有确定。<code>int数组</code>记录距离<code>(在算法执行过程可能被多次更新)</code>。</li><li>需要<code>优先队列</code>加入<code>已经确定点的周围点</code>。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。(优化后)</li></ol><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>&emsp;&emsp;在上一篇文章当中我们曾经说过Bellman-ford算法本质上其实是动态规划算法，我们的状态就是每个点的最短距离，策略就是可行的边，由于一共最多要松弛V-1次，所以整体的算法复杂度很高。当我们用队列维护可以松弛的点之后，就将复杂度降到了<br>$O(kE)$，也就是spfa算法。<br>&emsp;&emsp;Dijkstra算法和Bellman-ford算法虽然都是最短路算法，但是核心的逻辑并不相同。Dijkstra算法的底层逻辑是贪心，也可以理解成贪心算法在图论当中的使用。<br>&emsp;&emsp;其实Dijstra算法和Bellman-ford算法类似，也是一个松弛的过程。即一开始的时候除了源点s之外，其他的点的距离都设置成无穷大，我们需要遍历这张图对这些距离进行松弛。所谓的松弛也就是要将这些距离变小。假设我们已经求到了两个点u和v的距离，我们用<br>dis[u]表示u到s的距离，dis[v]表示v的距离。</p><p>&emsp;&emsp;假设我们有dis[u] &lt; dis[v]，也就是说u离s更近，那么我们接下来要用一个新的点去搜索松弛的可能，u和v哪一个更有可能获得更好的结果呢？当然是u，所以我们选择u去进行新的松弛，这也就是贪心算法的体现。如果这一层理解了，算法的整个原理也就差不多<br>了。</p><p>我们来整理一下思路来看下完整的算法流程：</p><ol><li>我们用一个数组dis记录源点s到其他点的最短距离，起始时dis[s] = 0，其他值设为无穷大</li><li>我们从未访问过的点当中选择距离最小的点u，将它标记为已访问</li><li>遍历u所有可以连通的点v，如果dis[v] &lt; dis[u] + l[u] [v]，那么更新dis[v]</li><li>重复上述2，3两个步骤，直到所有可以访问的点都已经访问过</li></ol><p>怎么样，其实核心步骤只有两步，应该很好理解吧？我找到了一张不错的动图，大家可以根据上面的流程对照一下动图加深一下理解。</p><p><img src="/img/short-path/dijkstra.gif" alt="如图"><br>我们根据原理不难写出代码：<br>C++版本：<br><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> g[N][N];<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">int</span> st[N];<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);        dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp;(t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j])) &#123;                t = j;            &#125;        &#125;        st[t] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            dis[j] = min(dis[j], dis[t] + g[t][j]);        &#125;    &#125;        <span class="hljs-keyword">if</span>(dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dis[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);    <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        g[a][b] = min(g[a][b], c);    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dijkstra());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><p>Pyhon版本：<br><pre><code class="hljs Python">INF = sys.maxsizeedges = [[]] <span class="hljs-comment"># 邻接表存储边</span>dis = [] <span class="hljs-comment"># 记录s到其他点的距离</span>visited = &#123;&#125; <span class="hljs-comment"># 记录访问过的点</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    mini = INF    u = <span class="hljs-number">0</span>    flag = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 遍历所有未访问过点当中距离最小的</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(V):        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited <span class="hljs-keyword">and</span> dis[i] &lt; mini:            mini, u = dis[i], i            flag = <span class="hljs-literal">True</span>                <span class="hljs-comment"># 如果没有未访问的点，则退出</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:        <span class="hljs-keyword">break</span>         visited[u] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        dis[v] = min(dis[v], dis[u] + l)</code></pre></p><p>&emsp;&emsp;虽然我们已经知道算法没有反例了，但是还是可以思考一下。主要的点在于我们每次都选择未访问的点进行松弛，有没有可能我们松弛了一个已经访问的点，由于它已经被松弛过了，导致后面没法拿来松弛其他的点呢？<br>&emsp;&emsp;其实是不可能的，因为我们每次选择的都是距离最小的未访问过的点。假设当前的点是u，我们找到了一个已经访问过的点v，是不可能存在dis[u] + l &lt; dis[v]的，因为dis[v]必然要小于dis[u]，v才有可能先于u访问。但是这有一个前提，就是每条边的长度不<br>能是负数。</p><h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><p>&emsp;&emsp;和Bellman-ford算法一样，Dijkstra算法最大的问题同样是复杂度。我们每次选择一个点进行松弛，选择的时候需要遍历一遍所有的点，显然这是非常耗时的。复杂度应该是$O(V^2 + E)$，这里的E是边的数量，Dijkstra中每个点只会松弛一次，也就意味着每条<br>边最多遍历一次。<br>&emsp;&emsp;我们观察一下会发现，外面这层循环也就算了，里面这层循环很没有必要，我们只是找了一个最值而已。完全可以使用数据结构来代替循环查询，维护最值的场景我们也已经非常熟悉了，当然是使用优先队列。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>一般从选定点开始抛入优先队列。（路径一般为0），<code>bool数组</code>标记0的位置(最短为0) , 然后0周围连通的点抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内<code>(如果小于就更新，大于就不动，初始第一次是无穷肯定会更新)</code>，第一次就结束了</li><li>从队列中抛出距离最近的那个点B（第一次就是0周围邻居）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为true，<code>并且将这个点的邻居加入队列</code>(下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过B点计算各个位置的<br>长度，如果小于则更新！<br><img src="/img/short-path/dijkstra1.png" alt="如图"></li><li>重复二的操作，直到所有点都确定。<br><img src="/img/short-path/dijkstra2.png" alt="如图"></li></ul><p><a class="btn" href="https://www.acwing.com/problem/content/description/852/" title="title">参考题目</a></p><p>C++版本：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;<span class="hljs-keyword">int</span> dist[N], heap[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span> (heap.size())    &#123;        PII t = heap.top();        heap.pop();        <span class="hljs-keyword">int</span> ver = t.second; <span class="hljs-comment">//distance = t.first;</span>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;        st[ver] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])        &#123;            <span class="hljs-keyword">int</span> j = e[i];            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] = dist[ver] + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dist[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dijkstra());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Pyhon版本：</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> heapq<span class="hljs-keyword">import</span> sys<span class="hljs-comment"># 优先队列</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, item, priority</span>):</span>        <span class="hljs-comment"># 传入两个参数，一个是存放元素的数组，另一个是要存储的元素，这里是一个元组。</span>        <span class="hljs-comment"># 由于heap内部默认由小到大排，所以对priority取负数</span>        heapq.heappush(self._queue, (-priority, self._index, item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> len(self._queue) == <span class="hljs-number">0</span>que = PriorityQueue()INF = sys.maxsizeedges = [[], [[<span class="hljs-number">2</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">14</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">15</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">11</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]] <span class="hljs-comment"># 邻接表存储边</span>dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>)] <span class="hljs-comment"># 记录s到其他点的距离</span>s = <span class="hljs-number">1</span>que.push(s, <span class="hljs-number">0</span>)dis[s] = <span class="hljs-number">0</span>visited = &#123;&#125;<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():    u, d = que.pop()    <span class="hljs-keyword">if</span> d != dis[u]:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            que.push(v, dis[v])print(dis)</code></pre><p>Java版本：<br><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-keyword">import</span> java.util.PriorityQueue;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dijkstra</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">int</span> x; <span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> lenth;<span class="hljs-comment">//长度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> lenth)</span> </span>&#123;<span class="hljs-keyword">this</span>.x=x;<span class="hljs-keyword">this</span>.lenth=lenth;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//记录权值，顺便记录链接情况，可以考虑附加邻接表</span>initmap(map);<span class="hljs-comment">//初始化</span><span class="hljs-keyword">boolean</span> bool[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//判断是否已经确定</span><span class="hljs-keyword">int</span> len[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//长度</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;len[i]=Integer.MAX_VALUE;&#125;Queue&lt;node&gt;q1=<span class="hljs-keyword">new</span> PriorityQueue&lt;node&gt;(com);len[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//从0这个点开始</span>q1.add(<span class="hljs-keyword">new</span> node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//计算执行了几次dijkstra</span><span class="hljs-keyword">while</span> (!q1.isEmpty()) &#123;node t1=q1.poll();<span class="hljs-keyword">int</span> index=t1.x;<span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> length=t1.lenth;<span class="hljs-comment">//节点当前点距离</span>bool[index]=<span class="hljs-keyword">true</span>;<span class="hljs-comment">//抛出的点确定</span>count++;<span class="hljs-comment">//其实执行了6次就可以确定就不需要继续执行了  这句可有可无，有了减少计算次数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;map[index].length;i++)&#123;<span class="hljs-keyword">if</span>(map[index][i]&gt;<span class="hljs-number">0</span>&amp;&amp;!bool[i])&#123;node node=<span class="hljs-keyword">new</span> node(i, length+map[index][i]);<span class="hljs-keyword">if</span>(len[i]&gt;node.lenth)<span class="hljs-comment">//需要更新节点的时候更新节点并加入队列</span>&#123;len[i]=node.lenth;q1.add(node);&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;System.out.println(len[i]);&#125;&#125;<span class="hljs-keyword">static</span> Comparator&lt;node&gt;com=<span class="hljs-keyword">new</span> Comparator&lt;node&gt;() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(node o1, node o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o1.lenth-o2.lenth;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initmap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] map)</span> </span>&#123;map[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;&#125;&#125;</code></pre></p><p>&emsp;&emsp;这里用visited来判断是否之前访问过的主要目的是为了防止负环的产生，这样程序会陷入死循环，如果确定程序不存在负边的话，其实可以没必要判断。因为先出队列的一定更优，不会存在之后还被更新的情况。如果想不明白这点加上判断也没有关系。<br>&emsp;&emsp;我们最后分析一下复杂度，每个点最多用来松弛其他点一次，加上优先队列的调整耗时，整体的复杂度是$O(V \log V+E)$，比之前$O(V^2+E)$的复杂度要提速了很多，非常适合边很多，点相对较少的图。有时候spfa卡时间了，我们会选择Dijkstra。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最短路径算法&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>最短路径之bellman-ford&amp;SPFA</title>
    <link href="http://www.wulnut.top/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/"/>
    <id>http://www.wulnut.top/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/</id>
    <published>2020-09-17T10:33:31.039Z</published>
    <updated>2020-09-20T15:20:07.765Z</updated>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>&emsp;&emsp;最短路问题也属于图论算法之一，解决的是在一张有向图当中点与点之间的最短距离问题。最短路算法有很多，比较常用的有bellman-ford、dijkstra、floyd、spfa等等。这些算法当中主要可以分成两个分支，其中一个是<br>bellman-ford及其衍生出来的spfa，另外一个分支是dijkstra以及其优化版本。floyd复杂度比较高，一般不太常用。<br>&emsp;&emsp;这次就先简单说一下bellman-ford和SPFA算法。</p><h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>我们要对一张有向图计算最短路，那么我们首先要做的就是将一张图存储下来。关于图的存储的数据结构，常用的方法有很多种。最简单的是邻接矩阵，所谓的邻接矩阵就是用一个二维矩阵存储每两个点之间的距离。如果两个点之间没有边相连，那么设为无穷大。</p><p><img src="/img/short-path/save-Graph.png" alt="如图"></p><p>&emsp;&emsp;这种方法的好处就是<code>非常直观</code>，实现也很简单，但是这中方法所消耗的时间复杂度也是很高的 $V^2$,这里的V指的是顶点的数量当顶点的数量稍稍大一些之后，带来的开销是非常庞大的。一般情况下我们的图的边的密集程度是不高<br>的，也就是说大量点和点之间没有边相连，我们浪费了很多空间。<code>一般情况下当边是顶点的10倍时(也就是稠密图)我们选择这种存图方式,此外我们就选择邻接表的方式来存储稀疏图</code></p><p>&emsp;&emsp;所谓的邻接表也就是说我们把顶点一字排开存入数组当中，每个顶点对应一条链表。这条链表当中存储了这个点可以到达的其他点的信息。邻接表的好处是可以最大化利用空间，有多少条边存储多少信息。但是也有缺点，除了实现稍稍复<br>杂一点之外，另外一个明显的缺点就是我们<code>没办法直接判断两点之间是否有边存在</code>，必须要遍历链表才可以。除了邻接矩阵和邻接表之外，还有一些其他的数据结构可以完成图的存储。比如前向星、边集数组、链式前向星等等。这些数据结构并没有<br>比邻接表有质的突破，对于非算法竞赛同学来说，能够熟练用好邻接表也就足够了。</p><h2 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman-ford算法"></a>bellman-ford算法</h2><p>&emsp;&emsp;刚才上面描述当中提到的算法除了floyd算法是计算的所有点对之间的最短距离之外，其他算法解决的都是单源点最短路的问题。所谓的单源点可以简单理解成单个的出发点，也就是说我们求的是从图上的一个点出发去往其他每个点的最短<br>距离。既然如此，我们的出发点以及到达点都是确定的，不确定的只是它们之间的距离而已。</p><p>&emsp;&emsp;为什么我们会将bellman-ford算法和dijkstra算法区分开呢？因为两者的底层逻辑是不同的，bellman-ford算法的底层逻辑是动态规划， 而dijkstra算法的底层逻辑是贪心。</p><p>&emsp;&emsp;bellman-ford算法的得名也和人有关，我们之前在介绍KMP算法的时候曾经说过。由于英文表意能力不强，所以很多算法和公式都是以人名来取名。bellman-ford是Richard Bellman 和 Lester Ford 分别发表的，实际上还有一个<br>叫Edward F. Moore也发表了这个算法，所以有的地方会称为是Bellman-Ford-Moore 算法。</p><p>&emsp;&emsp;算法的原理非常简单，利用了动态规划的思想来维护源点出发到各个点的最短距离。</p><p>&emsp;&emsp;它的核心思维是松弛，所谓的松弛可以理解成找到了更短的路径对原路径进行更新。对于一个有V个节点的有向图进行V-1轮松弛，从而找到源点到所有点的最短距离。</p><p>&emsp;&emsp;初始的时候我们会用一个数组记录源点到其他所有点的距离，对于与源点直接相连的点来说，这个距离就是它和源点的距离否则则是无穷大。对于第一轮松弛来说，我们寻找的是源点出发经过一个点到达其他点的最短距离。我们用s代表源<br>点，我们寻找的就是s经过点a到达点b，使得距离小于s直接到b的距离。</p><p>&emsp;&emsp;第二轮松弛就是寻找的s经过两个点到达第三个点的最短距离，同理，对于一个有V个点的图来说，两个点之间最多经过V-1个点，所以我们需要V-1轮松弛操作。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;    <span class="hljs-keyword">for</span> (var j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;//对m条边进行循环      var edge = edges[j];      // 松弛操作      <span class="hljs-keyword">if</span> (distance[edge.to] &gt; distance[edge.<span class="hljs-keyword">from</span>] + edge.weight )&#123;         distance[edge.to] = distance[edge.<span class="hljs-keyword">from</span>] + edge.weight;      &#125;    &#125;&#125;</code></pre><p>&emsp;&emsp;Bellman-ford的算法很好理解，实现也不难，但是它有一个缺点就是复杂度很高。我们前面说了一共需要V-1轮松弛，每一轮松弛我们都需要遍历E条边，所以整体的复杂度是$O(VE)$，E指的是边的数量。想想看，假设对于一个有1w个顶点，10w条边的<br>图来说，这个算法是显然无法得出结果的。</p><p>&emsp;&emsp;所以为了提高算法的可用性，我们必须对这个算法进行优化。我们来分析一下复杂度巨大的原因，主要在两个地方，一个地方是我们松弛了V-1次，另外一个地方是我们枚举了所有的边。松弛V-1次是不可避免的，因为可能存在极端的情况需要V-1次松弛<br>才可以达成。但我们每次都枚举了所有的边感觉有点浪费，因为其中大部分的边是不可能达成新的松弛的。那有没有办法我们筛选出来可能构成新的松弛的边呢？</p><p>&emsp;&emsp;针对这个问题的思考和优化引出了新的算法——spfa。</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>&emsp;&emsp;SPFA算法的英文全称是Shortest Path Faster Algorithm，从名字上我们就看得出来这个算法的最大特点就是快。它比Bellman-ford要快上许多倍，它的复杂度是$O(kE)$，这里的k是一个小于等于2的常数。</p><p>&emsp;&emsp;SPFA的核心原理和Bellman-ford算法是一样的，也是对点的松弛。只不过它优化了复杂度，优化的方法也很简单，用一个队列维护了可能存在新的松弛的点。这样我们每次从这些点出发去寻找其他可以松弛的点加入队列，这里面的原理<br>很简单，只有被松弛过的点才有可能去松弛其他的点。</p><p>&emsp;&emsp;SPFA的代码也很短，实现起来难度很低，单单从代码上来看和普通的宽搜区别并不大。</p><p>Python版本：<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queueque = Queue()<span class="hljs-comment"># 邻接表存储边</span>edges = [[]]<span class="hljs-comment"># 维护是否在队列当中</span>visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(V)]dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(V)]dis[s] = <span class="hljs-number">0</span>que.put(s)visited[s] = <span class="hljs-literal">True</span><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.emtpy():    u = que.get()    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:                que.add(v)                visited[v] = <span class="hljs-literal">True</span>                    visited[u] = <span class="hljs-literal">False</span></code></pre></p><p><a class="btn" href="https://www.acwing.com/problem/content/853/" title="title">参考题目</a></p><p>C++版本：<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], e[N], ne[N], w[N], idx;<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    q.push(<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> ( !q.empty() ) &#123;        <span class="hljs-keyword">int</span> t = q.front();        q.pop();                st[t] = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;            <span class="hljs-keyword">int</span> j = e[i];                        <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i]) &#123;                dis[j] = dis[t] + w[i];                st[j] = <span class="hljs-literal">true</span>;                q.push(j);            &#125;        &#125;    &#125;        <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[n];    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);        <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;        <span class="hljs-keyword">int</span> t = spfa();        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, t);&#125;</code></pre></p><p>Python版；<br><pre><code class="hljs python">n, m, k = map(int, input().split())<span class="hljs-comment">## 用一个list 记录所有边的信息即可</span>g = []dist = [float(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):    a, b, w = map(int, input().split())    g.append([a, b, w])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bellman_ford</span>():</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>    <span class="hljs-comment">## 循环几次代表最多用几条边</span>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(k):        <span class="hljs-comment">## 必须backup 防止在过程中会更新dist里面的数据导致并不是最多k条边</span>        backup = dist[:]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):            a, b, w = g[i][<span class="hljs-number">0</span>], g[i][<span class="hljs-number">1</span>], g[i][<span class="hljs-number">2</span>]            dist[b] = min(dist[b], backup[a] + w)bellman_ford()print(dist[n] <span class="hljs-keyword">if</span> dist[n] != float(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;impossible&quot;</span>)</code></pre></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最短路径算法&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>公告 | 🔊 置顶</title>
    <link href="http://www.wulnut.top/2020/09/15/%E7%BD%AE%E9%A1%B6/"/>
    <id>http://www.wulnut.top/2020/09/15/%E7%BD%AE%E9%A1%B6/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-09-16T16:30:40.055Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;</p><a id="more"></a><!-- <style>.box{  width:600px;  margin: 100px auto;  padding: 20px;  background-image:-webkit-linear-gradient(left,#3498db 0%,#f47920 10%,#d71345 20%,#f7acbc 30%,#ffd400 40%,#3498db 50%,#f47920 60%,#d71345 70%,#f7acbc 80%,#ffd400 90%,#3498db 100%);  color:transparent;  background-size:200% 100%;  -webkit-background-clip:text;  font-size:3em;  text-align:center;  animation: move 3s infinite linear;}@keyframes move{  0%{    background-position:0 0;  }  100%{    background-position:-100% 0;  }}hr.style{     width:80%;    margin:0 auto;    border: 0;    height: 1px;    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0)); }</style><center><div class='box'>国赛结束，恢复更新喽~</div></center><hr class = "style"><br><br><br><br>$$C = W \log_2 (1 + \frac{S}{N}) $$<br><br><br><br> --><style>section {    width: 100%;    height: 100px;    /*border: 1px solid red;*/    display: flex;    justify-content: space-around;    align-items: center;}section .section_item {    /*border: 1px solid blue;*/    position: relative;    display: flex;    justify-content: center;    align-items: center;    transition: filter 0.5s, transform 0.5s;}section .section_item .a {    color: #ffffff;    font-size: 2vw;    top: 0;    opacity: 1;    transition: top 0.5s, opacity 0.5s;}section .section_item .a:nth-child(1) {    position: absolute;    clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%);}section .section_item .a:nth-child(2) {    position: relative;    clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%);}/*出发景深效果*/section:hover .section_item {    filter: blur(10px);    transform: scale(0.8);    transition: filter 0.5s, transform 0.5s;}/*对应取消景深效果*/section .section_item:hover {    filter: blur(0px);    transform: scale(1.1);    transition: filter 0.5s, transform 0.5s;}section .section_item:hover .a:nth-child(1) {    top: -40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item:hover .a:nth-child(2) {    top: 40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item a {    position: absolute;    color: #fff;    text-decoration: none;    opacity: 0;    transition: opacity 0.5s;}section .section_item a:hover {    text-decoration: underline;}section .section_item:hover a {    opacity: 1;    transition: opacity 0.5s;}</style>  <section>        <div class="section_item">            <div class="a">Before.</div>            <div class="a">Before.</div>            <a class="btn" href="" title="title">六级</a>        </div>        <div class="section_item">            <div class="a">Now.</div>            <div class="a">Now.</div>            <a class="btn" href="" title="title">六级</a>        </div>        <div class="section_item">            <div class="a">After.</div>            <div class="a">After.</div>            <a class="btn" href="" title="title">六级</a>        </div>    </section><script>$(window).resize(function () {    resizeList();})function resizeList(){    var s_width=$(window).width();        //console.log("s_width:"+s_width);        if(s_width>600 && s_width <=1280)        {            $(".list-table1 li").css("width","25%");        }else if(s_width>400 && s_width <=600){            $(".list-table1 li").css("width","33.3%");        }else if(s_width>200 && s_width <=400){            $(".list-table1 li").css("width","50%");        }else if(s_width<=200){             $(".list-table1 li").css("width","100%");        }}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何配置与安装maven</title>
    <link href="http://www.wulnut.top/2020/07/11/maven%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.wulnut.top/2020/07/11/maven%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-11T09:30:47.941Z</published>
    <updated>2020-07-11T10:34:52.668Z</updated>
    
    <content type="html"><![CDATA[<p>介绍以下如何安装与配置maven</p><a id="more"></a><h1 id="一、-安装本地Maven"><a href="#一、-安装本地Maven" class="headerlink" title="一、 安装本地Maven"></a>一、 安装本地Maven</h1><ol><li><p>进入<a href="https://maven.apache.org/download.cgi">Apache maven官网</a>下载maven</p></li><li><p>点击左侧Download </p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_download.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">下载</div></center><ol><li><p>点击这个连接然后下载</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_download2.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">下载</div></center></li><li><p>下载完成之后，任意找一个文件夹存入然后解压</p></li><li>然后就开始配置环境变量了<ul><li>系统变量：MAVEN_HOME = ..\apache-maven-3.63</li><li>系统变量：path: %MAVEN_HOME%\bin</li></ul></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path3.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><h1 id="二、配置settings文件"><a href="#二、配置settings文件" class="headerlink" title="二、配置settings文件"></a>二、配置settings文件</h1><ol><li>在你放置maven文件的文件夹里找到conf文件夹然后可以在conf文件夹中找到setting文件</li><li>找到第52行，这里是设置maven默认的默认本地仓库。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li></ol><ol><li>我们复制第53行</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/path/to/local/repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>将它拿到注释外并将中间的内容改成你需要的路径，如图</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>F:/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>注意这个repository需要自己建,这里的路径随便设置，注意这里是正斜杠</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning)</li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阿里云仓库 --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-comment">&lt;!--或者--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><ol><li><p>如图，要夹在两个mirrors标签之间</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo3.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li><li><p>在最后配置jdk，也要夹在两个profiles标签之间</p></li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- java版本 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo4.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功</li></ol><p>最后，如果你使用的idea作为Java的IDE， 我们是可以将idea的maven仓库设置为本地仓库。<br>File -&gt; Build, Execution, Deployment -&gt; Maven修在下面两个参数就可以了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_idea.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍以下如何安装与配置maven&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="http://www.wulnut.top/categories/Notes/"/>
    
    
    <category term="Java" scheme="http://www.wulnut.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>半年记</title>
    <link href="http://www.wulnut.top/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    <id>http://www.wulnut.top/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/</id>
    <published>2020-07-02T14:43:33.527Z</published>
    <updated>2020-07-03T09:16:38.621Z</updated>
    
    <content type="html"><![CDATA[<p>简单的总结一下这荒废的半个学期</p><a id="more"></a><h1 id="一切都是要从蝙蝠说起"><a href="#一切都是要从蝙蝠说起" class="headerlink" title="一切都是要从蝙蝠说起"></a>一切都是要从蝙蝠说起</h1><p>&emsp;&emsp;由于2019年起的一只蝙蝠，我们的生活出现了天翻地覆的变化。在家隔离遵守防疫要求，争取不给国家添乱。在家度过了我最为魔幻的一个寒假，虽然在家但是我丝毫没感受到无聊，相反还发生了很多有趣的事情，我觉得我有必要对期间发生的经过找时间好好记录一下。</p><h2 id="这可能是高中时所期盼的"><a href="#这可能是高中时所期盼的" class="headerlink" title="这可能是高中时所期盼的"></a>这可能是高中时所期盼的</h2><p>&emsp;&emsp;上高中的时候总想着能在大学过的舒服，还能有超长的假期，每次在寒暑假结束的时候大家总会调侃：“嗯你假期余额已不足请及时充值”。不过很对不这个恐怖故事真的出现了.</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear2.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><p>&emsp;&emsp;虽然没有上图那么恐怖，但是我寒假确实涨了不少这一涨就是一个学期。线下教学也随之敲定转为线上。刚开始上网课，还每天幻想<br>嗯等等3月份学校就会要我们回去了。但是在一次和周老师的聊天中得知广东那边的学校可能会在6月底开学，一开始对这个差异的消息还是还保持着<br>怀疑态度，每天上课老师也在和我们预测学校会在什么时候开学，武汉什么时候解封这样的话题。但是慢慢的，随着北师大说今年上半年不开学、听<br>到华科的朋友说他们辅导员发长文警告那些期待等回学校再补课的同学要好好学习的截图，时我才意识到今年武汉上边年不开学，可能是真的了做好打持久战的准备是一定的了。<br>&emsp;&emsp;果然随着所有课程全部转入线上教学的开始，上半年在家学习也就真的出现了。但是我对线上教学有着强烈的抵触情绪，根本没有想跟着老师的节奏好好在家里学习本学期既定的课程，“我上不了985，我看985的网课还不行么”这句话虽然搞笑，但确十分真实。线上上课老师和学校也是绞尽脑汁，督促学生好好在线上学习，不要逃课。可是呢？有些老师总喜欢用着骗三岁小孩的话来骗我们，制定了一些十分好笑的条条框框，什么早自习打卡啊、晚自习打卡啊等等吧。打完卡再去睡觉然后等到开课在起床这样操作，不用说也有人会做。但是有些人就是爱与面子，说自己按时打卡学习早读，晚自习。当然我也认识真正这样做的人。为此我也背上了逃早自这样的搞笑的名号。嗯大三了我看大家谁，睡得香~<br>&emsp;&emsp;虽然说我不想听老师线上的讲课，但是我又害怕错过一些知识。说白了就是“贱”，上网课就挂在那里假惺惺的听老师的讲课然后把声音调到最小，自己看各大名校的网课视频。这也算是我在名校学习了吧Hhhh。不得不说中科大概率真香，听课真如醍醐灌顶一样，想我基础这么差的，在学习玩之后也能明白个八九不离十，还有翁恺的程序课，不说了质量真的高，比上课讲所谓的算法题要实在的多，带你一步一步实现一个小小的项目，并学习其中的一些关键词和用法。比上课听理论，缺乏实践要来的实在的多，虽然不能说我做题一定能做对，但是我用一定用的恰到好处。<br>&emsp;&emsp;当然也是由于课程安排的原因周么也就只能休息一天，不过我大部分时间也是花在了学习网课上了，其实去完成自己的兴趣也是极少<br>并没有我想的那种可以搞搞别的事情，学习一下新的知识。也不知道该怎么形容，新的看的眼馋，旧也不想丢。两手抓，最终还是没干成一样。</p><h2 id="在家时间过的真的很快"><a href="#在家时间过的真的很快" class="headerlink" title="在家时间过的真的很快"></a>在家时间过的真的很快</h2><p>&emsp;&emsp;不得不说在家学习的时间过的真的很快虽然天天在上课，但是循环往复时间也就一下没了。到了5月份参加了一些无聊的比赛，每天熬夜到深夜，感觉自己很充实每天都很忙，要做好多事情。但是呢其实我啥也没干成，自己还累的够呛。感觉那段时间自己写了7、8万字，每天都在对着键盘打字。因为时间紧迫，外加上学长的催促。就想机器一样每天都在赶工期完成以下我都不知道我在干什么的东西。(退坑了退坑了，后面不能再参加了)<br>&emsp;&emsp;晃一晃这个学期就没几周了，扫清了比赛的事情之后就是专心的学习，我尝试认真的听老师上课，但是我还是放弃了。上一次课3、4<br>个小时的煎熬，虽然老师讲的很拖沓，但是知识含量太高一下子真的接受不了。还是自己看吧….</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear3.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;当然这🐕学习通，真是想个毒瘤一样。学习通上的成堆的视频，都要计入平时分今年平时分还是55开(上香)。我也就开始了疯狂的补补课模式，可能是我高估了学校期末考试的难度。总感觉自己的掌握程度不够，在文库找题做，针对知识点练习一下。我也很离奇的开始梳理知识结构因为我是真的觉得学的知识很乱，感觉没有形成知识体系。但是目前来说到现在我都没有形成知识体系。</p><h2 id="都是大佬"><a href="#都是大佬" class="headerlink" title="都是大佬"></a>都是大佬</h2><p>&emsp;&emsp;也就预习了尽一个月吧，中途周末实在是不行听课，就开车出去玩了一下。还是很开心的~然后就开始期末考试了，有人就喜欢🐕叫</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear4.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>当然我也是个儒雅随和的人，不和他计较。有冇搞错，管你咩事。我也在每次出成绩之后问了一下谁是最高分，我也没有听到你的名字呀。还专门买课本，在我这种垃圾面前卖弄自己了解到的知识。知识也分高低贵贱？</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear5.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;我也很庆幸我有一些很要好的朋友，和三个优秀的室友。虽然各有专攻但是大家在一起交流总是很快乐的。在不断学习的过程中，有人愿你和你解释交流，我觉得是一件很美好的事情。而不是自己守着自己所谓的优势，谦卑谦卑再谦卑。这也是我慢慢明白的，不是因为你知道的有多少，懂得有多少。我才会说你牛逼是大佬，你出来溜溜交流一下，光说不练假把式嘛，这一下子便高判立下。这个月我也感觉自己实在是浮躁，以前都说我浮躁，但是我总是不明白浮躁到是为什么。这个假期我也好像慢慢明白理解所谓的浮躁。脚踏实地，似乎才是最难实现的东西。为了一些论文<br>每天忙活，似乎还不如早点开始学习专业方向。认真学习一下什么是机器学习。复制百度百科我们谁都会。</p><p>&emsp;&emsp;先就说到这吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的总结一下这荒废的半个学期&lt;/p&gt;</summary>
    
    
    
    <category term="day" scheme="http://www.wulnut.top/categories/day/"/>
    
    
    <category term="day" scheme="http://www.wulnut.top/tags/day/"/>
    
  </entry>
  
  <entry>
    <title>SQL入门训练题</title>
    <link href="http://www.wulnut.top/2020/05/25/sql%E8%AE%AD%E7%BB%83/"/>
    <id>http://www.wulnut.top/2020/05/25/sql%E8%AE%AD%E7%BB%83/</id>
    <published>2020-05-25T13:43:06.477Z</published>
    <updated>2020-07-02T14:40:47.568Z</updated>
    
    <content type="html"><![CDATA[<p>sql训练题</p><p><a href="https://www.jianshu.com/p/476b52ee4f1b">https://www.jianshu.com/p/476b52ee4f1b</a></p><a id="more"></a><h2 id="数据表介绍"><a href="#数据表介绍" class="headerlink" title="数据表介绍"></a>数据表介绍</h2><p>—1.学生表<br>Student(SId,Sname,Sage,Ssex)<br>—SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别</p><p>—2.课程表<br>Course(CId,Cname,TId)<br>—CId 课程编号,Cname 课程名称,TId 教师编号</p><p>—3.教师表<br>Teacher(TId,Tname)<br>—TId 教师编号,Tname 教师姓名</p><p>—4.成绩表<br>SC(SId,CId,score)<br>—SId 学生编号,CId 课程编号,score 分数</p><h2 id="学生表-Student"><a href="#学生表-Student" class="headerlink" title="学生表 Student"></a>学生表 Student</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sname <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sage datetime,Ssex <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-12-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-12-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;09&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span> , <span class="hljs-string">&#x27;2017-12-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;10&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2017-12-25&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;11&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2012-06-06&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span> , <span class="hljs-string">&#x27;赵六&#x27;</span> , <span class="hljs-string">&#x27;2013-06-13&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;13&#x27;</span> , <span class="hljs-string">&#x27;孙七&#x27;</span> , <span class="hljs-string">&#x27;2014-06-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);</code></pre><h2 id="科目表-Course"><a href="#科目表-Course" class="headerlink" title="科目表 Course"></a>科目表 Course</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),CId <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),score <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);</code></pre><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><ol><li>查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数<br>1.1 查询同时存在” 01 “课程和” 02 “课程的情况</li></ol><p>1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</p><p>1.3 查询不存在” 01 “课程但存在” 02 “课程的情况</p><ol><li><p>查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p></li><li><p>查询在 SC 表存在成绩的学生信息</p></li><li><p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</p></li></ol><p>4.1 查有成绩的学生信息</p><ol><li><p>查询「李」姓老师的数量</p></li><li><p>查询学过「张三」老师授课的同学的信息</p></li><li><p>查询没有学全所有课程的同学的信息</p></li><li><p>查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息</p></li><li><p>查询和” 01 “号的同学学习的课程 完全相同的其他同学的信息</p></li><li><p>查询没学过”张三”老师讲授的任一门课程的学生姓名</p></li><li><p>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p></li><li><p>检索” 01 “课程分数小于 60，按分数降序排列的学生信息</p></li><li><p>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p></li><li><p>查询各科成绩最高分、最低分和平均分：</p></li><li><p>以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</p></li><li><p>及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p></li><li><p>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时合并名次</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时保留名次空缺</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</p></li><li><p>统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</p></li><li><p>查询各科成绩前三名的记录</p></li><li><p>查询每门课程被选修的学生数</p></li><li><p>查询出只选修两门课程的学生学号和姓名</p></li><li><p>查询男生、女生人数</p></li><li><p>查询名字中含有「风」字的学生信息</p></li><li><p>查询同名同性学生名单，并统计同名人数</p></li><li><p>查询 1990 年出生的学生名单</p></li><li><p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p></li><li><p>查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩</p></li><li><p>查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p></li><li><p>查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</p></li><li><p>查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p></li><li><p>查询不及格的课程</p></li><li><p>查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名</p></li><li><p>求每门课程的学生人数</p></li><li><p>成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p></li><li><p>查询每门功成绩最好的前两名</p></li><li><p>统计每门课程的学生选修人数（超过 5 人的课程才统计）。</p></li><li><p>检索至少选修两门课程的学生学号</p></li><li><p>查询选修了全部课程的学生信息</p></li><li><p>查询各学生的年龄，只按年份来算</p></li><li><p>按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</p></li><li><p>查询本周过生日的学生</p></li><li><p>查询下周过生日的学生</p></li><li><p>查询本月过生日的学生</p></li><li><p>查询下月过生日的学生</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;sql训练题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/476b52ee4f1b&quot;&gt;https://www.jianshu.com/p/476b52ee4f1b&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="sql" scheme="http://www.wulnut.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>逻辑规则总结</title>
    <link href="http://www.wulnut.top/2020/05/23/logist/"/>
    <id>http://www.wulnut.top/2020/05/23/logist/</id>
    <published>2020-05-23T09:25:04.972Z</published>
    <updated>2020-06-14T15:05:42.949Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结逻辑推理规则与规律</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>&emsp;&emsp;由于数字逻辑种得推理规则与离散数学中得推理规则几乎是一模一样得。<br>对此讲有关逻辑推理部分进行总结。</p><h1 id="数字逻辑与离散数学"><a href="#数字逻辑与离散数学" class="headerlink" title="数字逻辑与离散数学"></a>数字逻辑与离散数学</h1><div class="table-container"><table><thead><tr><th>数字逻辑</th><th>离散数学</th></tr></thead><tbody><tr><td>或：$A$ $\cdot$  $B$</td><td>或: A $ \and B$</td></tr><tr><td>与: $A+B$</td><td>与: A $  \or B$</td></tr><tr><td>非:   $\overline{A}$</td><td>非: $ \neg A$</td></tr></tbody></table></div><h1 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h1><h2 id="基本公理"><a href="#基本公理" class="headerlink" title="基本公理"></a>基本公理</h2><ul><li>交换律：$A + B = B + A$   $or$  $A \cdot B = B \cdot A$</li><li>结合率：$(A + B)+C = A+(A+B)$   $or$   $(A \cdot B) \cdot C = A \cdot (B \cdot C)$</li><li>分配率：$A + (B \cdot C) = (A + B) \cdot (A + C)$    $or$   $A \cdot(B + C) = A \cdot B + A \cdot C$</li><li>$0-1$律：$A + 0 = A$  $or$  $A \cdot 1 = A$  $or$  $A + 1 = 1$  $or$  $A \cdot 0 = 0$</li><li>互补律：$\overline{A} + A = 1$  $or$  $\overline{A} \cdot A = 0$</li></ul><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><ul><li>定理1： $0 + 0 = 0$ 、$0 + 1 = 1$、 $1 + 0 = 1$、 $1 + 1 = 1$、$0 \cdot 0 = 0$、$0 \cdot 1 = 0$、 $1 \cdot 0 = 0$、 $1 \cdot 1 = 1$</li><li>重叠律： $A + A = A$   $or$  $A \cdot A = A$</li><li>吸收率： $A + A \cdot B = A$  $or$  $A \cdot(A + B) = A$</li><li>消因子法: $A + \overline{A} \cdot B = A + B$  $or$  $A \cdot(\overline{A} + B) = A \cdot B$</li><li>并项法： $A \cdot B + A \cdot \overline{B} = A$  $or$  $(A + B) \cdot (A + \overline{B}) = A$</li><li>消项法： $A \cdot B + \overline{A} \cdot C + B \cdot C = A \cdot B + \overline{A} \cdot C$  $or$  $(A + B) \cdot (\overline{A} + C) \cdot(B + C) = (A + B) \cdot (\overline{A} + C)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单总结逻辑推理规则与规律&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
  </entry>
  
  <entry>
    <title>快读</title>
    <link href="http://www.wulnut.top/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"/>
    <id>http://www.wulnut.top/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/</id>
    <published>2020-05-12T08:50:44.853Z</published>
    <updated>2020-05-15T14:47:30.760Z</updated>
    
    <content type="html"><![CDATA[<p>快读的一些方法</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在做数据结构、算法题的时候会遇见比较大的数，有的时候数据大小已经超过了int所能储存的范围，这样的大数如果比较多情况下如果使用普通的输入或者输出，超时就可能会发生，如果出现这样的错误，在算法时间复杂度没有问题的前提下出现这样的问题是非常令人头疼的一件事情。</p><p>这里我将从Java和C++两中语言入手，在减少这样的问题出现</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一、StreamTokenizer实现快速输入</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;</code></pre><p>定义如下：</p><pre><code class="hljs java">StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));</code></pre><p>StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：!@#$%^&amp;*()[]{})无法识别，会显示null</p><p>StreamTokenizer可以<strong>获取输入</strong>流并根据空格和回车分割成Token（标记），用nextToken方法读取下一个标记 </p><p>如果标记是字符串，用st.sval获取标记，如果是数字用st.nval获取标记，st.navl是double类型</p><p>示例</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));        st.nextToken();        String s=st.sval;        System.out.println(s);        st.nextToken();        <span class="hljs-keyword">double</span> n=st.nval;        System.out.println(n);        <span class="hljs-comment">/**输入内容</span><span class="hljs-comment">         * hollow 1233</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow</span><span class="hljs-comment">         * 1233.0</span><span class="hljs-comment">         */</span>            &#125; &#125;</code></pre><p>二、BufferedReader实现快速输入读一行</p><p>需要导入的jar</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;</code></pre><p>定义：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</code></pre><p>常用方法：</p><pre><code class="hljs java">inBuff.readLine()<span class="hljs-comment">//读取一行内容，返回字符串</span></code></pre><p>实例：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        String s=inBuff.readLine();        System.out.println(<span class="hljs-string">&quot;有问题吗&quot;</span>+s+<span class="hljs-string">&quot;没有吧&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world!</span><span class="hljs-comment">         * 有问题吗hollow world!没有吧</span><span class="hljs-comment">         */</span></code></pre><p>三、PrintWriter实现快速输出</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;</code></pre><p>定义如下：</p><pre><code class="hljs java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));</code></pre><p>常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 输出分为两步：</span><span class="hljs-comment">// 1、先通过print()或println()方法把需要输出的内容放入缓冲区，</span><span class="hljs-comment">// 2、然后通过flush()将缓冲区的内容输出到控制台</span>print(需要输出的内容)<span class="hljs-comment">//不换行输出，只是把需要的内容放入缓冲，</span>println(需要输出的内容)<span class="hljs-comment">//换行输出</span>flush()<span class="hljs-comment">//刷新缓冲区，把缓冲区的内容输出到控制台，</span></code></pre><p>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> CCPC;<span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));        String s=<span class="hljs-string">&quot;hollow world&quot;</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">12344</span>;        out.print(s+<span class="hljs-string">&quot; &quot;</span>+i);        out.flush();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world 12344</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre><p>一个例子<br><strong>一般建议使用BufferedRead()</strong><br><pre><code class="hljs java"><span class="hljs-comment">// https://www.acwing.com/problem/content/790/</span><span class="hljs-comment">// 使用BufferedReader读入的方法</span><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex4</span> </span>&#123;    <span class="hljs-comment">// 全局变量</span><span class="hljs-comment">//    static int N = 100010;  // 数据规模为 10w</span><span class="hljs-comment">//    static int[] arr = new int[N];</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-comment">// parseInt将字符串转为int</span>        <span class="hljs-comment">// parseDouble将字符转为double</span>        <span class="hljs-keyword">int</span> n = Integer.parseInt(reader.readLine());        String[] arrStr = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;            arr[i] = Integer.parseInt(arrStr[i]);        &#125;        reader.close();        <span class="hljs-keyword">long</span> ans = mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        System.out.println(ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> res = mergesort(arr, l, mid) + mergesort(arr,mid + <span class="hljs-number">1</span>, r);        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k ++] = arr[i ++];            <span class="hljs-keyword">else</span> &#123;                res += mid - i + <span class="hljs-number">1</span>;                temp[k ++] = arr[j ++];            &#125;        &#125;        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = arr[i ++];        <span class="hljs-keyword">while</span> (j &lt;=   r) temp[k ++] = arr[j ++];        <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) &#123;            arr[i] = temp[j];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="getchar读入"><a href="#getchar读入" class="headerlink" title="getchar读入"></a>getchar读入</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> , ch = getchar();    <span class="hljs-keyword">while</span>( !<span class="hljs-built_in">isdigit</span>( ch ) ) ch = getchar();    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">isdigit</span>( ch ) ) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span> , ch = getchar();    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>用时28.74s</p><h3 id="fread读入优化"><a href="#fread读入优化" class="headerlink" title="fread读入优化"></a>fread读入优化</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ibuf[<span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span>] , * s;    io()    &#123;        fread( s = ibuf , <span class="hljs-number">1</span> , <span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span> , <span class="hljs-built_in">stdin</span> );    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>( * s &lt; <span class="hljs-number">48</span> ) s++;        <span class="hljs-keyword">while</span>( * s &gt; <span class="hljs-number">32</span> )            u = u * <span class="hljs-number">10</span> + * s++ - <span class="hljs-number">48</span>;        <span class="hljs-keyword">return</span> u;    &#125;&#125; ip;</code></pre><p>用时1.535s</p><h3 id="当然如果觉得以上的方法比较麻烦可以："><a href="#当然如果觉得以上的方法比较麻烦可以：" class="headerlink" title="当然如果觉得以上的方法比较麻烦可以："></a>当然如果觉得以上的方法比较麻烦可以：</h3><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::ios::sync_with_stdio(<span class="hljs-literal">false</span>);</code></pre><p>通过对cin和cout的解除绑定可以达到和scanf于printf一样的速度有时候会更快</p><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><p><strong>cout</strong></p><p>用时102.2s</p><p><strong>printf</strong></p><p>用时27.36s</p><p><strong>puts（直接当字符串输出）</strong></p><p>用时2.001s</p><h3 id="putchar输出优化"><a href="#putchar输出优化" class="headerlink" title="putchar输出优化"></a>putchar输出优化</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);        x=-x;    &#125;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)        print(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;</code></pre><p>用时3.339s</p><h3 id="fwrite输出优化"><a href="#fwrite输出优化" class="headerlink" title="fwrite输出优化"></a>fwrite输出优化</h3><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span><span class="hljs-class">    <span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span>( <span class="hljs-title">register</span> <span class="hljs-title">T</span> <span class="hljs-title">u</span> )</span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> * q = a;        <span class="hljs-keyword">if</span>( !u ) * t++ = <span class="hljs-number">48</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>( u &lt; <span class="hljs-number">0</span> )                * t++ = <span class="hljs-number">45</span> , u *= <span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span>( u ) * q++ = u % <span class="hljs-number">10</span> + <span class="hljs-number">48</span> , u /= <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>( q != a )                * t++ = * --q;        &#125;    &#125;</code></pre><p>用时0.6653s</p><p><strong>由此可以看出，fwrite对比其他读入方式有极大的差距</strong></p><p>不过由于一般输出量都比较小，所以输出优化意义不大</p><h2 id="inline-define-register"><a href="#inline-define-register" class="headerlink" title="inline,define,register"></a>inline,define,register</h2><p>register就是把东西放到寄存器里面</p><p>比如for( int i = 1 ; i &lt;= n ; i++ )</p><p>可以写成for( register int i = 1 ; i &lt;= n ; i++ )</p><p>但是这个不一定有用，因为这个int可能编译器会帮你放寄存器里面</p><p><strong>for register short可能比for register int慢，因为short的寄存器更少..</strong><br><strong>大家for循环里面还是int比较好</strong></p><p>register在大部分情况下（特别是开了O2的时候）并没有明显的优化效果，如果加错了反而可能负优化</p><p>如果一个简单函数调用次数很多，属于瓶颈，调用时的传参可能会大大影响程序效率</p><p>这种情况下可以把这个函数给inline掉</p><p>inline就是把一个函数内联，可以减少跳转和传参的代价</p><p>但是如果这个函数过于复杂，可能并不会inline，可以考虑<strong>attribute</strong> ( ( always_inline ) )或者手动展开，或者define掉（注意define别爆炸）</p><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/qq_40079933/article/details/79419065">https://blog.csdn.net/qq_40079933/article/details/79419065</a></li><li><a href="https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua">https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;快读的一些方法&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Text Format</title>
    <link href="http://www.wulnut.top/2020/05/05/scenes1/"/>
    <id>http://www.wulnut.top/2020/05/05/scenes1/</id>
    <published>2020-05-05T15:20:18.417Z</published>
    <updated>2020-05-05T15:48:51.728Z</updated>
    
    <content type="html"><![CDATA[<p>manim 入门</p><a id="more"></a><h1 id="Text-format"><a href="#Text-format" class="headerlink" title="Text format"></a>Text format</h1><pre><code class="hljs 注意```:">&#96;&#96;&#96;python3from big_ol_pile_of_manim_imports import *</code></pre><p>在第一行</p><h2 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h2><pre><code class="hljs python3">class WriteText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/WriteText.gif" alt=" "></p><pre><code class="hljs python3">class AddText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.add(text)        self.wait(3)</code></pre><p><img src="/img/AddText.gif" alt=" "></p><pre><code class="hljs python3">class Formula(Scene):     def construct(self):         formula &#x3D; TexMobject(&quot;This is a formula&quot;)        self.play(Write(formula))        self.wait(3)</code></pre><p><img src="/img/Formula.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $this is a formula$,            $$this is a formula$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText2(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText2.gif" alt=" "></p><pre><code class="hljs python3">class DisplayFormula(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\displaystyle\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/DisplayFormula.gif" alt=" "></p><pre><code class="hljs python3">class TextInCenter(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInCenter.gif" alt=" "></p><pre><code class="hljs python3">class TextOnTopEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnTopEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnBottomEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnBottomEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnRightEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnRightEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnLeftEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(LEFT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnLeftEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextInUpperRightCorner(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP+RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInUpperRightCorner.gif" alt=" "></p><pre><code class="hljs python3">class TextInLowerLeftCorner(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;Text&quot;)         text.to_edge(LEFT+DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInLowerLeftCorner.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(0.25*UP)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/CustomPosition1.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(1*UP+1*RIGHT)        self.play(Write(textM),Write(textC))        self.wait(1)        textM.move_to(1*UP+1*RIGHT)         self.play(Write(textM))        self.wait(3)</code></pre><p><img src="/img/CustomPosition2.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.next_to(textC,LEFT,buff&#x3D;1)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition1.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP*0.1)        self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition2.gif" alt=" "></p><pre><code class="hljs python3">class RotateObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP)        textM.rotate(PI&#x2F;4) # &lt;- Radians        # You can use .rotate(45*DEGREES) too        self.play(Write(textM),Write(textC))        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI)        self.wait(2)</code></pre><p><img src="/img/RotateObject.gif" alt=" "></p><pre><code class="hljs python3">class FlipObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textM.flip(UP)        self.play(Write(textM))        self.wait(2)</code></pre><p><img src="/img/MirrorObject.gif" alt=" "></p><pre><code class="hljs python3">class SizeTextOnLaTeX(Scene):    def construct(self):        textHuge &#x3D; TextMobject(&quot;&#123;\\Huge Huge Text 012.\\#!?&#125; Text&quot;)        texthuge &#x3D; TextMobject(&quot;&#123;\\huge huge Text 012.\\#!?&#125; Text&quot;)        textLARGE &#x3D; TextMobject(&quot;&#123;\\LARGE LARGE Text 012.\\#!?&#125; Text&quot;)        textLarge &#x3D; TextMobject(&quot;&#123;\\Large Large Text 012.\\#!?&#125; Text&quot;)        textlarge &#x3D; TextMobject(&quot;&#123;\\large large Text 012.\\#!?&#125; Text&quot;)        textNormal &#x3D; TextMobject(&quot;&#123;\\normalsize normal Text 012.\\#!?&#125; Text&quot;)        textsmall &#x3D; TextMobject(&quot;&#123;\\small small Text 012.\\#!?&#125; Texto normal&quot;)        textfootnotesize &#x3D; TextMobject(&quot;&#123;\\footnotesize footnotesize Text 012.\\#!?&#125; Text&quot;)        textscriptsize &#x3D; TextMobject(&quot;&#123;\\scriptsize scriptsize Text 012.\\#!?&#125; Text&quot;)        texttiny &#x3D; TextMobject(&quot;&#123;\\tiny tiny Texto 012.\\#!?&#125; Text normal&quot;)        textHuge.to_edge(UP)        texthuge.next_to(textHuge,DOWN,buff&#x3D;0.1)        textLARGE.next_to(texthuge,DOWN,buff&#x3D;0.1)        textLarge.next_to(textLARGE,DOWN,buff&#x3D;0.1)        textlarge.next_to(textLarge,DOWN,buff&#x3D;0.1)        textNormal.next_to(textlarge,DOWN,buff&#x3D;0.1)        textsmall.next_to(textNormal,DOWN,buff&#x3D;0.1)        textfootnotesize.next_to(textsmall,DOWN,buff&#x3D;0.1)        textscriptsize.next_to(textfootnotesize,DOWN,buff&#x3D;0.1)        texttiny.next_to(textscriptsize,DOWN,buff&#x3D;0.1)        self.add(textHuge,texthuge,textLARGE,textLarge,textlarge,textNormal,textsmall,textfootnotesize,textscriptsize,texttiny)        self.wait(3)</code></pre><p><img src="/img/SizeTextOnLaTeX.gif" alt=" "></p><pre><code class="hljs python3">class TextFonts(Scene):    def construct(self):        textNormal &#x3D; TextMobject(&quot;\\textrm&#123;Roman serif text 012.\\#!?&#125; Text&quot;)        textItalic &#x3D; TextMobject(&quot;\\textit&#123;Italic text 012.\\#!?&#125; Text&quot;)        textTypewriter &#x3D; TextMobject(&quot;\\texttt&#123;Typewritter text 012.\\#!?&#125; Text&quot;)        textBold &#x3D; TextMobject(&quot;\\textbf&#123;Bold text 012.\\#!?&#125; Text&quot;)        textSL &#x3D; TextMobject(&quot;\\textsl&#123;Slanted text 012.\\#!?&#125; Text&quot;)        textSC &#x3D; TextMobject(&quot;\\textsc&#123;Small caps text 012.\\#!?&#125; Text&quot;)        textNormal.to_edge(UP)        textItalic.next_to(textNormal,DOWN,buff&#x3D;.5)        textTypewriter.next_to(textItalic,DOWN,buff&#x3D;.5)        textBold.next_to(textTypewriter,DOWN,buff&#x3D;.5)        textSL.next_to(textBold,DOWN,buff&#x3D;.5)        textSC.next_to(textSL,DOWN,buff&#x3D;.5)        self.add(textNormal,textItalic,textTypewriter,textBold,textSL,textSC)        self.wait(3)</code></pre><p><img src="/img/TextFonts.gif" alt=" "></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;manim 入门&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="python" scheme="http://www.wulnut.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>第一期半月谈</title>
    <link href="http://www.wulnut.top/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/"/>
    <id>http://www.wulnut.top/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/</id>
    <published>2020-05-02T14:42:30.941Z</published>
    <updated>2020-05-04T04:40:24.463Z</updated>
    
    <content type="html"><![CDATA[<p>这是是我对现在的简单思考</p><a id="more"></a><p>&emsp;&emsp;现在是5月1号，距离上次更新博客已经很久了。因为在家上课，所以时间非常自由。因为想参加一下蓝桥杯，来看看自己的专业水平到底怎么样。所以就慢慢开始准备学习算法起来了。</p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>&emsp;&emsp;在学习算法的过程种，我慢慢的对我自己的真实能有了比较全面的了解。从简单的基本算法开始到数据结构到图论</p><script type="math/tex; mode=display">基本算法\rightarrow 数据结构 \rightarrow 图论 \rightarrow \dots</script><p>说实话没得一步是简单的，是真的举步维艰。基本算法中的枚举、模拟、递归、分治$\dots$ 我感觉我到现在都没有真正学会其中的思想，每天坚持通过训练的方式来提高自己的对一些算法的理解，但是半天下来可能也就做了一两个题目，有时候思路开阔可能也就三四个，但是大部分时间也就是一两个的样子。可能是在家的原因，调板子没啥效率。但是这种挫败感是太真实了，随着渐渐对这种方向的深入了解。也就慢慢的明白自己知道东西实在是太少了，不断的从一些教学视频里面慢慢的学习前人总结出的经验。</p><p>但是这确实很可笑，你感觉你学会了一种算法，但是题目给你变一变，你就立马懵逼了。如果说做算法题可以类比成你高中的数学题的话，可能就是你题型见的不够多，总结的很少导致的。但这也是困难所在，虽然算法就那么多你这么能正真理解一个题目到底想怎么考你去使用这个算法是十分困难的。就拿前缀和为例</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> arr[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i], arr[i] += arr[i - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>前缀和就是那样很简单，就是一个arr[i] = arr[i - 1] + arr[i];的一个公式，在仔细看看其实是就是前$N$项求和，但是它有什么用？怎么用？可以干啥一般都是怎么处理的。</p><p>完完全全就需要你自己去总结思考，但是可能这种小技巧也只会出现在你解决某个题目中的一个小步骤中，但是有些人总是能把这种小技巧玩的出神入化，来降低时间复杂度。这就要看各位对这种技巧的理解了，没人能帮助你。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在知乎上经常能看到有人发这样的问题，“大神都是如何刷leetcode的”。我才这样的问这样问题的人都是一些为了找工作而去刷题的人。因为正真的大佬早已经在ACM类比赛中把算法这东西玩的炉火纯青了，你可能还在第一层，人家已经到了第五层了。其中有个人的回答很是亮眼，他说：你把打好的青春都浪费在刷LeetCode上那你为什么不把那些时间去研究一下新技术，学习一下技术的底层实现呢？看到一个题目思考了10分钟还没思路那就去看题解理解这个题目，花费那么长时间浪费在这上面不那么值得。就像郭杰瑞那期视频一样老郭做了江苏高考英语试卷但是到最后结果和大家想的一样，错了很多，是他英语差吗不是，那是人家的母语那是什么是缺乏这方面的训练。也就是说为什么我们刚开始学算法的时候为什么会那么痛苦，没有接收相关的训练很难一开始就上手完成的很好，针对的训练是至关重要的。</p><p>但是我反观一下自己，把大把的时间花在学习这些东西上是否也是一种浪费？当然不是，那是我以后吃饭的东西花费时间在这上面怎么算是浪费呢？但是我觉得我缺走上了歧途，什么歧途？</p><p>C++:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span>;&#125;</code></pre><p>Java:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">public</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;&#125;</code></pre><p>Python:</p><pre><code class="hljs python">print(<span class="hljs-string">&quot;Hello World&quot;</span>)</code></pre><p>JavaScript:</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello World&quot;</span>);</code></pre><p>我现在会四种语言来写出Hello World这个词，说明我了解了很多不同种类的编程语言但是，我确实不明白为什么我们要一开始去写一个Hello World。是因为他简单？其实并不是，学习编程每个人的目的是不同的，为什么现在社会上有那么多培训班，在短短是几个星期里面就能教出一个人去公司里面上班每个月拿着一两万的工资？因为现在很多东西被模式化了，</p><p>UADC(update, add, delete, create)这样的模式几乎符合任何情况，并不是人们想的通过编程来改变世界。如果说你被这种混口饭吃的想法所束缚，那你的发展也就那样的。那科班生和培训班的人也就没什么两样的了，科班生不只是有很多时间去打磨自己的能力，更多的是有时间去创造。这些语言归根到底是一种我们所特有的一种工具，而这种工具用来帮助我们把现实生活中的一些常见问题给抽象出来我们通过算法来反复重复的解决这种问题来方便我们。这才是我们的学习的正真目的，为什么说各个行业都需要会写程序的人，但是这些领域有时候又和计算机专业完全不沾边。但是就有人能去创造它方便行业快速发展，而这就是创造力。而不是仅仅的为了那一两行算法代码。这也是为什么说我<strong>没趣、死板、不懂审美</strong>$\dots$ 的原因。</p><p>被这种看起来死板的东西所束缚了，不能走出这种圈子，去学习了解更多的东西来正真成就自己。</p><p>$未完\dots$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是是我对现在的简单思考&lt;/p&gt;</summary>
    
    
    
    <category term="半月谈" scheme="http://www.wulnut.top/categories/%E5%8D%8A%E6%9C%88%E8%B0%88/"/>
    
    
    <category term="回忆，杂谈" scheme="http://www.wulnut.top/tags/%E5%9B%9E%E5%BF%86%EF%BC%8C%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="http://www.wulnut.top/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>http://www.wulnut.top/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-04-01T09:10:36.287Z</published>
    <updated>2020-09-17T10:34:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>快快快~</p><a id="more"></a><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>问题描述：</p><p>&emsp;&emsp;求$A^B$的最后三位数的整数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果我们直接通过循环的方法来解决我们会发现</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;            result = result * base;      &#125;        <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>如果给出$base = 2$ $power = 100$ 的时候我们就就会发现函数$f(x) = a^{b}$是一个指数函数后期的增长速度是非常快的所以我们需要对此进行优化。</p><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p>取模运算有以下 性质：</p><ol><li><p>$(a + b)\%c = ((a\%c) + (b\%c))\%c$</p></li><li><p>$(a \times b)\%c = ((a\%c) \times (b\%c))\%c$</p></li><li><p>$(a - b)\%c = ((a\%c)-(b\%c))\%c$</p><p>总成依据话就是，在取模运算的时候我们在中间过程每次都取模，在得出答案之后我们再取一次模。</p><p>我们通过性质性质2来优化我们的代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;        result *= base;        result %= <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>通过这样的运算优化，我们发现这种取模运算中如果我们中间进行取模的话是可以防止出现溢出的情况的。</p></li></ol><h2 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h2><p>&emsp;&emsp;快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。从而达到快速计算的目的。</p><p>例如：</p><p>$3^{10} = 3\times3\times3\times3\times3\times3\times3\times3\times3\times3$</p><p>我们可以尽可能的将其指数降下来，来简化运算。</p><p>$3^{10} = (3\times3)\times(3\times3)\times(3\times3)\times(3\times3)\times(3\times3)$</p><p>$3^{10} = (3\times3)^5$</p><p>其实这种方法也在平常也是十分常见的，比如我们向计算$2^4$我们肯定不会一个一个的乘$2$我们一般都会去直接计算$4\times4$从而快速的计算出结果，其实两者的关系是一样的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = base;        whlie (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果指数为偶数</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//把指数缩小为一半</span>            base = base * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//底数变大成原来的平方</span>        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">//如果指数为奇数</span>            power = power - <span class="hljs-number">1</span>;<span class="hljs-comment">//把指数减去1，使其变成一个偶数</span>            result = result * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//此时记得要把指数为奇数时分离出来的底数的一次方收集好</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//此时指数为偶数，可以继续执行操作</span>            base = base * base % <span class="hljs-number">1000</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最终优化"><a href="#最终优化" class="headerlink" title="最终优化"></a>最终优化</h2><p>&emsp;&emsp;我们知到判断奇偶性除了使用 $\%$看其余数是否为$0$ $or$ $1$来进行判断之外，我们还可以通过位运算来进行计算，例如：power&amp;1。因为如果power为偶数，则其二进制表示的最后一位一定是0；如果power是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是power二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1=1；而6是偶数，则6&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p>&emsp;&emsp;同样对于除以$2$的运算我们也可以使用位运算来进行优化power /= 2可以使用右移power = power &gt;&gt; 1实现，右移动1就是除以2，如果右移2就是除以4，同理左移就是乘，左移1就是乘以2左移2就是乘以4；</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>求$m^k$ $\% $ $p$ 时间复杂度为$O(logk)$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p, t = m;        <span class="hljs-keyword">while</span> (k) &#123;                <span class="hljs-comment">//如果为奇数</span>        <span class="hljs-keyword">if</span> (k &amp;  <span class="hljs-number">1</span>) res = res * t % p;                t = t * t % p;        k &gt;&gt; <span class="hljs-number">1</span>;    &#125;        <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;快快快~&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>双向BFS</title>
    <link href="http://www.wulnut.top/2020/03/28/%E5%8F%8C%E5%90%91BFS/"/>
    <id>http://www.wulnut.top/2020/03/28/%E5%8F%8C%E5%90%91BFS/</id>
    <published>2020-03-28T13:31:36.632Z</published>
    <updated>2020-03-28T14:48:53.630Z</updated>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="搜索-双向BFS"><a href="#搜索-双向BFS" class="headerlink" title="搜索-双向BFS"></a>搜索-双向BFS</h1><ul><li>双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率。</li><li>同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案</li><li><font color="red">但是双向BFS在针对于小型数据范围时就会退化成BFS,如果双向BFS的两个端点完全没有连接，时间复杂度也会和BFS相同</font></li></ul><p><img src="/img/BFS.png" alt=" "></p><p>当两种颜色相遇的时候，说明两个方向的搜索树遇到一起，这个时候就搜到了答案。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>简单理入门：</p><p><strong>问题描述</strong>：<br>一个迷宫由$R$行$C$列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。<br>给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。</p><p><strong>输入</strong></p><p>第一行是两个整数，$Ｒ$和$Ｃ$，代表迷宫的长和宽。$（1≤R，C≤40)$<br>接下来是$Ｒ$行，每行$Ｃ$个字符，代表整个迷宫。<br>空地格子用‘.’表示，有障碍物的格子用‘#’表示。<br>迷宫左上角和右下角都是‘.’。</p><p><strong>输出</strong></p><p>输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点</p><p><strong>输入样例</strong></p><pre><code class="hljs clean"><span class="hljs-number">5</span> <span class="hljs-number">5</span>..####....#.#.##.#.##.#..</code></pre><p><strong>输出样例</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">9</span></code></pre><p><strong>普通BFS：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">100000</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[MAX][MAX];<span class="hljs-keyword">int</span> d[MAX][MAX];<span class="hljs-comment">//表示起点到各个位置的最短距离 </span><span class="hljs-keyword">int</span> sx, sy, gx, gy;<span class="hljs-comment">//表示起点和终点坐标 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,- <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; d[x][y]==INF &amp;&amp; <span class="hljs-built_in">map</span>[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">queue</span>&lt;P&gt; que;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)d[i][j] = INF;que.push(P(sx, sy));d[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!que.empty()) &#123;P p = que.front(); que.pop();<span class="hljs-keyword">if</span>(p.first == gx &amp;&amp; p.second == gy)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = p.first + dx[i];<span class="hljs-keyword">int</span> ny = p.second + dy[i];<span class="hljs-keyword">if</span>(Check(nx, ny)) &#123;que.push(P(nx,ny));d[nx][ny] = d[p.first][p.second] + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> d[gx][gy]; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];sx = <span class="hljs-number">0</span>, sy = <span class="hljs-number">0</span>;gx = n<span class="hljs-number">-1</span>, gy = m<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> res = bfs(); <span class="hljs-built_in">cout</span> &lt;&lt; res+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>双向BFS</strong>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//记录下当前状态, 从前往后搜索值为1，从后往前搜索值为2，如果某状态下，当前节点和准备扩展节点的状态相加为3，说明相遇</span><span class="hljs-built_in">queue</span> &lt;P&gt; q1, q2; <span class="hljs-keyword">int</span> r, c, ans, dis[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>], vst[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">char</span> m[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dbfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">bool</span> flag;q1.push(P(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), dis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, vst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//从前搜</span>q2.push(P(r, c)), dis[r][c] = <span class="hljs-number">1</span>, vst[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">//从后搜</span><span class="hljs-keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;<span class="hljs-keyword">int</span> x0, y0;<span class="hljs-keyword">if</span>(q1.size() &gt; q2.size()) &#123; <span class="hljs-comment">//每次扩展搜索树小的队列 flag=1扩展前搜的队列，flag=0扩展后搜的队列</span>x0 = q2.front().first, y0 = q2.front().second;q2.pop();flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;x0 = q1.front().first, y0 = q1.front().second;q1.pop();flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = x0 + dx[i];<span class="hljs-keyword">int</span> ny = y0 + dy[i];<span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; m[nx][ny] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(!dis[nx][ny]) &#123;dis[nx][ny] = dis[x0][y0] + <span class="hljs-number">1</span>;vst[nx][ny] = vst[x0][y0];<span class="hljs-keyword">if</span>(flag) q1.push(P(nx, ny));<span class="hljs-keyword">else</span> q2.push(P(nx, ny));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(vst[x0][y0] + vst[nx][ny]== <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//相遇</span>ans = dis[nx][ny] + dis[x0][y0];<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; r &gt;&gt; c;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++)<span class="hljs-built_in">cin</span> &gt;&gt; m[i][j];dbfs(); <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a herf = "https://leetcode-cn.com/problems/word-ladder/">力扣第127题：单词接龙</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code class="hljs clean">输入:beginWord = <span class="hljs-string">&quot;hit&quot;</span>,endWord = <span class="hljs-string">&quot;cog&quot;</span>,wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]输出: <span class="hljs-number">5</span>解释: 一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>,     返回它的长度 <span class="hljs-number">5</span>。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>beginWord = <span class="hljs-string">&quot;hit&quot;</span>endWord = <span class="hljs-string">&quot;cog&quot;</span>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<span class="hljs-section">输出: 0</span><span class="hljs-section">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span></code></pre><p>&emsp;&emsp;如果只是单纯的使用BFS经行操作那么时间复杂度将会为$O(M\times N)$ $M$表示单词的长度, $N$表示单词列表中单词的个数.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;      <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s; <span class="hljs-comment">// 可以块数查找</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : wordList) s.insert(i);      <span class="hljs-comment">// first 表示字符</span>      <span class="hljs-comment">// second 表示走过的路长</span>      <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;      q.push(<span class="hljs-built_in">make_pair</span>(beginWord, <span class="hljs-number">1</span>));      <span class="hljs-built_in">string</span> temp;      <span class="hljs-keyword">int</span> step; <span class="hljs-comment">// 表示用暂时存贮走过的步子</span>      <span class="hljs-keyword">while</span> (!q.empty()) &#123;          <span class="hljs-keyword">if</span> (q.front().first == endWord) <span class="hljs-keyword">return</span> q.front().second;          temp = q.front().first;          step = q.front().second;          q.pop();          <span class="hljs-keyword">char</span> ch;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= temp.size(); ++ i) &#123;              ch = temp[i];              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                  <span class="hljs-keyword">if</span> (ch == a) <span class="hljs-keyword">continue</span>;                  temp[i] = a;                  <span class="hljs-keyword">if</span> (s.find(temp) != s.end()) &#123; <span class="hljs-comment">// 这里表示如果找到了可以转换的两个单词，就把该数存放入队列里</span>                      q.push(<span class="hljs-built_in">make_pair</span>(temp, step + <span class="hljs-number">1</span>));                      s.erase(temp); <span class="hljs-comment">// 删掉结点的意思防止找到重复</span>                  &#125;                  temp[i] = ch;              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>如果使用双向BFS：</p><ul><li>$O(M \times N)$，其中 MM 是单词的长度 $N$是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 $M \times N$ 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</li></ul><p>算法：</p><ul><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p></li></ul><blockquote><p> 双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote><ul><li>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dbfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;       <span class="hljs-function"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">dict</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;       <span class="hljs-keyword">if</span> (dict.find(beginWord) != dict.end()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//初始化</span>       <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; beginSet, endSet, tmp, visited;       beginSet.insert(beginWord);       endSet.insert(endWord);       <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (!beginSet.empty() &amp;&amp; !endSet.empty()) &#123;           <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;               tmp = beginSet;               beginSet = endSet;               endSet = tmp;           &#125;           tmp.clear();           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> word : beginSet) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.size(); ++ i) &#123;                   <span class="hljs-keyword">char</span> old = word[i];                   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                       <span class="hljs-keyword">if</span> (old == a) <span class="hljs-keyword">continue</span>;                       word[i] = a;                       <span class="hljs-keyword">if</span> (endSet.find(word) != endSet.end()) &#123;                           <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;                       &#125;                       <span class="hljs-keyword">if</span> (visited.find(word) == visited.end() &amp;&amp; dict.find(word) != dict.end()) &#123;                           tmp.insert(word);                           visited.insert(word);                       &#125;                   &#125;                   word[i] = old;               &#125;           &#125;           beginSet = tmp;           ++ len;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于set与unordered-set"><a href="#关于set与unordered-set" class="headerlink" title="关于set与unordered_set"></a>关于set与unordered_set</h3><ul><li><strong>set函数(集合)</strong>：这里的set表示集合的意思，和数学中的集合是一个意思，集合中不允许有重复出现的元素，由于set函数底层通常以红黑树实现，红黑树具有自动排序的功能，因此set内部所有的数据，在任何时候，都是有序的。</li><li><strong>unordered_set函数</strong>： 是含有 Key 类型唯一对象集合的关联容器，依赖于哈希表。搜索、插入和移除拥有平均常数时间复杂度。在内部，元素并不以任何特别顺序排序，而是组织进桶中，元素被放进哪个桶完全依赖其值的哈希。允许对单独元素的快速访问，因为一旦哈希，就能够准确指代元素被放入的桶。不可修改容器元素（即使通过非 const 迭代器），因为修改可能更改元素的哈希，并破坏容器。代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</li></ul><h4 id="下面几种情况一般使用set："><a href="#下面几种情况一般使用set：" class="headerlink" title="下面几种情况一般使用set："></a>下面几种情况一般使用set：</h4><ol><li>需要有序的数据(元素不同)。</li><li>需要按顺序打印/访问数据。</li><li>需要元素的前任或后继。</li></ol><h4 id="下面几种情况一般使用unordered-set："><a href="#下面几种情况一般使用unordered-set：" class="headerlink" title="下面几种情况一般使用unordered_set："></a>下面几种情况一般使用unordered_set：</h4><ol><li>需要保留一组不同的元素，不需要排序。</li><li>需要访问单个元素，不要遍历。</li></ol><h3 id="关于map与unordered-map"><a href="#关于map与unordered-map" class="headerlink" title="关于map与unordered_map"></a>关于map与unordered_map</h3><ul><li><strong>map函数（映射）</strong>： map函数在缺省下，按照递增的排序顺序，并且内部采用了自平衡的BST（二叉搜索树）的数据结构，实现了数据排序。所以在搜索的时候时间复杂度为$Olog(n)$</li><li><strong>unordered_map函数</strong>：unordered_map函数不进行排序二内部采用了哈希表的数据结构在搜索的时候时间复杂度为$O(1)$，但是在特殊情况下时间复杂度就会退化为$O(n)$</li></ul><p>因此如果你想要一个具有排序后的数据的话，通常可以选择map这种类型。或者想要打印具有一定顺序的元素。如果你只想记录数据而不是想要将数据进行排序的话，那么就可以选择unordered_map这种数据结构。</p><p><a herf="https://blog.csdn.net/weixin_43501684/article/details/90147421">.</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;值得思考的实现&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
    <category term="数据结构" scheme="http://www.wulnut.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>cellular automata</title>
    <link href="http://www.wulnut.top/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/"/>
    <id>http://www.wulnut.top/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-27T12:14:28.375Z</published>
    <updated>2020-03-27T13:02:22.497Z</updated>
    
    <content type="html"><![CDATA[<p>STL函数，内部用二分查找实现</p><a id="more"></a><h1 id="有关lower-bound-函数的使用"><a href="#有关lower-bound-函数的使用" class="headerlink" title="有关lower_bound()函数的使用"></a>有关lower_bound()函数的使用</h1><p>lower_bound()函数需要加载头文件#include<algorithm>,其基本用途是查找有序区间中第一个大于或等于某给定值的元素的位置，其中排序规则可以通过二元关系来表示。</p><pre><code class="hljs C++">函数原型：<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;</span><span class="hljs-class">   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(</span><span class="hljs-class">      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">First</span>, </span><span class="hljs-class">      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">Last</span>,</span><span class="hljs-class">      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; _<span class="hljs-title">Val</span></span><span class="hljs-class">   );</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;</span><span class="hljs-class">   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(</span><span class="hljs-class">      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">First</span>, </span><span class="hljs-class">      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">Last</span>,</span><span class="hljs-class">      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; _<span class="hljs-title">Val</span>,</span><span class="hljs-class">      <span class="hljs-title">BinaryPredicate</span> _<span class="hljs-title">Comp</span></span><span class="hljs-class">   );</span>传入参数说明：   _First 要查找区间的起始位置_Last 要查找区间的结束位置_Val 给定用来查找的值_Comp 自定义的表示小于关系的函数对象，根据某个元素是否满足小于关系而返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span></code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>例如，有如下序列：<br>$a[i]={12,15,17,19,20,22,23,26,29,35,40,51}$;<br>用值21调用lower_bound(),返回一个指向22的iterator。用值22调用lower_bound(),也返回一个指向22的iterator。第一个版本使用底层 &lt; (小于)操作符，第二个版本根据comp进行排序和比较。</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>调用lower_bound之前必须确定序列为有序序列，否则调用出错。第一个版本排序根据底层的 &lt;(小于)操作符，第二个版本根据comp进行排序。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/sdtc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);   <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p>上面的例子是针对容器的，注意返回的是距离元素3最近的指针it，输出的是*it结果为元素4，假如我想得到位置而非具体的元素应该怎么办呢？这里有一个指针偏移的技巧，只需要减去起始位置的指针即可，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)          v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的  </span>    <span class="hljs-comment">//vector&lt;int&gt;::iterator it = lower_bound(v.begin(), v.end(), 3);  </span>    <span class="hljs-keyword">int</span> pos = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>)-v.begin();      <span class="hljs-built_in">cout</span> &lt;&lt; pos&lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>结果和容器的时候是一样的。</p><p>对于4个参数的情形，最后一个参数的自己定义的表示大小关系函数的对象，常用的逆序可以加载头文件#include<functional>,里边有一个greater<int>()函数即可对逆序求最近位置。假如说像上边一样元素为2 4 6 8，逆序则是8 6 4 2，那么求距离3最近表示的是与3最近的小于等于3的元素，输出结果则是元素2了，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &gt;<span class="hljs-number">0</span>; i--)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());     <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们知道map容器是根据键值进行排序的</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><p>这两个函数常用于multimap容器，用来获取某个键对应的所有元素</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; m;    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">2</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">3</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">2</span>));    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = m.begin();    <span class="hljs-keyword">while</span>(it != m.end())    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;        it++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it1 = m.lower_bound(<span class="hljs-string">&quot;China&quot;</span>),it2 = m.upper_bound(<span class="hljs-string">&quot;China&quot;</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;it1-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it1-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;it2-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it2-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;STL函数，内部用二分查找实现&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
    <category term="泛型编程" scheme="http://www.wulnut.top/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>杂题选讲</title>
    <link href="http://www.wulnut.top/2020/03/26/AC%E9%80%89%E8%AE%B2/"/>
    <id>http://www.wulnut.top/2020/03/26/AC%E9%80%89%E8%AE%B2/</id>
    <published>2020-03-26T07:29:20.986Z</published>
    <updated>2020-03-27T13:08:42.969Z</updated>
    
    <content type="html"><![CDATA[<p>最近AC题目的分析</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><blockquote><p>示例1：</p></blockquote><pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><blockquote><p>示例2:</p></blockquote><pre><code>输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;<strong>这种在数组空间上进行各种操作的题目，一般可以利用双指针进行解决。</strong><br>&emsp;&emsp;这个题目比较困难的地方再于各种边界的判定于操作，以及如何快速高效的进行合并。<br>&emsp;&emsp;双指针再解决这类问题的时候总有着很清晰的思路，首先我们要减少复杂情况，所以先排序形成一个有序的状态。我们先设双指针<br>第一个$save$用于保留和扩展另一个用$scan$来进行扫描</p><p>&emsp;&emsp;因为我们排序之后这个序列肯定是有序的所以我们就可以不用考虑左边界所有就剩下三种情况了</p><ul><li>eg:  $\overbrace{[1,3],[4,5]}^{save}$这种情况最为简单，两个区间不相交，因此我们就可以把$save$指针所指向的数据压入result数组种，然后再将$save$移动到<br>scan指针所指的地方：$[1,3],\overbrace{[4,5]}^{save}, \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save}, \overbrace{[2,3]}^{scan}$,这种是一种不被包含的情况，因此我们呢不需要操作$save$指针，$scan$ 指针继续往后移动即可：$\overbrace{[1,4]}^{save}, [2,3], \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save},\overbrace{[3,5]}^{scan}$,这种情况是相对比较复杂的情况，即我们需要对于$save$指针指向的数组进行扩展，所以我们需要修改数组为$\overbrace{[1,4]}^{save} \rightarrow \overbrace{[1,5]}^{save}$, 然后将$scan$指向下一个,也就是:  $\overbrace{[1,5]}^{save}, [3,5], \overbrace{[X,X]}^{scan}$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;        <span class="hljs-comment">// 对于特殊情况的特判</span>        <span class="hljs-keyword">if</span> (intervals.size() == <span class="hljs-number">0</span> || intervals.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;        <span class="hljs-comment">// 双指针</span>        <span class="hljs-keyword">int</span> save = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于保存的数组</span>        <span class="hljs-keyword">int</span> scan = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用户扫描的数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;        sort (intervals.begin(), intervals.end());        <span class="hljs-keyword">while</span> (scan &lt; intervals.size()) &#123;            <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">0</span>] &gt; intervals[save][<span class="hljs-number">1</span>]) &#123;                result.emplace_back(intervals[save]);                save = scan;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">1</span>] &lt;= intervals[save][<span class="hljs-number">1</span>]) &#123;                ++ scan;            &#125; <span class="hljs-keyword">else</span> &#123;                intervals[save][<span class="hljs-number">1</span>] = intervals[scan][<span class="hljs-number">1</span>]; <span class="hljs-comment">//将数组扩充</span>                ++ scan;            &#125;        &#125;        result.emplace_back(intervals[save]); <span class="hljs-comment">// 当scan扫描到最后一个区间之后会跳出循环也就是说还有一个区间没有压入向量</span>        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;三种情况种第一种情况是一般情况，后面两种是特殊情况，我们只需要对特殊情况经行处理称一般情况，然后让一般情况操就行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近AC题目的分析&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Largest Rectangle in Histogram</title>
    <link href="http://www.wulnut.top/2020/03/21/MaximalRectangle/"/>
    <id>http://www.wulnut.top/2020/03/21/MaximalRectangle/</id>
    <published>2020-03-21T07:42:00.000Z</published>
    <updated>2020-03-23T08:30:06.106Z</updated>
    
    <content type="html"><![CDATA[<p>Largest Rectangle in Histogram解析</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/img/rectangle2.png" alt=" "></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="/img/rectangle1.png" alt=" "></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>示例:</p><p>输入: [2,1,5,6,2,3]</p><p>输出: 10</p></blockquote><h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p><img src="/img/rectangle.png" alt=" "></p><p>height的内容是 [5,6,7,8,3]，特点是除了最后一个，前面全部保持递增，且最后一个立柱的高度小于前面所有立柱高度。对于<br>这种特点的柱状图，如果使用上面所说的“挨个使用每一个柱状图的高度作为矩形的高度，求面积”的方法，还需要用嵌套循环吗？</p><p>&emsp;&emsp;我们知道除了最后一个，从第一个到倒数第二个立柱的高度都在升高，那么如果挨个使用每一个柱的高度作为矩形的<br>高度，那么依次能得到的矩形的宽度就可以直接算出来：使用5作为高度可以使用前四个立柱组成 $4\times5$的矩形，高度6可以<br>组成$3\times6$的矩形… 因此只需要遍历一次，选出最大面积即可。对于这种类型的柱状图，最大矩形面积的时间复杂度是O(n)。我们将这种特点的柱状图称为“波峰图”。</p><p>从而算法设计步骤：</p><p>(1) 在height尾部添加一个0，也就是一个高度为0的立柱。作用是在最后也能凑成上面提的那种“波峰图”。</p><p>(2) 定义了一个stack，然后遍历时如果height[i] 大于stack.top()，进栈。反之，出栈直到栈顶元素小于height[i]。</p><p>由于出栈的这些元素高度都是递增的，我们可以求出这些立柱中所围成的最大矩形。更妙的是，由于这些被弹出的立柱处于“波峰”之上(比如弹出i 到 i+k，那么所有这些立柱的高度都高于 i-1和 i+k+1的高度)，因此，如果我们使用之前所提的“左右延伸找立<br>柱”的思路解，以这些立柱的高度作为整个矩形的高度时，左右延伸出的矩形所包含的立柱不会超出这段“波峰”，因为波峰外的立柱<br>高度都比他们低。“波峰图”其实就是求解最大矩形的“孤岛”，它不会干扰到外部。</p><p>(3) 由于比height[i]大的元素都出完了，height[i]又比栈顶元素大了，因此再次进栈。如此往复，直到遍历到最后那个高度为0的柱，触发最后的弹出以及最后一次面积的计算，此后stack为空。</p><p>(4) 返回面积最大值。</p><p>&emsp;&emsp;栈中存的不是高度，而是height的索引，这样做的好处是不会影响宽度的计算，索引值相减 = 宽度。</p><h2 id="但是对于面积的计算，还需要再多少几句"><a href="#但是对于面积的计算，还需要再多少几句" class="headerlink" title="但是对于面积的计算，还需要再多少几句"></a>但是对于面积的计算，还需要再多少几句</h2><p><img src="/img/rectangle3.png" alt=" "></p><p>矩形的面积=高*宽。<br>我们的发现，在这个分支情况下，我们已经知道高为2了，那么宽度如何求呢？<br>通过观察，我们发现矩形的左边沿是左边第一个高比2小的柱子，右边沿是右边第一个高比2小的柱子（将高为3的柱子的右面看作还<br>有一个高为0的柱子）如此它的宽度是$6 -（1+1）=4$</p><h2 id="如何寻找柱子的左右边"><a href="#如何寻找柱子的左右边" class="headerlink" title="如何寻找柱子的左右边"></a>如何寻找柱子的左右边</h2><p>我们已经说了，左边沿是左边第一小与本柱子高的柱子的右边，右边沿也是同理。<br>这正好可以用单调栈。<br>当第i个柱子进栈时，如果栈顶柱子（此处记作柱子A）的高度低于或等于第i个柱子，则第i个柱子进栈；<br>如果高于第i个柱子，则出栈，并计算以柱子A为高的矩形最大面积。</p><ul><li>高度：就是柱子A的高度</li><li>右边沿：正好是i（由于单调栈的性质，第i个柱子就是右边第一个矮于A的柱子）</li><li>左边沿：单调栈中紧邻A的柱子。（如果A已经出栈，那么左边沿就是A出栈后的栈顶）而且是该柱子的右边，所以要+1.</li></ul><p>因此，完全覆盖第index个柱子的最大矩形的面积如下（stk是单调栈）</p><pre><code>maxArea = heights[index] * (i - (stk.top() +1))</code></pre><p>还有一种情况。当A出栈后，单调栈为空时，那就是说明，A的左边没有比它矮的。左边沿就可以到0.</p><pre><code>maxArea = heights[index] * (stk.empty() ? i : (i - stk.top() -1)))</code></pre><p>可能你还有点不明白就是，那实际代码是怎么计算的？其实自习想一下就明白了，因为是取得top元素进行计算所以计算是从右边逐<br>渐往左边延伸。所以当整个栈排空的时候也就计算了距离右边最远的边界。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>栈实现：</strong></p><pre><code>int largeRectangleArea(vector&lt;int&gt;&amp; h) &#123;    stack&lt;int&gt; s;    h.push_back(0);    int sum = 0;    for (int i = 0; i &lt; h.size(); ++ i) &#123;        if (s.empty() || h[i] &gt; h[s.top()]) s.push(i);        else &#123;            int tmp = s.top();            s.pop();            sum = max(sum, h[tmp] * (s.empty() ? i : i - s.top() - 1));            i --;        &#125;    &#125;    return sum;&#125;</code></pre><p><strong>分治解法：</strong></p><pre><code>    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        if(heights.empty()) return 0;        return maxArea(heights,0,(int)heights.size()-1);    &#125;    int maxArea(vector&lt;int&gt;&amp; heights,int start, int end)&#123;        if(start &gt; end)            return 0;        int minIndex=start;        bool sorted = true;        for(int i=start+1;i&lt;=end;++i)&#123;            if(heights[i]&lt;heights[i-1])                sorted=false;            if(heights[i] &lt; heights[minIndex])&#123;                minIndex=i;            &#125;         &#125;        if(sorted)&#123;//如果有序则不需要再作进一步的分治            int mx=0;            for(int i=start;i&lt;=end;++i)            mx = max(mx,(end-i+1)*heights[i]);            return mx;        &#125;        return max( (end-start+1)*heights[minIndex],                max( maxArea(heights,start, minIndex-1),maxArea(heights,minIndex+1, end) ) );//分治    &#125;</code></pre><h1 id="算01-矩阵中包含最多1-的矩形"><a href="#算01-矩阵中包含最多1-的矩形" class="headerlink" title="算01 矩阵中包含最多1 的矩形"></a>算01 矩阵中包含最多1 的矩形</h1><p>接下来还有道Maximal Rectangle 的题，这道题的实用价值很大：算01 矩阵中包含最多1 的矩形。</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>有了上一题的基础，这道题就可等效为上一题，对于矩阵每一行，我们将其看作直方图，立柱的高度就是行中元素往上数包含的连续1的个数。</p><p>因此每一行都可以利用上一题方法计算最大矩形，最后求出各行结果的最大值就好了。时间复杂度 O(n2)</p><pre><code>    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;                if(matrix.size() == 0 || matrix[0].size() == 0) return 0;        int H = matrix.size(), W = matrix[0].size();        int height[W+1];        int i, j , MAX = 0, leftarea = 0, rightarea = 0;        stack&lt;int&gt; st;        for(i = 0; i &lt;= W; height[i] = 0, ++i);        for(i = 0; i &lt; H; ++i)&#123;            while(!st.empty()) st.pop();            for(j = 0; j &lt; W; ++j)&#123;                if(matrix[i][j] == &#39;1&#39;) height[j]++;                else height[j] = 0;            &#125;            for(int j = 0; j &lt;= W; ++j)&#123;                while(!st.empty() &amp;&amp; height[st.top()] &gt; height[j])&#123;                    int tmp = st.top();                    st.pop();                    leftarea = (st.empty() ? tmp + 1 : tmp - st.top()) * height[tmp];                    rightarea = (j - tmp - 1) * height[tmp];                    if((leftarea + rightarea) &gt; MAX) MAX = (leftarea + rightarea);                &#125;                st.push(j);            &#125;        &#125;        return MAX;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Largest Rectangle in Histogram解析&lt;/p&gt;</summary>
    
    
    
    <category term="训练题" scheme="http://www.wulnut.top/categories/%E8%AE%AD%E7%BB%83%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode小技巧</title>
    <link href="http://www.wulnut.top/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.wulnut.top/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-03-19T08:36:30.297Z</published>
    <updated>2020-03-22T12:19:11.959Z</updated>
    
    <content type="html"><![CDATA[<p>vscode 快捷键</p><a id="more"></a><h1 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h1><h1 id="如果懒"><a href="#如果懒" class="headerlink" title="如果懒"></a>如果懒</h1><p>不想看我bb就直接这样做就直接⬇；</p><p>ctrl k + ctrl s = 打开快捷键一览表。</p><p>在这里面、你可以查看、搜索、修改快捷键。</p><h2 id="列出当前可执行的动作"><a href="#列出当前可执行的动作" class="headerlink" title="列出当前可执行的动作"></a>列出当前可执行的动作</h2><p>显示 Errors或 Warnings，也可以 Ctrl+Shift+M:跳转到行数，也可以 Ctrl+G 直接进入</p><p>跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入</p><p>根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入” : “进入</p><p>根据名字查找 symbol，也可以 Ctrl+T</p><p>代码行向左或向右缩进:   Ctrl+[ 、 Ctrl+]</p><p>复制或剪切当前行/当前选中内容:   Ctrl+C 、 Ctrl+V</p><p>代码格式化:   Shift+Alt+F</p><p>向上或向下移动一行:   Alt+Up 或 Alt+Down</p><p>向上或向下复制一行:   Shift+Alt+Up 或 Shift+Alt+Down</p><p>在当前行下方插入一行:   Ctrl+Enter</p><p>在当前行上方插入一行:   Ctrl+Shift+Enter</p><p>Ctrl+Shift+P,F1 展示全局命令面板</p><p>Ctrl+P 快速打开最近打开的文件</p><p>Ctrl+Shift+N 打开新的编辑器窗口</p><p>Ctrl+Shift+W 关闭编辑器</p><p>Ctrl + X 剪切</p><p>Ctrl + C 复制</p><p>Alt + up/down 移动行上下</p><p>Shift + Alt up/down 在当前行上下复制当前行</p><p>Ctrl + Shift + K 删除行</p><p>Ctrl + Enter 在当前行下插入新的一行</p><p>Ctrl + Shift + Enter 在当前行上插入新的一行</p><p>Ctrl + Shift + | 匹配花括号的闭合处，跳转</p><p>Ctrl + ] 或 [ 行缩进</p><p>Home 光标跳转到行头</p><p>End 光标跳转到行尾</p><p>Ctrl + Home 跳转到页头</p><p>Ctrl + End 跳转到页尾</p><p>Ctrl + up/down 行视图上下偏移</p><p>Alt + PgUp/PgDown 屏视图上下偏移</p><p>Ctrl + Shift + [ 折叠区域代码</p><p>Ctrl + Shift + ] 展开区域代码</p><p>Ctrl + / 添加关闭行注释</p><p>Shift + Alt +A 块区域注释</p><p>Alt + Z 添加关闭词汇包含</p><h2 id="导航快捷键"><a href="#导航快捷键" class="headerlink" title="导航快捷键"></a>导航快捷键</h2><p>Ctrl + T 列出所有符号</p><p>Ctrl + G 跳转行</p><p>Ctrl + P 跳转文件</p><p>Ctrl + Shift + O 跳转到符号处</p><p>Ctrl + Shift + M 或 Ctrl + J 打开问题展示面板</p><p>F8 跳转到下一个错误或者警告</p><p>Shift + F8 跳转到上一个错误或者警告</p><p>Ctrl + Shift + Tab 切换到最近打开的文件</p><p>Alt + left / right 向后、向前</p><p>Ctrl + M 进入用Tab来移动焦点</p><p>Ctrl + F 查询</p><p>Ctrl + H 替换</p><p>F3 / Shift + F3 查询下一个/上一个</p><p>Alt + Enter 选中所有出现在查询中的</p><p>Ctrl + D 匹配当前选中的词汇或者行，再次选中-可操作</p><h2 id="多行光标快捷键"><a href="#多行光标快捷键" class="headerlink" title="多行光标快捷键"></a>多行光标快捷键</h2><p>Alt + Click 插入光标-支持多个</p><p>Ctrl + Alt + up/down 上下插入光标-支持多个</p><p>Ctrl + U 撤销最后一次光标操作</p><p>Shift + Alt + I 插入光标到选中范围内所有行结束符</p><p>Ctrl + I 选中当前行</p><p>Ctrl + Shift + L 选择所有出现在当前选中的行-操作</p><p>Ctrl + F2 选择所有出现在当前选中的词汇-操作</p><p>Shift + Alt + right 从光标处扩展选中全行</p><p>Shift + Alt + left 收缩选择区域</p><p>Shift + Alt + (drag mouse) 鼠标拖动区域，同时在多个行结束符插入光标</p><p>Ctrl + Shift + Alt + (Arrow Key) 也是插入多行光标的<code>[方向键控制]</code></p><p>Ctrl + Shift + Alt + PgUp/PgDown 也是插入多行光标的<code>[整屏生效]</code></p><p>Esc Esc 连续按两次Esc键取消多行光标</p><p>Shift + Alt + F 格式化代码</p><p>F12 跳转到定义处</p><p>Alt + F12 代码片段显示定义</p><p>Ctrl + K F12 在其他窗口打开定义处</p><p>Ctrl + . 快速修复部分可以修复的语法错误</p><p>Shift + F12 显示所有引用</p><p>F2 重命名符号</p><p>Ctrl + Shift + . / , 替换下个值</p><h2 id="编辑器管理快捷键"><a href="#编辑器管理快捷键" class="headerlink" title="编辑器管理快捷键"></a>编辑器管理快捷键</h2><p>Ctrl + F4, Ctrl + W 关闭编辑器</p><p>Ctrl + |切割编辑窗口</p><p>Ctrl + 1/2/3 切换焦点在不同的切割窗口</p><p>Ctrl + Shift + PgUp/PgDown 切换标签页的位置</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;vscode 快捷键&lt;/p&gt;</summary>
    
    
    
    <category term="vscode" scheme="http://www.wulnut.top/categories/vscode/"/>
    
    
    <category term="vscode" scheme="http://www.wulnut.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="http://www.wulnut.top/2020/03/18/C++note/"/>
    <id>http://www.wulnut.top/2020/03/18/C++note/</id>
    <published>2020-03-18T04:29:07.301Z</published>
    <updated>2020-03-22T15:09:23.058Z</updated>
    
    <content type="html"><![CDATA[<p>记录C++中遇到的问题</p><a id="more"></a><h2 id="关于auto"><a href="#关于auto" class="headerlink" title="关于auto"></a>关于auto</h2><p>(1)auto</p><p>auto即 for(auto x:range)  这样会拷贝一份range元素，而不会改变range中元素；</p><p>但是！（重点)  使用for(auto x:vector<bool>)时得到一个proxy class,操作时会改变vector<bool>本身元素。应用：for(bool x:vector<bool>)</p><p>(2)auto&amp;</p><p>当需要修改range中元素，用for(auto&amp; x:range)</p><p>当vector<bool>返回临时对象，使用auto&amp;会编译错误，临时对象不能绑在non-const l-value reference （左值引用）需使用auto&amp;&amp;,初始化右值时也可捕获</p><p>(3)const auto&amp;   </p><p>当只想读取range中元素时，使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range   </p><p>(4)const auto</p><p>当需要拷贝元素，但不可修改拷贝出来的值时，使用 for(const auto x:range)，避免拷贝开销.</p><hr><p>当我们在遍历容器的时候</p><pre><code>for(auto i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>但我知道这不必要的——不必要,因为我只需要打印 vec ——复制的值</p><p>编辑 : vec的每个元素，所以我可以这样做</p><pre><code>for(auto &amp;i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>但是我想确保 vec的值从未被修改并遵守 const-correctness，所以我可以：</p><pre><code>for(const auto &amp;i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>我的问题是:如果我只需要看看一些容器的值,不会最后循环( const auto &amp;i ) 总是首选由于增加effieciency没有额外的副本(编辑 : vec的每个元素？</p><pre><code>T//I&#39;m copying thisT&amp;//I&#39;m modifying thisconst T&amp;//I&#39;m reading this</code></pre><p>这些是你的”默认值”。当 T 是基本类型( 内置) 时，你通常只需要恢复 const T ( 无引用)，因为副本比别名更便宜。</p><h1 id="对vector进行排序"><a href="#对vector进行排序" class="headerlink" title="对vector进行排序"></a>对vector进行排序</h1><p>源码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;vector&lt;int&gt; vec;//比较函数，这里的元素类型要与vector存储的类型一致bool compare(int a,int b)&#123;return a&lt;b; //升序排列&#125;std::sort(vec.begin(),vec.end(),compare);</code></pre><blockquote><p>注意：由于sort()函数如果不声明比较函数就是默认升序，从小到大。</p></blockquote><h2 id="利用标准库函数find-对vector进行查找"><a href="#利用标准库函数find-对vector进行查找" class="headerlink" title="利用标准库函数find()对vector进行查找"></a>利用标准库函数find()对vector进行查找</h2><pre><code>vector&lt;int&gt; vec;int a=10;vector&lt;int&gt;::iterator it=find(vec.begin(),vector.end(),a);</code></pre><h2 id="构造类型在vector中的排序与查找"><a href="#构造类型在vector中的排序与查找" class="headerlink" title="构造类型在vector中的排序与查找"></a>构造类型在vector中的排序与查找</h2><p>&emsp;&emsp;将构造类型，比如struct的对象存储在vector中，查找时，需要重载等于运算符（operator==），具体实现参考如下代码。</p><pre><code>struct Element &#123;public:    int a;    int b;    Element(int a,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;;    bool operator == (const Element&amp; ele)&#123;        return a == ele.a &amp;&amp; b == ele.b;    &#125;;&#125;;//自定义比较函数bool compare(const Element&amp; left,const Element&amp; right)&#123;    return left.a &lt; right.a; //升序排列&#125;//重载输出操作符&lt;&lt;，格式化输出Elementostream&amp; operator &lt;&lt; (ostream&amp; coutU,const Element&amp; ele)&#123;    coutU &lt;&lt; &quot;a:&quot; &lt;&lt; ele.a &lt;&lt; &quot;,b:&quot; &lt;&lt; ele.b;    return coutU;&#125;int main() &#123;    vector&lt;Element&gt; vecEle;    vecEle.push_back(Element(4,4));    vecEle.push_back(Element(1,1));    vecEle.push_back(Element(2,2));    vecEle.push_back(Element(3,3));    //sort    std::sort(vecEle.begin(),vecEle.end(),compare);    for(int i=0; i&lt;vecEle.size(); ++ i) &#123;        cout &lt;&lt; vecEle[i] &lt;&lt; endl;    &#125;    //查找Element(4,4)    vector&lt;Element&gt;::iterator it = find(vecEle.begin(),vecEle.end(),Element(4,4));    cout &lt;&lt; &quot;found &quot; &lt;&lt; *it &lt;&lt; endl;&#125;</code></pre><blockquote><p>程序输出：<br>a:1,b:1<br>a:2,b:2<br>a:3,b:3<br>a:4,b:4<br>found a:4,b:4</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录C++中遇到的问题&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="http://www.wulnut.top/categories/study/"/>
    
    
    <category term="C++" scheme="http://www.wulnut.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>滴滴~</title>
    <link href="http://www.wulnut.top/2020/03/15/20%E5%B2%81/"/>
    <id>http://www.wulnut.top/2020/03/15/20%E5%B2%81/</id>
    <published>2020-03-14T16:25:24.231Z</published>
    <updated>2020-07-02T14:43:48.896Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><center></p><p><font size="#e78e97"><br>迈入二十大关</font><br>&lt;/center&gt;<br>你往往只能看到正面，而背面你缺一无所知。<br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /></p><!---------------------------能看到这说明你更愿意去了解背后的故事。而这些的开始，往往可能也就是一种冲动-------------------------------------><p>$\ldots$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=&quot;#e78e97&quot;&gt;&lt;br&gt;迈入二十大关
&lt;/font&gt;&lt;br&gt;&amp;lt;/center&amp;gt;&lt;br&gt;你往往只能看到正面，而背面你缺一无所知。&lt;br&gt;&lt;br /&gt;&lt;br&gt;&lt;br /&gt;&lt;</summary>
      
    
    
    
    <category term="day" scheme="http://www.wulnut.top/categories/day/"/>
    
    
    <category term="day" scheme="http://www.wulnut.top/tags/day/"/>
    
  </entry>
  
  <entry>
    <title>忆第一次美赛</title>
    <link href="http://www.wulnut.top/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
    <id>http://www.wulnut.top/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/</id>
    <published>2020-03-10T11:49:19.809Z</published>
    <updated>2020-07-02T14:57:24.785Z</updated>
    
    <content type="html"><![CDATA[<p>这不仅仅只是一次比赛那么简单</p><a id="more"></a><p>&emsp;&emsp;会战的失败原因是拿破仑一世对敌情侦察不够，临战前分散兵力，初战不利便改变决心，指挥不果断。惠灵顿<br>在进行会战决策、选择阵地、组织防御和协调联军作战方面显示了统帅才能。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>&emsp;&emsp;到我开始写这篇回忆的时候已经，已经距离美赛结束9个小时左右了。当我点下发送的那一刻，我们这场耗时80个小时三天零8个小时的比赛就真的全部结束了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/mail.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">提交</div></center><p>&emsp;&emsp;在关掉电脑之后我狠狠的删自己一巴掌之后，倒上床了就睡了过去。</p><h1 id="前夜"><a href="#前夜" class="headerlink" title="前夜"></a>前夜</h1><p>&emsp;&emsp;由于今年疫情的特殊原因，这次本应该在线下的比赛。被迫转移到了线上，腾讯会议是我和两个好伙伴交流与<br>讨论的唯一途径。在阿凡群里面我们对我们的设备做好了最后的调试，也大概确定了我们所希望努力的方向。就只等3月7号上<br>午出题了，大家还开玩笑说自己已经买好咖啡做好通宵的准备。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/coffee.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">阿凡的饮料</div></center><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>&emsp;&emsp;当拿到题目的时候已经是翻译好的了，由于我们的队伍均是有CS专业同学组成的队伍，且我和阿凡都是第一次参加建模比赛。我们在比赛之前，也了解到每个题目的总体大概所需要的知识。对于C题来说相对我们来说相对友好一些。我也了解到，C题会用到数据挖掘、数据清洗、python。我觉得我在寒假期间稍微学习了一下python的基础知识，对于读懂python的基本语法应没有什么问题。但是看到题目的时候，复杂程度对于我来说几乎是没辙。怎么剔除文本中的乱码情况，怎么对给的数据进行清洗，什么是.tsv文件$\ldots$, 一系列问题我完全傻了。什么正则表达式，什么情感分析。我完全都不懂。</p><p>&emsp;&emsp;这原本是我觉得可以在前期帮助到我们队伍的东西，完全用了。负责建模的阿凡也就揽了过去，要我和阿豪去看后的题目。谁知道第一题我和阿豪就看的非常懵…问的很笼统。随后还是在知乎上有人解读才慢慢似懂非懂的大概知道第一题要我们干什么，上午我们也很快的解决的了第一题，下午便开始对后面的主要部分开始了思考，在赛前我说我会$\LaTeX$，可以负责写作。也在一个月的时间里系统的学习了，之前简单了解的知识。但是我对写作的理解太片面了。赛前准备的时候，看到网上的教程说，写作的同学不能不懂建模，不然写不出来，虽然不直接参与建模但是要对整个模型要明白。我觉得我明白了后一段话，而前段话我到现在才明白。第一天我们对题目的分析之后也就大概解决了第一题。<br>&emsp;&emsp;在第一天结束的时候,我对我这一天进行了总结，因为我感觉我很懵，感觉自己一直在神游，除了可以提一提建议，可以说没有做别的任何事。决定他们在建模的时候了解大概的思路，我就去找找文献，看一下所用到的方法。可以为后面的写作做好准备。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>&emsp;&emsp;因为第二题中a问用到了NLP文本情感分析，在了解学习之后需要需要用到python来进行机器学习。我想我学习过python看看能不能在网上找一下代码看看，能不能跑。但是我又再次错了，我装上了库。库不能运行，我也一直找不出问题。寻求开发者文档也没有结果。到最后我也跑成功，除了知道了大家用了什么方法，想干什么之外。我还是什么也不知道干什么。直到晚上我才明白，我应该开始写作。把要用到的图表先画上去，把$\LaTeX$用的图片环境都给配置好。为后面写作做节省时间。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>&emsp;&emsp;到第三天，也就到最后的冲刺阶段了，但是我们在之前的b题出现了一些新的问题，感觉在后面的拟合效果不好是不是我们的方法出现了问题，这也导致我们本就不自信的c题和d题，需要有所改动。当时我时我知道如果我们不加快进度可能时间会不太够。因为我们在第二天晚上就开始写了问题分析，稍微解决了一些写作上的问题，但是后面主题部分，模型的建立，模型的步骤、推广、在问题中的实际应用，也都没写，也就是我的失职。本应该同时经行的地方我确把这写东西寄托在别人身上。</p><h1 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h1><p>&emsp;&emsp;到了晚上8点，也就是说我们距离美赛结束还剩最后的16个小时。我们的主题部分，还又最为重要的摘要还没写。我从8点开始写摘要一直到10点才写完。我本人为自己写的很好。但是实际确实，完全没不了。完全不可能用在我们的论文中。这也就浪费了很多时间。在模型的建立部分我只是从阿凡那里获得，几乎是他所完成的。当时我们也比较急，当时他说你到低干了啥的时候确实十分内疚，我真的干了啥，我真的有在做什么…<br>&emsp;&emsp;之后我最不愿意看到的地方出现了，<code>我的</code> $\LaTeX$ <code>编译不了了</code>，这也是我从来没有遇到过的问题。我写了100次的$\LaTeX$也遇见过一些问题，但是今天在翻译复制上的之后出现的问题我也是第一次遇到，一直编译不过我是真的急了，当时看到时间已经凌晨了，如果再不解决我们就很有可能面临着无法提交的问题。我试用了各种方法，来解决。但是就是无法解决…然后我下载了TeXstduio,看看能不能有所改进，然后我才发现是“_”的问题，我也没有转义就一直无法编译…<br>&emsp;&emsp;但是这还没完，我在机翻复制之后表格环境还是出现了问题。因为实在不知道怎么解决，只能手画了…，然后还是阿凡，不断给我法写好的表格代码，才稍微加快的进度。眼看时间已经2点了，距离比赛还剩6个小时了。我还在翻译a题，我真的很慌，再加上不时出现的图片浮动位置变化的问题，对于复杂公式我也开始不能快速的书写出来，可以说完全写不了。还是只能在帮助下才能完成….</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我终于在7点左右把所有的问题都给完成了，我的两个好朋友也陪着我一起整整一夜没有睡觉。我也很感谢他们在最后也没有没指责我，因为我的原因，导致了整个队伍在最后如此狼狈的完成了这次的比赛。到了最后大家还在讨论是否能在最后把我们的论文做一下改进，做一下优化。直到最后在发送比赛邮件的时候，这似乎真的都成了历史，真的是一次非常难忘且独特的经历，看到大家那么努力的建模，却在最后应该我负起责任的时候出现了这么严重了的问题。这本来就是一个团队每个人每个环节都应该认真完成的比赛，要是有一环出现问题，那么到最后也是功亏一篑。而我就是那最后一环，原本想用$\LaTeX$来进行一次完美的排版，到了最后确实这样的结果。</p><h1 id="明白"><a href="#明白" class="headerlink" title="明白"></a>明白</h1><p>&emsp;&emsp; 原本我是不打算写这边回忆的，但是不记录一下却又十分而可惜，由于我的参与感太低，几乎在整个团队中没有做到一点贡献，到了我在应该。<br>做出贡献的时候我确掉了链子，掉链子似乎真的成为了我的专有名词，大家都说我靠不住。一开始我还不理解，直到现在我才<br>明在为什么，从赛前准备开始我的准备就不足，虽然知道自己的在哪方面存在问题存在不足。但是我还是存在不足的问题，感<br>觉自己已经准备好了，但是自己完全认识到事情真正是什么情况。总是逃避问题，不愿意去认识到错误。总觉得自己懂，觉得自己可以，但往往还是不明白。“哦，你又懂了”我一直告诉自己要谦逊，要虚心接受。但是我直到，现在我还没有想到问题的<br>本质是什么。但是通过这件事情，我才明白我为什么无法明白，是因为一直都逃避，不愿意接受别人本来就比自己强，自己本来就不明白，却非要不懂装懂。这才是我无法虚心接受的原因，如果对一些知识没了解过，就完全没有资格去说自己明白了，说别人说不对。<br>&emsp;&emsp;学长说我太浮躁，也是我一直的诟病。我也一直把阿凡作为我的现在榜样，希望能赶超他。如果我现在还是这种，对自己一直自我感觉良好的的状态，别说是望其项背了，可能就是只剩下望尘莫及了。直面逃避的问题，才是我应该做的。而不是说我要好好努力就行了。通过这次比赛我明白了很多，真正认识到了自己应该去努力的方向。寒假认识了GZTime,<br>我也应该明白了我后面发展方向。感觉就之前的经历都没有美赛这么锻炼人，虽然很难但是我认为我有必要再参加一次。好好的向我的两位好朋友好好道歉。在后面的时日里好好努力，去消除那本来就很大的差距，去弥补那缺失的学习能力.去成为一<br>为一个稳健且说到做到的人。</p><h2 id="后面是因为我而没用上的插图"><a href="#后面是因为我而没用上的插图" class="headerlink" title="后面是因为我而没用上的插图"></a>后面是因为我而没用上的插图</h2><p><img src="/img/WordArt.jpeg" alt=" "><br><img src="/img/WordArt1.jpeg" alt=" "><br><img src="/img/WordArt2.jpeg" alt=" "><br><img src="/img/WordArt3.jpeg" alt=" "><br><img src="/img/WordArt4.jpeg" alt=" "></p><font color="#7ea497">致谢：阿凡、阿豪</font><font color="#f4f4f4">(虽然我不喜欢这种阿什么什么的称呼）</font>]]></content>
    
    
    <summary type="html">&lt;p&gt;这不仅仅只是一次比赛那么简单&lt;/p&gt;</summary>
    
    
    
    <category term="mathematical-modeling" scheme="http://www.wulnut.top/categories/mathematical-modeling/"/>
    
    
    <category term="mathematical" scheme="http://www.wulnut.top/tags/mathematical/"/>
    
  </entry>
  
  <entry>
    <title>mcm写作基本流程</title>
    <link href="http://www.wulnut.top/2020/03/05/mcm%E5%86%99%E4%BD%9C/"/>
    <id>http://www.wulnut.top/2020/03/05/mcm%E5%86%99%E4%BD%9C/</id>
    <published>2020-03-05T12:45:09.580Z</published>
    <updated>2020-03-05T13:49:02.625Z</updated>
    
    <content type="html"><![CDATA[<p>美赛的基本写作流程</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过对优秀文章的阅读，美赛的文章有相对固定的写作套路。大部分都分为：</p><ul><li>摘要</li><li>问题重述<ul><li>问题背景</li><li>问题重述</li></ul></li><li>问题分析<ul><li>对问题一分析</li><li>对问题二分析</li><li>对问题三分析</li></ul></li><li>模型假设</li><li>符号说明</li><li>模型的建立与求解<ul><li>问题一</li><li>问题二</li><li>问题三</li></ul></li><li>模型的分析建议</li><li>模型的评估与优化</li><li>参考文献</li><li>附录</li></ul><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>摘要一般第一段写对问题总体环境的概述，第二段开始一般是回答第一个问题，第二段对第二个问题进行分析，第三段对三个问题分析。一般摘要的三段或四段都是与题目相对应。题目一般都是循序渐进，逐步解决问题。最后就是$\textbf{keywords}$ 这个就主要写所使用的模型。</p><h1 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h1><p>这个没什么好说得，就直接把问题重新再抄写一下就可以了，分为问题背景和问题重述</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>问题分析这部分就是对每个小问题，分别建模讨论使用得模型对所寻找的数据或题目所给的数据进行分析。然后再对得到的数据进行预测建立模型，</p><p>….</p><p>后面的就是独家内容了，嘿嘿嘿。晚点再更新….</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;美赛的基本写作流程&lt;/p&gt;</summary>
    
    
    
    <category term="LaTex" scheme="http://www.wulnut.top/categories/LaTex/"/>
    
    
    <category term="LaTex" scheme="http://www.wulnut.top/tags/LaTex/"/>
    
    <category term="mathematical" scheme="http://www.wulnut.top/tags/mathematical/"/>
    
  </entry>
  
</feed>
