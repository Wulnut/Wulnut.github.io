<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>健身的浅见</title>
    <link href="/2022/02/13/%E5%81%A5%E8%BA%AB%E6%B5%85%E8%B0%88/"/>
    <url>/2022/02/13/%E5%81%A5%E8%BA%AB%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>健身了快一个寒假，有了一些自己的理解简单记录一下。</p><a id="more"></a><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>&emsp;&emsp;对于健身来说，全部的动作总体可以分为三部分。推、拉、腿。三部分，因为这三部分是我们日常生活中最为常见的用力动作。</p><p>通过这三个方面也对应着三个基础动作，卧推、硬拉、深蹲。这三个动作不仅仅是锻炼单一肌群，而是身体一些部分的所有肌群。</p><p>这是我这种小白刚入门容易误入的一个误区，直接去练习一些针对性的动作从而达到一些心理上所为的正确目的。但是要是这样，</p><p>就是去了我来健身房的目的，要是按照这种错误的想法，其实通过囚徒的方法似乎更加高效和明显。</p><p>&emsp;&emsp;通过这三个基础动作，可以衍生出其他一些器械和哑铃动作。这也是为什么一上来就要先练习这三个动作，通过这些动作的不足</p><p>我们再对其他一些肌群进行补强和针对性练习。也是我的大体思路，以总体带动局部肌群。而不是单一刺激局部肌群。</p><h3 id="推"><a href="#推" class="headerlink" title="推"></a>推</h3><p>&emsp;&emsp;bench pass(杠铃卧推)，可以理解成胸前水平推举，主要刺激的是胸大肌、肱三头肌、三角肌。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/%E5%8D%A7%E6%8E%A8%E8%82%8C%E7%BE%A4.jpg" alt="卧推肌群"></p><p>也就是说通过卧推，可以总体提升自己的上肢力量。也就是说我们再练习完卧推后，可以进一步专项增强胸大肌、肱三头肌、三角肌。</p><p>从而达到全面刺激的目的。拉和腿也是一样</p><h3 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h3><p>&emsp;&emsp;Barbell deadlift(杠铃硬拉)，相当于我们从下向上抬起东西，主要刺激斜方肌、竖脊肌、背阔肌、核心肌群、臀大肌、腘绳肌、股四头肌。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/deadlift.png" alt="Barbell deadlift"></p><p>这个动作锻炼的部位很多，但是发力也相对难掌握。必须通过小重量理解发力点和发力细节不然对腰的损伤是十分明显的。</p><h3 id="腿"><a href="#腿" class="headerlink" title="腿"></a>腿</h3><p>&emsp;&emsp;Barbell squat(杠铃深蹲),蹲起是我们日常是生活种的常用动作，主要锻炼的是两侧肌肉以及臀部肌肉。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/squat.png" alt="Barbell squat"></p><p>深蹲是对腿部肌群总体锻炼的一个动作，但是这个动作对膝盖的压力会比较大，所以需要我们标准做好每次蹲起</p><h2 id="训练规划"><a href="#训练规划" class="headerlink" title="训练规划"></a>训练规划</h2><p>&emsp;&emsp;训练规划是我认为最为重要的一个环节，仅此与标准的动作。我认为如果没有个科学的训练计划，那么训练起来</p><p>出效果的周期就会很长，一些需要的练习到的肌肉锻炼不够充分等等。</p><p>&emsp;&emsp;目前来说我认为时间充裕的话，应该一周七天，需要六练一休息并且中间穿插两次有氧训练。这应该是我目前来说最为</p><p>满意的训练节奏，但是懂得都懂有氧实在是太难受了，想坚持下来确实有点不太容易。如果再细致一点我是这样规划的，周一到周三</p><p>分别锻炼推、拉、腿。周四休息一次，然后剩下的三天同理。因为在周三和周日连腿，所以有氧连起来会比较困难，一般有氧应该放在周二</p><p>和周六。</p><p>&emsp;&emsp;当然周一到周三期间，每天练习的动作其实我觉得也是有一些关系的，应该在一些地方相互避开。周一的练习卧推时主要时练</p><p>胸、肩、三头肌。那我们就可以再着重练习完卧推之后对剩下的肌群进行加强。周二练习硬拉后可以再加强背和腰，例如：引体向上。</p><p>周三练腿之后可以加强对腹部肌肉的训练，这样的基本三天下来，可以把身体上的各个肌肉锻炼到。从而往复训练，可以达到不错的效果。</p><p>健身其实就是简单的事情重复做，总体来说是比较枯燥的。如果不搭配其他动作混合训练，一次训练课来有点难坚持枯燥不说，肌肉耐受强度</p><p>达到最大后，效率就会下降。所以我们需要制定好训练计划这样才能更好的达到自己的训练效果。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健身</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾旁路由</title>
    <link href="/2022/02/11/%E6%97%81%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/02/11/%E6%97%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>浅谈如何设置旁路由器</p><a id="more"></a><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>由于市面上的主流路由器例如：小米、荣耀、华为、TP-Link、水星、华三等等路由器，厂家为了方便用户使用，</p><p>往往会是使用定制系统，让用户尽量简单且只管的设置路由器，从而帮助用户在家庭、寝室等环境内快速使用无线</p><p>路由功能。但是这也会给一些用于带来困扰，比如国内对家用路由器的功率大小有严格的限制，所以在一定条件下无</p><p>法充分发挥路由器的信号的强度。从而就慢慢了解到了openwrt这样的主流路由器系统，但是由于主流路由器的厂商</p><p>为了避免用户修改路由器本身系统就会通过各种方式来限制用户从新刷写路由器系统，所以国内也有一种独特的路由</p><p>方式：旁路由。旁路由准确来说是旁路网关，也就说在整个家庭网络环境中，我们通过统一更改设备网关来达到目的。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="主路由"><a href="#主路由" class="headerlink" title="主路由"></a>主路由</h3><p>对于一些路由器厂商例如华为、荣耀、TP-Link需要设置WAN网口我们用荣耀路由器为例</p><ol><li><p>首先去荣耀路由器关闭WAN/LAN自动识别： 在更多功能-系统设置<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/honor1.png" alt="设置WAN口"></p></li><li><p>然后关闭荣耀路由的DHCP功能：更多设置-网络设置-局域网-关闭DHCP<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/honor2.png" alt="关闭DHCP"></p></li><li><p>如果你家是电信的宽带，一般会分配ipv6地址给你，我想你都点开这篇博客了肯定是想用旁路由干点啥，我建议你关闭ipv6，因为这可能会对你的openwrt旁路由产生影响<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/honor3.png" alt="关闭ipv6"></p></li></ol><p>好到这里你的主路由已经设置好了然后我们再来设置旁路由</p><h3 id="旁路由"><a href="#旁路由" class="headerlink" title="旁路由"></a>旁路由</h3><p>首先你需要有个已经刷好openwrt固件的路由器，我用的是一个树莓派。</p><p>如果还没有刷入固件可以参照下表根据自己的需求来进行下载相关固件</p><div class="table-container"><table><thead><tr><th><strong>支持设备</strong></th><th><strong>支持平台</strong></th><th><strong>固件下载</strong></th></tr></thead><tbody><tr><td>树莓派 1B</td><td>bcm27xx/bcm2708</td><td><a href="https://openwrt.cc/releases/targets/bcm27xx/bcm2708/">🔗</a></td></tr><tr><td>树莓派 2B</td><td>bcm27xx/bcm2709</td><td><a href="https://openwrt.cc/releases/targets/bcm27xx/bcm2709/">🔗</a></td></tr><tr><td>树莓派 3B</td><td>bcm27xx/bcm2710</td><td><a href="https://openwrt.cc/releases/targets/bcm27xx/bcm2710/">🔗</a></td></tr><tr><td>树莓派 4B</td><td>bcm27xx/bcm2711</td><td><a href="https://openwrt.cc/releases/targets/bcm27xx/bcm2711/">🔗</a></td></tr><tr><td>ipq40xx 设备</td><td>ipq40xx/generic</td><td><a href="https://openwrt.cc/releases/targets/ipq40xx/generic/">🔗</a></td></tr><tr><td>rockchip 设备</td><td>rockchip/armv8</td><td><a href="https://openwrt.cc/releases/targets/rockchip/armv8/">🔗</a></td></tr><tr><td>x86_64 设备</td><td>x86/64</td><td><a href="https://openwrt.cc/releases/targets/x86/64/">🔗</a></td></tr></tbody></table></div><h4 id="固件选择"><a href="#固件选择" class="headerlink" title="固件选择"></a>固件选择</h4><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/openwrt.png" alt="openwrt固件"></p><p>我们会发现很多固件不知道选择哪个一个，我们只需要关注ext4和squashfs这两个版本就够了。ext4代表可以使用swap进行空间交换，</p><p>适合一些内存比较的设备，可以扩容一些存储空间给内存提升性能，但是没有重置系统的功能。squashfs代表可以进行系统重置也就是恢复出厂设置。</p><p>然后有个factory.img和sysupgrade。factory.img就是我们需要刷写的系统，sysupgrade是当内核更新时系统升级的版本。</p><h4 id="设置旁路有"><a href="#设置旁路有" class="headerlink" title="设置旁路有"></a>设置旁路有</h4><p>我们把树莓派插到路由器上</p><p>主路由器(192.168.3.1)—-&gt;树莓派网关(192.168.3.2)</p><p>设置openwrt 网络-接口-基本设置<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/openwrt2.png" alt="openwrt设置"></p><p>设置传输协议为静态地址，ip地址要和主路由在一个网段内，子网掩码设置默认，ipv4网关设置为主路由的ipv4地址，和ipv6相关设置全部关闭。</p><p><strong>这里有个坑需要注意</strong>,我们设置好这些最好填写一些自定义DNS服务器比如：114.114.114.114。这是为了防止出现在路由器终端内ping的通公网ip但是</p><p>ping不通域名的尴尬情况。</p><p>在高级设置内打开动态DHCP和强制、开机自运行、强制链路，物理设置内关闭桥接、接口选择eth0就行了。最后就保存并运用<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/openwrt3.png" alt="openwrt设置"></p><p>最后需要设置防火墙，在自定义规则内填入</p><pre><code class="hljs shell">iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE</code></pre><p>重启防火墙即可。</p><p>最后重启路由器和旁路由，我们检查自己的设备是否网关都是旁路由地址就可以了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>旁路由模式其实是整个网络环境下有两个网关，主路由是第一个网关，旁路由是第二个网关所有网络流量会先到主路由再到旁路由。</p><p>这也就会带来一个问题，如果你搞到了公网ipv4的地址想做端口转发应该怎么做？其实有个原则，在哪个设备上进行拨号，DHCP我们就</p><p>在哪个设备上进行端口转发。</p><p>但是旁路由模式相对比较特殊，在设置DDNS时我们可以在openwrt上进行设置，因为主路由对与DDNS提供商可能会由限制。荣耀、华为就只能</p><p>使用oary(贝瑞)的域名。所以我们使用openwrt的ddns插件，选择自己现有的域名进行设置，这个时候因为我们不是网口拨号，只能使用url查询。</p><p>我建议使用<a href="https://ip.3322.net/">https://ip.3322.net/</a>这个网站。</p><p>然后设置好动态DNS后，设置端口转发时就会发现我们无论怎么设置都不能通过网址访问除了openwrt以外的所有设备，这可能就是我最开始说的</p><p>旁路由相对独特的网络的特点。我们就需要先在主路由上设置端口转发给openwrt然后我们再通过openwrt上的端口转发再进行转发到相应的设备端口上。</p><p>有人可能会有疑问我们需不需要设置openwrt防火墙里面的转发为接受，我测试的结果是不需要，无论是拒绝和接受都不影响。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/openwrt4.png" alt="主路由设置"></p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/openwrt5.png" alt="旁路由设置"></p><p>对了，可能你为了省事打开了DMZ服务，那你可能会面临一个问题，你可能会无法从域名访问你的设备，具体为什么我也不太清楚。</p><h2 id="最最后"><a href="#最最后" class="headerlink" title="最最后"></a>最最后</h2><p>可能会有人担心树莓派的行能问题，目前来说我通过梯子上网，开启的有广告过滤，smartDNS，DDNS，基本上每天的cpu性能使用率不到2%。家里的设备大概是</p><p>8台300M的网速基本无压力，可以大胆放心使用。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>openwrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debian编译CMake遇到的坑</title>
    <link href="/2022/01/10/Debian%E8%A3%85CMake%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <url>/2022/01/10/Debian%E8%A3%85CMake%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>踩坑记录<br><a id="more"></a></p><p>事情是这样的这两天我准备搭一个CLion的远程开发环境来给我的毕业设计做一下准备，在配置Toolchains的时候因为是一个远程环境。<br>需要确认远程主机上是否有相应的开发环境。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AE.png" alt=""><br>大概就是上图那个样子，我的树莓派上没有CMake所以就有了后来的这些坑。</p><h1 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h1><p>&nbsp;&nbsp;当时忘记截图了，大概就是我通过<code>bootstrap</code>引导<code>cmake</code>安装的时候报了一个它找不到openssl和openssl所对应的库。</p><p>我当时第一反应以为是我的机器上没有装openssl然后我就尝试用了一下<code>openssl version</code>的命令看看能不能有结果。</p><p>发现嘿！我机器上有这玩意，然后我以为是我的版本太低了，网上有些帖子也有这种观点。我就尝试去更行一下openssl。</p><p>但是操作下来发现问题其实不是这个openssl版本的问题，因为报错信息里面说的是它找不到库函数。</p><p>我更行了之后通过<code>find</code>命令也找不到那个东西安装哪里去了。这个坑现在我也没有解决emm，后面再研究一下。</p><h1 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h1><p>&nbsp;&nbsp;当然CMake的报错还给了我另一条路可以选，就是编译的时候忽略<code>openssl</code>，提示是-DCMAKE_USE_OPENSSL=OFF，我试了一下是不是在使用bootstrap命令的时候后面加一句，发现这样没什么卵用，又因为是CMake的编译是由CMakeList.txt控制的和makefile差不多，想是不是改CMakeList.txt来实现。</p><p>就在CMakeList.txt的头部加上set(CMAKE_USE_OPENSSL OFF)然后再试一下bootstrap命令，唉!就成了然后就是一些基本流程。</p><p>还有个很重要的问题，我的机器是树莓派编译CMake的时间长大概编译了快两个小时，所以性能差的设备就被干等了。乘早挂在那里睡觉吧。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/CMake%E7%BC%96%E8%AF%91.jpg" alt=""></p><p>不要学我在那傻等。</p><h1 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h1><p>&nbsp;&nbsp;当我把CMake配置好之后，我准备把CLion的最后一部分配置完成一切都正常，但是还是有个问题就是CLion找不到gmake。</p><p>gamke其实就是make，因为在别的平台上面make这个名词一直被占用就叫做gmake了这个相对来说好解决，只需要建立一个链接就好了。</p><pre><code class="hljs shell">cd /usr/binln -s make gamke</code></pre><h1 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h1><p>&nbsp;&nbsp;vim好久没用了，vim的搜索关键字的还是很重要的有两种方法</p><ul><li>方法1: /content 默认从上往下查找<ul><li>只读模式下输入 /content 后回车</li><li>按 n 向下查找</li><li>按 N 向上查找</li></ul></li><li>方法2：?content 默认从下往上查找<ul><li>只读模式下输入 ?content 后回车</li><li>按 n 向上查找</li><li>按 N 向下查找</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021</title>
    <link href="/2021/12/31/2021%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/31/2021%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2021总结<br><a id="more"></a></p><h1 id="序-简述一下这一年"><a href="#序-简述一下这一年" class="headerlink" title="序-简述一下这一年"></a>序-简述一下这一年</h1><p>&nbsp;&nbsp;2021年是关键一年，因为我选择了考研。正因我从年初选择了考研，这一年我一开始想想必是单一而枯燥的一年，但是到年终我才发现我只猜中了开始但是没有猜中结尾。</p><p>我记得我在刚去自习室的时候发现，自习室厕所窗户前有课水杉，我当时就想起来高中毕业的时候有个老兄发了四张教室窗户前水杉四个季节的照片，印象特别深刻也正应为这个我也决定用这种方法来记录一下生活，</p><p>我也用这种方法记录了这9个月来的生活。我本以为学习见坚持的过程是很痛苦的，但是我有一群志同道合的朋友这使我减轻了不少的压力。但是我在学习中好方法的保持上还是没能做到一如既往，这确实我的一个遗憾。</p><p>正因为这群朋友让我对每个月的月底感到非常的期待，因为我们可以一起出去吃烧烤也是我感到最为放松的时候。</p><p>&nbsp;&nbsp;这一年下来最痛苦的时期也是最让我成长的时期我觉得应该就是考前的三个月的那段时间，因为那段时间查漏补缺问题层次不穷的冒出来，也导致了自己状态的起伏，心态的变化也在那个时期最为频繁。</p><p>“焦虑”算是那段时间的关键词吧，睡不着见，吃不进饭，学习效率底下，基本上都是焦虑的基本病状。这也要我逐渐失去了把题目做对的信心。</p><h1 id="有的放矢"><a href="#有的放矢" class="headerlink" title="有的放矢"></a>有的放矢</h1><p>&nbsp;&nbsp;有的放矢这四个字应该是我这一路下来领悟最深的成语。因为在最后几个月里面我真真真切切的明白了人的精力是有限的。也正因为感觉自己可以抓住整个面，但是到最后每个点都很平庸。在适当的时候放弃，</p><p>并不会影响整个事情的发展，反而会有好的结果。但是对我来说要是能做到这点只有我想明白放过自己才能做到，不然我就会感到不甘心，觉得自己还是能全都要，但是实际上这对我来说是种非常愚蠢的想法。</p><h1 id="蚌埠住了"><a href="#蚌埠住了" class="headerlink" title="蚌埠住了"></a>蚌埠住了</h1><p>&nbsp;&nbsp;最后一个月的背书应该是我以后再也忘不掉的记忆了，真的是太痛苦了。每天晚睡早起，躲到人少的隔间里背书，我本以为我早点开始记忆可以缓解冲刺阶段的压力，但是实际并没有什么作用，每天需要背诵的东西基本上</p><p>不可能完成自己的任务，而我确没有意识到这个问题，这也使我在冲刺的时候埋下了隐患，直接导致了直到考试前一天知识我还没背完。再加上不让别的学科状态下滑，就得额外抽出时间来弥补这些可能出现的问题。</p><p>不过这也是个普遍的现象，坚持不下去的也在最后这段时间摆烂了。真的太不容易了，如果要我再来一次我感觉我真的坚持不下去。</p><h1 id="谈谈未来"><a href="#谈谈未来" class="headerlink" title="谈谈未来"></a>谈谈未来</h1><p>&nbsp;&nbsp;现在来说在等成绩这段时间还是需要好好准备一下，复试的科目。万一我要是我进复试了，也不至于应付不过来。</p><p>其二就是通过考试我发现我对长期目标的规划和完成能力缺陷还是很大很多事情缺乏长期规划,由于没有长期的规划从而无法完成一些需要长期完成的事情。虽然有能力对短期目标有明确规划，但是对宏观总体无法做出有效的把握。<br>因此需要尝试对长期目标做出尝试性规划来提升相关能力。<br>其三是毕业设计的问题，Linux的相关内容还是不熟悉，再就是网络编程。这两块对我来说可能都比较生疏了还是需要快速的把内容过一篇。毕竟在家里面整个人都是懒散的…..根本没什么效率可说。还是得想办法改变一下才行。<br>其四就是要长期练习英语，单词外刊，英文书籍。感觉英语这玩意就是得多用多练，不然就没办法提高。什么语法，什么长难句，可能就是为了考试能更快理解吧。但是练的多成习惯了就不会在意这些了。</p>]]></content>
    
    
    <categories>
      
      <category>day</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断互质数的五种方法</title>
    <link href="/2021/02/19/%E5%88%A4%E6%96%AD%E4%BA%92%E8%B4%A8%E6%95%B0%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/19/%E5%88%A4%E6%96%AD%E4%BA%92%E8%B4%A8%E6%95%B0%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一. 概念判断法</p><p>公约数只有1的两个数叫做互质数。根据互质数的概念可以对一组数是否互质进行判断。如：9和11的公约数只有1，则它们是互质数。</p><p>二. 规律判断法</p><p>根据互质数的定义，可总结出一些规律，利用这些规律能迅速判断一组数是否互质。</p><p>（1）两个不相同的质数一定是互质数。如：7和11、17和31是互质数。</p><p>（2）两个连续的自然数一定是互质数。如：4和5、13和14是互质数。</p><p>（3）相邻的两个奇数一定是互质数。如：5和7、75和77是互质数。</p><p>（4）1和其他所有的自然数一定是互质数。如：1和4、1和13是互质数。</p><p>（5）两个数中的较大一个是质数，这两个数一定是互质数。如：3和19、16和97是互质数。</p><p>（6）两个数中的较小一个是质数，而较大数是合数且不是较小数的倍数，这两个数一定是互质数。如：2和15、7和54是互质数。</p><p>（7）较大数比较小数的2倍多1或少1，这两个数一定是互质数。如：13和27、13和25是互质数。</p><p>三. 分解判断法</p><p>如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数。如果没有，这两个数是互质数。如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11。分解后，发现它们没有相同的质因数，则130和231是互质数。</p><p>四. 求差判断法</p><p>如果两个数相差不大，可先求出它们的差，再看差与其中较小数是否互质。如果互质，则原来两个数一定是互质数。如：194和201，先求出它们的差，201－194＝7，因7和194互质，则194和201是互质数。</p><p>五. 求商判断法</p><p>用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。如：317和52，317÷52＝6……5，因余数5与52互质，则317和52是互质数。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学学习的思考</title>
    <link href="/2021/02/18/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/02/18/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>值得思考的数学，看到一篇很不错的数学分享</p><a id="more"></a><p>学好数学，要先建立知识网络，再训练解题路径搜索能力</p><p>1、在理解的基础上牢记知识点，并记住这些知识点的来龙去脉，形成一个知识网络是高效学习的第一步。</p><p>2、解题就是从你的知识网络中独立自主的搜索出一条有效的解题路径。</p><p>3、不独立钻研难题，只听老师讲题，轻易看答案，相当于走哪儿都带着导航走。 丢了导航，立马抓瞎！</p><p>在我教过的学生中，我见过两类自称数学学的不好的。</p><p>一类学生，是以下这类情况：比如我问他，什么是对数，他说知道，我们课上讲过对数。但是我问他对数运算规律，他知道几个，但不全知道。 问他换底公式，他说，书上写着呢。但我让他写出来，又写的磕磕巴巴。 我继续问，换底公式还有几个变形，知道吗？ 答曰，老师上课讲过。 我让他写出来，不会。 我给他写出来，他做恍然大悟状。</p><p>这样的学生，我要求他系统的复述知识点都常常是半生不熟， 要让他把这些知识点用在具体的题目上，谈何容易。这种基本可以判定是基础问题，知识点太生了，不要说形成自己的知识网络了，知识点都是模糊的，点与点的连线就更模糊脆弱了。 所以当务之急是理解并记忆知识点。 为了记住知识点，刷最基础的简单题。</p><p>还有一类学生，知识点公式背的挺熟练，也刷过很多题。对于已经做过几遍的题型，基本能做出来。 但如果往细节处问，经不起问。 问着问着，就变成我看例题就是这么做的。这样的学生还有一个特点，比如你问他对数的换底公式，他记住了好几个，但你问这几个之间什么关系，怎么来的？ 他们有时候不知道。这类学生知识点已经记忆的很好了，但是知识点之间的连线是模糊的，所以也没有形成自己的知识网络。</p><p>这样的学生如果面对一道没见过的题型，常常一看没见过，试了三五分钟就放弃了。这样的学生，是勤动手，懒动脑的。 他们刷过很多题， 但常常是听过老师讲过这类题型之后，勤动手刷同类型题，对解题过程形成肌肉记忆。 这样的学生，考试还是能保证基本分数的。 可越学越吃力，因为越往上学，需要记忆的题型越来越多了。</p><p>所以在理解的基础上牢记知识点，并记住这些知识点的来龙去脉，形成一个知识网络是高效学习的第一步。有了牢固的知识网络。还要有下面这个能力：一道题拿到你面前， 你要从你的知识网络中搜索出能够用于解决这道题目的，用到这个题目上去。</p><p>我觉得这个能力是最难的，也是所谓的“思维能力”的体现。 这个能力是受益终身的能力，掌握了这个能力，即使学过的知识忘的差不多了，需要的时候也能快速重建知识网络、寻找解决问题的途径。</p><p>有些学生常常会抱怨说，数学太难。说，总是老师一讲就会，答案一看就懂，可是就是自己想不出来。 听老师讲，看答案， 这个独立搜索的过程，你是没有的。 长期欠缺这个能力，自己做题的时候， 就不知道怎么搜索。</p><p>解决的办法是，遇到新的题目、难的题目，要沉得住气去理解、分析，尝试求解。比较难的题目， 其解题路径常常由好几个知识点串起来的。 拿到一个难题， 最好还是尽可能多的去独立思考怎么做这个题目。 习惯了这样的主动搜索， 你离学好理科就不远了。看答案，或等着老师讲解，你把这其中最艰难，最有价值，最能体现智力的主动搜索能力给省了。</p><p>而思考了很久，实在不会做，再去看答案，就好像你去一个地方， 到处找路， 到处碰壁，突然有个人告诉你， 前面红色的门那里左拐。 这时候，这个信息就在你的记忆中非常的深刻。</p><p>看完了答案（或听完课）， 过一两天，必须要独自做一遍。 这就是你把之前你不能主动搜索知识点的过程补上。 就相当于， 有人带着你走了一遍路之后， 你要检查一下你到底记住路了没有， 还必须过两天再自己独立走一遍。简单的路， 拐一两个弯， 甚至是直路，一般独立走一遍你就记住了。 复杂的路， 左拐， 几个路口后右拐， 然后几个路口以后进了小区， 又七拐八拐，才能到。 你让别人带着走一遍， 就能完全记住的， 说明你的方向感（数学直觉） 很好。 不好怎么办？ 笨办法， 多练！</p><p>所以， 不独立钻研难题，只听老师讲题，轻易看答案，相当于走哪儿都带着导航走。 丢了导航，立马抓瞎！</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年</title>
    <link href="/2020/12/27/2020%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/27/2020%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2020年的总结<br><a id="more"></a></p><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>&emsp;&emsp;时间总是过的太快，天天和我玩着逗你玩的游戏。一晃一年又过去了，回想这一年也是十分魔幻了。从年初的疫情在家学习，等着杳无音讯的开学时间，到直接上半年在家里修完了大二下学期的整个课程。再到暑假去做实习体验，去南京穷游。再到下半年，直接回到学校开始了大三的学校，然后就是现在这个时刻。<br>&emsp;&emsp;没想到2020年过的格外之快，快到我能记清楚每个时间节点我都在做什么。快到我根本来不及好好感受生活，感知这个神奇的年份，我现在还依稀记得，在2019年年末我回到家，从阳台可以看到前面那块块荒地，从荒芜生息，到春天生机盎然。再到夏天茂盛高长，漫过我的身高。窗前的景色的变化不仅丈量这时间的长度，也要我渐渐感受到了时间的流逝。在家头一次呆那么久，我也头一次感受到我想去外面走走的意愿有多么的强烈。我的妈妈也义无反顾的答应我要我出去逛逛，这便有那次神奇的南京之旅。如果要我总结这一年我愿意把这一年分为三部分“上中下”。</p><h1 id="上"><a href="#上" class="headerlink" title="上"></a>上</h1><p>&emsp;&emsp;上半年的魔幻程度我觉得我有必要再说一说，疫情在家由于爸爸的工作原因…，但是我觉得是我爸的正义感。他擅做主张的上了前线，当时一连一两个月不在家，我正真感受到了我爸的那种众人为己任，大任为我担当，我将义不容辞的感觉。虽然我和时常想起这件事我都会打趣的说这是我爸有远见，想到抗疫成功之后能捞到好处hhh，不过正常人谁会把自己的生命和担当至于整个家庭之外冒这个险呢。也正是这样我和我妈两个人在家里相依为命的呆了两个月，我也深入了解到了我家这几年的得与失，逐渐感受到了他们的真实想法。疫情虽然在家度过了看似毫无意义的半年，因为我觉得在家上课就和玩差不多，好事靠自己自学了。但是我真正感受到了父母在一起的难道，可能这次疫情之后我很难再有和爸妈一起生活这么就的日子了。<br>&emsp;&emsp;不过还好，这个疫情还算有始有终，天气渐渐转暖。可能是当时在家太过于颓废把，天天除了睡觉就是吃饭了hhh，到了5月份把我重新做起了计划，也正是这样吧。把难以丈量的时间分为了，一段又一段的时区，我也渐渐养成的习惯，每天的生活也开始充实起来，每天起床背单词，每天看多少书，每天学多少东西，在什么时间学完，短期的有长期的也有。当实现短期目的开始无法满足我的时候我也渐渐可以完成长期目标。也是因为这些， 我每天晚上跑步，锻炼身体，也开始成为了习惯，每天坚持的3公里。也使我渐渐找到了跑步放松的乐趣和自虐坚持的爽快感Hhh有点抖M内味道了嗷。</p><h1 id="中"><a href="#中" class="headerlink" title="中"></a>中</h1><p>&emsp;&emsp;因为暑假的临近，社会复工复产的也主键恢复到了往日的生机。我也知道我不喜欢在家呆着，希望能出去玩玩或者说换种生活方式。就去参加了实习计划嘛，然后我就去了规划院哈哈哈，那里确实是一个学习的好去处里面大哥哥姐姐都是大吼人呀！！各处都很照顾我，也就没事帮他们看看电脑里面的问题,虽然我说我是学计算机，但是win的疑难杂症我也的解决方法也只能是去网上搜一下利索我能及的帮他们解决一下问题。院里面的徐工(徐国什么什么哈哈其实我还是记得名字的)，王竹燕姐姐，王院长，宋院长，张爽哥等等，大家都狠照顾我。当时在院里面的两个事我还是很清楚的虽然都是和吃饭有关哈哈哈，第一次是王院长要我和徐工一起出外勤，去某乡镇看他们测绘并了解一下现场情况，我当时嫌热就穿了一套清凉装，不过在上班之前我妈和我说过要我尽量穿短袖长裤上班，一个是职场礼节把，另一个就是防止在出外勤的时候被蚊虫叮咬。不过我也没想到我回出外勤，那次也是被咬的挺惨的然后就是中午的饭菜确实挺不错，就是酒桌上，说的话不太事宜哈哈，跟着一个哥哥喊50多岁的叔叔“哥”，有点尴尬。还有次就是王竹燕姐姐带我出去吃饭(主要是那个姐姐张的太好看了hhh)那次也比较好玩，一起去吃饭的业主姐姐的弟弟刚好是我同学，不然气氛挺尴尬的。也是疫情之后第一次去吃火锅，饭后去又去了一清吧(第一次去嗷！！)，我一个人干了四瓶鸡尾酒把，也好像是啤酒不过我感觉我还挺能喝的走路不飘一切正常，回家幸亏我爹不在家，我身上也没啥酒味脸也不红，肯能我妈没看出来把，就赶快去洗澡了哈哈哈有点刺激。<br>&emsp;&emsp;实习过后我就萌生了想出去逛逛的想法，也不知道为什么一开始第一反应就是去成都，或者重庆。不过因为别的原因嘛，就没敲定选择去了南京。也不知道为什么我一直又想去南京发展的想法，无论是学习还是工作生活。可惜现在学习肯定是去不了了，只能渴求以后了。不过这次去南京给我的感觉就是路很窄，最求梦想的人很多。地铁修很有旅游特点。第一感觉并没有我想象的那样，不过我很喜欢满街梧桐树，把道路的天空遮蔽起来的感觉。有点都市小城的感觉，不过我玩是真的没有玩舒服，因为我想去的想吃的都被一些省钱的建议打乱了。我也不知道说什么好，我还是想再去一次南京，好好感受一下古城的魅力，因为我认为南京的魅力不在于此。不过还是像吐槽一下老门东那边是真的无聊，硬是就是无聊的小吃街。</p><h1 id="下"><a href="#下" class="headerlink" title="下"></a>下</h1><p>&emsp;&emsp;上半年的过的太安逸，但是时间长了我也难免会想起我和我室友一起再周么开黑游戏到深夜的快乐，一起出去玩相互吹牛逼的欢乐场景。可能是几个男生一起生活久了吧，难免会有点想念吧，毕竟这也算是我的青春吧。回到学校的愿望也逐渐开始强烈起来，可能是在家呆时间长了吧。毕竟在学校自在一些，可以随意的干一些自己愿意的事情。哦对了其实我在暑假还有一件事，对我今年还蛮重要的，就是我实习的时候上下班都是开车上下班，这也要我这个每次开车都要我爸在旁边看着的小司机有了可以单干的机会。然后又是在南京租车带的我那俩小兄弟跑了个南京城。要我更有自信一个人开车了。现在想想还蛮刺激的，自己开车去学校，开车去接同学又在外面玩了两天，两天一直在开车Hhhh也是绝了。感觉当时是玩开了，真正的疫情之后的放风吧哈哈哈。不过今年开车也有翻车的时候，就是有次我去接我民族大学的发小去汉口吃饭，有个路口也不知道为啥，我可能刹车没踩死吧就撞轻轻的碰了一下前车，不过还好没什么问题，没有坑之类的，那个东北的女司机可能看我是小孩就放了我一马，但是我要交代在这了哈哈哈。<br>&emsp;&emsp;下半年的在校学习因为有几个时间节点显得还蛮有秩序，但是因为疫情的原因，学校压缩了课时，取消了一些活动，课程安排也十分紧凑。不过我还是在一开始几个月抽了点时间去搞了一下实习hhh，还挺有意思的。起码补贴了我的日常生活，要我后面的过的有点潇洒。不过还好幸亏我离职的早，后面课程紧张的时候我相对我室友有更多时间去学习和折腾还是意见蛮好的事情，有舍有得嘛。到期末vsbf带着大家复习，我也把我室友拉了进来，帮着他一起给期末困难户解决问题。从中间我明白了一件事，就是要是一件事重复了多遍，在什么情况你都能运用自足。在详细一下，就是给室友讲解问题，围绕着一个一些知识点反复的给别人讲，再不熟练都能很熟练，然后就应该是自己练习与巩固了。而我感觉我这次复习只有前面没有后面，不过可能是时间原因把，复习时间确实不多，我的有些课程也算是速成的。希望以后不会这样了。然后就是最后的这个该死的项目，其实组员都挺不错的。我感觉我做的也挺不错的，起码每个人都才项目组里面做了自己该做的事情，基本达到了我的目的，就是锻炼他们的个人意识这块感觉不济我的期望。<br><!---这才是正篇，其实这样的我真的不想吐槽那个Acmer，我不清楚是为什么，是不上心么。为什么我每次的布置的任务我都说的非常明确了，但是还是那个样子，我真的搞不懂了，要是能做了就和我说清楚嘛，我就提前计划好，还好我有预料到，提前把事情搞完，不至于一直拖到最后赶集赶忙的，为了完成任务而完成任务，我当然知道我自己的能力，我能单干虽然可能不会非常优秀，但是带着大家一起拿个优秀还是很稳的--><br>&emsp;&emsp;就先说这么多吧hhh</p>]]></content>
    
    
    <categories>
      
      <category>day</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC ResultSet结果通过java反射赋值给java对象</title>
    <link href="/2020/12/25/JDBC%E8%BF%94%E5%9B%9EResultSet/"/>
    <url>/2020/12/25/JDBC%E8%BF%94%E5%9B%9EResultSet/</url>
    
    <content type="html"><![CDATA[<p>使用反射</p><a id="more"></a><p>我们先来写一个不用框架，用JDBC来操作呢数据库，下面写一个简单的例子：</p><pre><code class="hljs java"><span class="hljs-comment">// 加载驱动程序</span>Class.forName(driver);conn = DriverManager.getConnection(url, user, password);Statement statement = conn.createStatement();String sql = <span class="hljs-string">&quot;select * from user&quot;</span>;ResultSet rs = statement.executeQuery(sql);String name  = <span class="hljs-keyword">null</span>;String phone = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">while</span> (rs.next()) &#123;    <span class="hljs-comment">//获取stuname这列数据</span>    name  = rs.getString(<span class="hljs-string">&quot;user_name&quot;</span>);    phone = rs.getString(<span class="hljs-string">&quot;user_phone&quot;</span>);    System.out.println(name + <span class="hljs-string">&quot;\t&quot;</span> + phone);&#125;</code></pre><p>就是这么简单的一段代码，然后就是想从数据库中获取相应的字段，就用get和set方法来处理，返回一个对象，写起来就是麻烦，不通用</p><p>因为java有反射的功能，所以可以抽取出来，写个通用的方法。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 把ResultSet的结果放到java对象中</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> rs</span><span class="hljs-comment"> *            ResultSet</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> obj</span><span class="hljs-comment"> *            java类的class</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ArrayList&lt;T&gt; <span class="hljs-title">putResult</span><span class="hljs-params">(ResultSet rs, Class&lt;T&gt; obj)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;ArrayList&lt;T&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;T&gt;();ResultSetMetaData metaData = rs.getMetaData();<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取总列数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">int</span> count = metaData.getColumnCount();<span class="hljs-keyword">while</span> (rs.next()) &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建对象实例</span><span class="hljs-comment"> */</span>T newInstance = obj.newInstance();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= count; i++) &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 给对象的某个属性赋值</span><span class="hljs-comment"> */</span>String name = metaData.getColumnName(i).toLowerCase();name = toJavaField(name);<span class="hljs-comment">// 改变列名格式成java命名格式</span>String substring = name.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// 首字母大写</span>String replace = name.replaceFirst(substring, substring.toUpperCase());Class&lt;?&gt; type = obj.getDeclaredField(name).getType();<span class="hljs-comment">// 获取字段类型</span>Method method = obj.getMethod(<span class="hljs-string">&quot;set&quot;</span> + replace, type);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断读取数据的类型</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span>(type.isAssignableFrom(String.class))&#123;method.invoke(newInstance, rs.getString(i));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.isAssignableFrom(<span class="hljs-keyword">int</span>.class) || type.isAssignableFrom(Integer.class))&#123;method.invoke(newInstance, rs.getInt(i));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.isAssignableFrom(Boolean.class) || type.isAssignableFrom(<span class="hljs-keyword">boolean</span>.class))&#123;method.invoke(newInstance, rs.getBoolean(i));&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.isAssignableFrom(Date.class))&#123;method.invoke(newInstance, rs.getDate(i));&#125;&#125;arrayList.add(newInstance);&#125;<span class="hljs-keyword">return</span> arrayList; &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException | SQLException | SecurityException| NoSuchMethodException | IllegalArgumentException | InvocationTargetException| NoSuchFieldException e) &#123;<span class="hljs-comment">// TODO Auto-generated catch block</span>e.printStackTrace();&#125; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 数据库命名格式转java命名格式</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> str</span><span class="hljs-comment"> *            数据库字段名</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> java字段名</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toJavaField</span><span class="hljs-params">(String str)</span> </span>&#123;  String[] split = str.split(<span class="hljs-string">&quot;_&quot;</span>);StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();builder.append(split[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 拼接第一个字符</span>  <span class="hljs-comment">// 如果数组不止一个单词</span><span class="hljs-keyword">if</span> (split.length &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; split.length; i++) &#123;<span class="hljs-comment">// 去掉下划线，首字母变为大写</span>String string = split[i];String substring = string.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);split[i] = string.replaceFirst(substring, substring.toUpperCase());builder.append(split[i]);&#125;&#125;  <span class="hljs-keyword">return</span> builder.toString();&#125;</code></pre><p>这里先简单处理这几种常用类型，其他的其实可以后续再加上。这里主要依赖反射obj.getDeclaredField(name).getType()获取字段类型，然后通过obj.getMethod(“set” + replace, type)来找到数据库java对象的这个set方法，最终method.invoke(newInstance, rs.getString(i))来附值，这么一想，如果查出来是一个很大的list的，那么该怎么优化呢？</p><p>先来使用一下，这个写的小工具，就可以不用繁琐的get和set方法：</p><pre><code class="hljs java">ArrayList&lt;userDO&gt; userDOS = ResultSetPropertiesHelper.transferResult(rs, userDO.class);<span class="hljs-keyword">for</span> (UserDD userDO : userDOS) &#123;    System.out.println(userDO.toString());&#125;</code></pre><p>上面是通过对象里面的set和get方法来设置变量的值，这样写起来感觉比较麻烦，直接用Field的set方法是不是更加简单一点，但是这样写，访问的是public对象，所以</p><pre><code class="hljs `java">Field field &#x3D; obj.getField(name);if (type.isAssignableFrom(String.class)) &#123;method.invoke(newInstance, rs.getString(i));&#125; else if (type.isAssignableFrom(byte.class) || type.isAssignableFrom(Byte.class)) &#123;method.invoke(newInstance, rs.getByte(i));&#x2F;&#x2F; byte 数据类型是8位、有符号的，以二进制补码表示的整数&#125; else if (type.isAssignableFrom(short.class) || type.isAssignableFrom(Short.class)) &#123;method.invoke(newInstance, rs.getShort(i));&#x2F;&#x2F; short 数据类型是 16 位、有符号的以二进制补码表示的整数&#125; else if (type.isAssignableFrom(int.class) || type.isAssignableFrom(Integer.class)) &#123;method.invoke(newInstance, rs.getInt(i));&#x2F;&#x2F; int 数据类型是32位、有符号的以二进制补码表示的整数&#125; else if (type.isAssignableFrom(long.class) || type.isAssignableFrom(Long.class)) &#123;method.invoke(newInstance, rs.getLong(i));&#x2F;&#x2F; long 数据类型是 64 位、有符号的以二进制补码表示的整数&#125; else if (type.isAssignableFrom(float.class) || type.isAssignableFrom(Float.class)) &#123;method.invoke(newInstance, rs.getFloat(i));&#x2F;&#x2F; float 数据类型是单精度、32位、符合IEEE 754标准的浮点数&#125; else if (type.isAssignableFrom(double.class) || type.isAssignableFrom(Double.class)) &#123;method.invoke(newInstance, rs.getDouble(i));&#x2F;&#x2F; double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数&#125; else if (type.isAssignableFrom(BigDecimal.class)) &#123;method.invoke(newInstance, rs.getBigDecimal(i));&#125; else if (type.isAssignableFrom(boolean.class) || type.isAssignableFrom(Boolean.class)) &#123;method.invoke(newInstance, rs.getBoolean(i));&#x2F;&#x2F; boolean数据类型表示一位的信息&#125; else if (type.isAssignableFrom(Date.class)) &#123;method.invoke(newInstance, rs.getDate(i));&#125;</code></pre><p>这里补充一下ResultSetMetaData接口都有哪些信息</p><p>可以使用此对象获得列的数目和类型以及每一列的名称：</p><ul><li>getColumnCount(); 返回 ResultSet 中的列数。 </li><li>getColumnName(int); 返回列序号为 int 的列名。 </li><li>getColumnLabel(int); 返回此列暗含的标签。 </li><li>isCurrency(int); 如果此列包含带有货币单位的一个数字，则返回 true。 </li><li>isReadOnly(int); 如果此列为只读，则返回 true。 </li><li>isAutoIncrement(int); 如果此列自动递增，则返回 true。这类列通常为键，而且始终是只读的。 </li><li>getColumnType(int); 返回此列的 SQL 数据类型。这些数据类型包括 </li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简述数据库连接池</title>
    <link href="/2020/12/23/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2020/12/23/%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>简介数据库连接池</p><a id="more"></a><h1 id="一般怎么链接数据库"><a href="#一般怎么链接数据库" class="headerlink" title="一般怎么链接数据库"></a>一般怎么链接数据库</h1><p>一般来说，Java应用程序访问数据库的过程是：</p><ol><li>装载数据库驱动程序</li><li>通过Jdbc链接数据库链接</li><li>访问数据库，执行sql语句</li><li>断开数据库连接</li></ol><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 声明Connection对象</span>        Connection connection;        <span class="hljs-comment">// 驱动程序名</span>        String driver = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;        <span class="hljs-comment">// URL指向要访问的数据库名也就是那张表 student</span>        String url  = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/student?serverTimezone=UTC&quot;</span>;        <span class="hljs-comment">// MySQL配置时的用户名</span>        String user = <span class="hljs-string">&quot;root&quot;</span>;        <span class="hljs-comment">// MySQL配置时的密码</span>        String pwd  = <span class="hljs-string">&quot;233333333&quot;</span>;        <span class="hljs-comment">// 加载驱动</span>        <span class="hljs-comment">// 防止没有该驱动</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 1.加载驱动</span>            Class.forName(driver);            System.out.println(<span class="hljs-string">&quot;驱动连接成功&quot;</span>);            <span class="hljs-comment">// 2.创建连接</span>            connection = DriverManager.getConnection(url, user, pwd);            <span class="hljs-keyword">if</span> (!connection.isClosed()) &#123;                System.out.println(<span class="hljs-string">&quot;\n\t\t成功以 &quot;</span> + user + <span class="hljs-string">&quot; 身份连接到数据库！！！&quot;</span>);            &#125;            <span class="hljs-comment">// 3.创建Statement</span>            Statement statement = connection.createStatement();            <span class="hljs-comment">// PreparedStatement 安全性更高</span><span class="hljs-comment">//            PreparedStatement st = connection.createStatement();</span>            <span class="hljs-comment">// 4.执行sql</span>            String sql_1 = <span class="hljs-string">&quot;insert into student.info values(&#x27;6&#x27;, &#x27;ash-bin&#x27;, &#x27;数学&#x27;, 40000)&quot;</span>;            <span class="hljs-keyword">int</span> n = statement.executeUpdate(sql_1);            System.out.println(n);            String sql_2 = <span class="hljs-string">&quot;select * from student.info&quot;</span>;            <span class="hljs-comment">// 5.ResultSet类，用来存放获取的结果集！！</span>            ResultSet rs = statement.executeQuery(sql_2);            System.out.println(<span class="hljs-string">&quot;\n\t\t执行结果如下所示:&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t-----------------------------------------------------&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t|\t&quot;</span> + <span class="hljs-string">&quot;ID&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;姓名&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;专业&quot;</span> + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;薪水\t|&quot;</span>);            System.out.println(<span class="hljs-string">&quot;\t\t-----------------------------------------------------&quot;</span>);            <span class="hljs-keyword">int</span> ID  = <span class="hljs-number">0</span>;            String name      = <span class="hljs-keyword">null</span>;            String salary    = <span class="hljs-keyword">null</span>;            String dept_name = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 查询</span>            <span class="hljs-keyword">while</span> (rs.next()) &#123;            <span class="hljs-comment">// 获取 ID 这列数据</span>            ID = rs.getInt(<span class="hljs-string">&quot;ID&quot;</span>);            <span class="hljs-comment">// 获取 Name 这列数据</span>            name = rs.getString(<span class="hljs-string">&quot;Name&quot;</span>);            <span class="hljs-comment">// 获取 dept_name 这列数据</span>            dept_name = rs.getString(<span class="hljs-string">&quot;dept_name&quot;</span>);            <span class="hljs-comment">// 获取 salary 这列数据</span>            salary = rs.getString(<span class="hljs-string">&quot;salary&quot;</span>);            <span class="hljs-comment">// 输出结果</span>            System.out.println(<span class="hljs-string">&quot;\t\t|\t&quot;</span> + ID + <span class="hljs-string">&quot;\t&quot;</span> + name + <span class="hljs-string">&quot;\t&quot;</span> + dept_name + <span class="hljs-string">&quot;\t&quot;</span> + salary + <span class="hljs-string">&quot;\t|\t\t&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; <span class="hljs-comment">// 这个异常是驱动异常</span>            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;没有该驱动&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123; <span class="hljs-comment">// 这个异常是getConnection的异常</span>            e.printStackTrace();            System.out.println(<span class="hljs-string">&quot;创建数据库连接失败&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;\t\t\t\t获取数据库数据完毕！&quot;</span>);        &#125;    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="连接池"></p><p>程序开发过程中，存在很多问题：</p><ol><li>首先，每一次web请求都要建立一次数据库连接。建立连接是一个费时的活动，每次都得花费0.05s～1s的时间，而且系统还要分配内存资源。这个时间对于一次或几次数据库操作，或许感觉不出系统有多大的开销。</li><li><p>可是对于现在的web应用，尤其是大型电子商务网站，同时有几百人甚至几千人在线是很正常的事。在这种情况下，频繁的进行数据库连接操作势必占用很多的系统资源，网站的响应速度必定下降，严重的甚至会造成服务器的崩溃。不是危言耸听，这就是制约某些电子商务网站发展的技术瓶颈问题。其次，对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将不得不重启数据库</p><p>通过上面的分析，我们可以看出来，“数据库连接”是一种稀缺的资源，为了保障网站的正常使用，应该对其进行妥善管理。其实我们查询完数据库后，如果不关闭连接，而是暂时存放起来，当别人使用时，把这个连接给他们使用。就避免了一次建立数据库连接和断开的操作时间消耗。</p><p>数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。</p><p>创建数据库连接池大概有3个步骤：</p><ol><li>创建ConnectionPool实例，并初始化创建10个连接，保存在Vector中（线程安全）</li><li>实现getConnection()从连接库中获取一个可用的连接</li><li>returnConnection(conn) 提供将连接放回连接池中方法</li></ol></li></ol><p> 数据库连接池类 ConnectionPool.java<br> <pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DatabaseMetaData;<span class="hljs-keyword">import</span> java.sql.Driver;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.sql.Statement;<span class="hljs-keyword">import</span> java.util.Enumeration;<span class="hljs-keyword">import</span> java.util.Vector; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123; <span class="hljs-keyword">private</span> String jdbcDriver = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库驱动</span><span class="hljs-keyword">private</span> String dbUrl = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据 URL</span><span class="hljs-keyword">private</span> String dbUsername = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库用户名</span><span class="hljs-keyword">private</span> String dbPassword = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 数据库用户密码</span><span class="hljs-keyword">private</span> String testTable = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 测试连接是否可用的测试表名，默认没有测试表</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> initialConnections = <span class="hljs-number">10</span>; <span class="hljs-comment">// 连接池的初始大小</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> incrementalConnections = <span class="hljs-number">5</span>;<span class="hljs-comment">// 连接池自动增加的大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxConnections = <span class="hljs-number">50</span>; <span class="hljs-comment">// 连接池最大的大小</span><span class="hljs-keyword">private</span> Vector connections = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 存放连接池中数据库连接的向量 , 初始时为 null</span><span class="hljs-comment">// 它中存放的对象为 PooledConnection 型</span> <span class="hljs-comment">/**</span><span class="hljs-comment"> * 构造函数</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> jdbcDriver</span><span class="hljs-comment"> *            String JDBC 驱动类串</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbUrl</span><span class="hljs-comment"> *            String 数据库 URL</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbUsername</span><span class="hljs-comment"> *            String 连接数据库用户名</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dbPassword</span><span class="hljs-comment"> *            String 连接数据库用户的密码</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String jdbcDriver, String dbUrl, String dbUsername,</span></span><span class="hljs-function"><span class="hljs-params">String dbPassword)</span> </span>&#123;<span class="hljs-keyword">this</span>.jdbcDriver = jdbcDriver;<span class="hljs-keyword">this</span>.dbUrl = dbUrl;<span class="hljs-keyword">this</span>.dbUsername = dbUsername;<span class="hljs-keyword">this</span>.dbPassword = dbPassword;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池的初始大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 初始连接池中可获得的连接数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getInitialConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.initialConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池的初始大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 用于设置初始连接池中连接的数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInitialConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.initialConnections = initialConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池自动增加的大小 、</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 连接池自动增加的大小</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIncrementalConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.incrementalConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池自动增加的大小</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 连接池自动增加的大小</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIncrementalConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> incrementalConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.incrementalConnections = incrementalConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回连接池中最大的可用连接数量</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 连接池中最大的可用连接数量</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxConnections</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.maxConnections;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置连接池中最大可用的连接数量</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 设置连接池中最大可用的连接数量值</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaxConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxConnections)</span> </span>&#123;<span class="hljs-keyword">this</span>.maxConnections = maxConnections;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取测试数据库表的名字</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 测试数据库表的名字</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTestTable</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.testTable;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 设置测试表的名字</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> testTable</span><span class="hljs-comment"> *            String 测试表的名字</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTestTable</span><span class="hljs-params">(String testTable)</span> </span>&#123;<span class="hljs-keyword">this</span>.testTable = testTable;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 创建一个数据库连接池，连接池中的可用连接的数量采用类成员 initialConnections 中设置的值</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">// 确保连接池没有创建</span><span class="hljs-comment">// 如果连接池己经创建了，保存连接的向量 connections 不会为空</span><span class="hljs-keyword">if</span> (connections != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果己经创建，则返回</span>&#125;<span class="hljs-comment">// 实例化 JDBC Driver 中指定的驱动类实例</span>Driver driver = (Driver) (Class.forName(<span class="hljs-keyword">this</span>.jdbcDriver).newInstance());DriverManager.registerDriver(driver); <span class="hljs-comment">// 注册 JDBC 驱动程序</span><span class="hljs-comment">// 创建保存连接的向量 , 初始时有 0 个元素</span>connections = <span class="hljs-keyword">new</span> Vector();<span class="hljs-comment">// 根据 initialConnections 中设置的值，创建连接。</span>createConnections(<span class="hljs-keyword">this</span>.initialConnections);<span class="hljs-comment">// System.out.println(&quot; 数据库连接池创建成功！ &quot;);</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建由 numConnections 指定数目的数据库连接 , 并把这些连接 放入 connections 向量中</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> numConnections</span><span class="hljs-comment"> *            要创建的数据库连接的数目</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createConnections</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numConnections)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 循环创建指定数目的数据库连接</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; numConnections; x++) &#123;<span class="hljs-comment">// 是否连接池中的数据库连接的数量己经达到最大？最大值由类成员 maxConnections</span><span class="hljs-comment">// 指出，如果 maxConnections 为 0 或负数，表示连接数量没有限制。</span><span class="hljs-comment">// 如果连接数己经达到最大，即退出。</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.maxConnections &gt; <span class="hljs-number">0</span>&amp;&amp; <span class="hljs-keyword">this</span>.connections.size() &gt;= <span class="hljs-keyword">this</span>.maxConnections) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">// add a new PooledConnection object to connections vector</span><span class="hljs-comment">// 增加一个连接到连接池中（向量 connections 中）</span><span class="hljs-keyword">try</span> &#123;connections.addElement(<span class="hljs-keyword">new</span> PooledConnection(newConnection()));&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 创建数据库连接失败！ &quot;</span> + e.getMessage());<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException();&#125;<span class="hljs-comment">// System.out.println(&quot; 数据库连接己创建 ......&quot;);</span>&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建一个新的数据库连接并返回它</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个新创建的数据库连接</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">newConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 创建一个数据库连接</span>Connection conn = DriverManager.getConnection(dbUrl, dbUsername,dbPassword);<span class="hljs-comment">// 如果这是第一次创建数据库连接，即检查数据库，获得此数据库允许支持的</span><span class="hljs-comment">// 最大客户连接数目</span><span class="hljs-comment">// connections.size()==0 表示目前没有连接己被创建</span><span class="hljs-keyword">if</span> (connections.size() == <span class="hljs-number">0</span>) &#123;DatabaseMetaData metaData = conn.getMetaData();<span class="hljs-keyword">int</span> driverMaxConnections = metaData.getMaxConnections();<span class="hljs-comment">// 数据库返回的 driverMaxConnections 若为 0 ，表示此数据库没有最大</span><span class="hljs-comment">// 连接限制，或数据库的最大连接限制不知道</span><span class="hljs-comment">// driverMaxConnections 为返回的一个整数，表示此数据库允许客户连接的数目</span><span class="hljs-comment">// 如果连接池中设置的最大连接数量大于数据库允许的连接数目 , 则置连接池的最大</span><span class="hljs-comment">// 连接数目为数据库允许的最大数目</span><span class="hljs-keyword">if</span> (driverMaxConnections &gt; <span class="hljs-number">0</span>&amp;&amp; <span class="hljs-keyword">this</span>.maxConnections &gt; driverMaxConnections) &#123;<span class="hljs-keyword">this</span>.maxConnections = driverMaxConnections;&#125;&#125;<span class="hljs-keyword">return</span> conn; <span class="hljs-comment">// 返回创建的新的数据库连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过调用 getFreeConnection() 函数返回一个可用的数据库连接 , 如果当前没有可用的数据库连接，并且更多的数据库连接不能创</span><span class="hljs-comment"> * 建（如连接池大小的限制），此函数等待一会再尝试获取。</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接对象</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池己被创建</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 连接池还没创建，则返回 null</span>&#125;Connection conn = getFreeConnection(); <span class="hljs-comment">// 获得一个可用的数据库连接</span><span class="hljs-comment">// 如果目前没有可以使用的连接，即所有的连接都在使用中</span><span class="hljs-keyword">while</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 等一会再试</span><span class="hljs-comment">// System.out.println(&quot;Wait&quot;);</span>wait(<span class="hljs-number">250</span>);conn = getFreeConnection(); <span class="hljs-comment">// 重新再试，直到获得可用的连接，如果</span><span class="hljs-comment">// getFreeConnection() 返回的为 null</span><span class="hljs-comment">// 则表明创建一批连接后也不可获得可用连接</span>&#125;<span class="hljs-keyword">return</span> conn;<span class="hljs-comment">// 返回获得的可用的连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 本函数从连接池向量 connections 中返回一个可用的的数据库连接，如果 当前没有可用的数据库连接，本函数则根据</span><span class="hljs-comment"> * incrementalConnections 设置 的值创建几个数据库连接，并放入连接池中。 如果创建后，所有的连接仍都在使用中，则返回 null</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">getFreeConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 从连接池中获得一个可用的数据库连接</span>Connection conn = findFreeConnection();<span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 如果目前连接池中没有可用的连接</span><span class="hljs-comment">// 创建一些连接</span>createConnections(incrementalConnections);<span class="hljs-comment">// 重新从池中查找是否有可用连接</span>conn = findFreeConnection();<span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 如果创建连接后仍获得不到可用的连接，则返回 null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-keyword">return</span> conn;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 查找连接池中所有的连接，查找一个可用的数据库连接， 如果没有可用的连接，返回 null</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回一个可用的数据库连接</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Connection <span class="hljs-title">findFreeConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;Connection conn = <span class="hljs-keyword">null</span>;PooledConnection pConn = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 获得连接池向量中所有的对象</span>Enumeration enumerate = connections.elements();<span class="hljs-comment">// 遍历所有的对象，看是否有可用的连接</span><span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-keyword">if</span> (!pConn.isBusy()) &#123;<span class="hljs-comment">// 如果此对象不忙，则获得它的数据库连接并把它设为忙</span>conn = pConn.getConnection();pConn.setBusy(<span class="hljs-keyword">true</span>);<span class="hljs-comment">// 测试此连接是否可用</span><span class="hljs-keyword">if</span> (!testConnection(conn)) &#123;<span class="hljs-comment">// 如果此连接不可再用了，则创建一个新的连接，</span><span class="hljs-comment">// 并替换此不可用的连接对象，如果创建失败，返回 null</span><span class="hljs-keyword">try</span> &#123;conn = newConnection();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 创建数据库连接失败！ &quot;</span> + e.getMessage());<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;pConn.setConnection(conn);&#125;<span class="hljs-keyword">break</span>; <span class="hljs-comment">// 己经找到一个可用的连接，退出</span>&#125;&#125;<span class="hljs-keyword">return</span> conn;<span class="hljs-comment">// 返回找到到的可用连接</span>&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试一个连接是否可用，如果不可用，关掉它并返回 false 否则可用返回 true</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> conn</span><span class="hljs-comment"> *            需要测试的数据库连接</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回 true 表示此连接可用， false 表示不可用</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">testConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 判断测试表是否存在</span><span class="hljs-keyword">if</span> (testTable.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<span class="hljs-comment">// 如果测试表为空，试着使用此连接的 setAutoCommit() 方法</span><span class="hljs-comment">// 来判断连接否可用（此方法只在部分数据库可用，如果不可用 ,</span><span class="hljs-comment">// 抛出异常）。注意：使用测试表的方法更可靠</span>conn.setAutoCommit(<span class="hljs-keyword">true</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 有测试表的时候使用测试表测试</span><span class="hljs-comment">// check if this connection is valid</span>Statement stmt = conn.createStatement();stmt.execute(<span class="hljs-string">&quot;select count(*) from &quot;</span> + testTable);&#125;&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<span class="hljs-comment">// 上面抛出异常，此连接己不可用，关闭它，并返回 false;</span>closeConnection(conn);<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// 连接可用，返回 true</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 此函数返回一个数据库连接到连接池中，并把此连接置为空闲。 所有使用连接池获得的数据库连接均应在不使用此连接时返回它。</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 需返回到连接池中的连接对象</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-comment">// 确保连接池存在，如果连接没有创建（不存在），直接返回</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法返回此连接到连接池中 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-comment">// 遍历连接池中的所有连接，找到这个要返回的连接对象</span><span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 先找到连接池中的要返回的连接对象</span><span class="hljs-keyword">if</span> (conn == pConn.getConnection()) &#123;<span class="hljs-comment">// 找到了 , 设置此连接为空闲状态</span>pConn.setBusy(<span class="hljs-keyword">false</span>);<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 刷新连接池中所有的连接对象</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshConnections</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池己创新存在</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法刷新 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;<span class="hljs-comment">// 获得一个连接对象</span>pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 如果对象忙则等 5 秒 ,5 秒后直接刷新</span><span class="hljs-keyword">if</span> (pConn.isBusy()) &#123;wait(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 等 5 秒</span>&#125;<span class="hljs-comment">// 关闭此连接，用一个新的连接代替它。</span>closeConnection(pConn.getConnection());pConn.setConnection(newConnection());pConn.setBusy(<span class="hljs-keyword">false</span>);&#125;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 关闭连接池中所有的连接，并清空连接池。</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnectionPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<span class="hljs-comment">// 确保连接池存在，如果不存在，返回</span><span class="hljs-keyword">if</span> (connections == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">&quot; 连接池不存在，无法关闭 !&quot;</span>);<span class="hljs-keyword">return</span>;&#125;PooledConnection pConn = <span class="hljs-keyword">null</span>;Enumeration enumerate = connections.elements();<span class="hljs-keyword">while</span> (enumerate.hasMoreElements()) &#123;pConn = (PooledConnection) enumerate.nextElement();<span class="hljs-comment">// 如果忙，等 5 秒</span><span class="hljs-keyword">if</span> (pConn.isBusy()) &#123;wait(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 等 5 秒</span>&#125;<span class="hljs-comment">// 5 秒后直接关闭它</span>closeConnection(pConn.getConnection());<span class="hljs-comment">// 从连接池向量中删除它</span>connections.removeElement(pConn);&#125;<span class="hljs-comment">// 置连接池为空</span>connections = <span class="hljs-keyword">null</span>;&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 关闭一个数据库连接</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 需要关闭的数据库连接</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;conn.close();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;System.out.println(<span class="hljs-string">&quot; 关闭数据库连接出错： &quot;</span> + e.getMessage());&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使程序等待给定的毫秒数</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> 给定的毫秒数</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mSeconds)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(mSeconds);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 内部使用的用于保存连接池中连接对象的类 此类中有两个成员，一个是数据库的连接，另一个是指示此连接是否 正在使用的标志。</span><span class="hljs-comment"> */</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PooledConnection</span> </span>&#123;Connection connection = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 数据库连接</span><span class="hljs-keyword">boolean</span> busy = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 此连接是否正在使用的标志，默认没有正在使用</span> <span class="hljs-comment">// 构造函数，根据一个 Connection 构告一个 PooledConnection 对象</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PooledConnection</span><span class="hljs-params">(Connection connection)</span> </span>&#123;<span class="hljs-keyword">this</span>.connection = connection;&#125; <span class="hljs-comment">// 返回此对象中的连接</span><span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> connection;&#125; <span class="hljs-comment">// 设置此对象的，连接</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnection</span><span class="hljs-params">(Connection connection)</span> </span>&#123;<span class="hljs-keyword">this</span>.connection = connection;&#125; <span class="hljs-comment">// 获得对象连接是否忙</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBusy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> busy;&#125; <span class="hljs-comment">// 设置对象的连接正在忙</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBusy</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> busy)</span> </span>&#123;<span class="hljs-keyword">this</span>.busy = busy;&#125;&#125; &#125;</code></pre></p><p>ConnectionPoolUtils.java</p><pre><code class="hljs java"><span class="hljs-comment">/*连接池工具类，返回唯一的一个数据库连接池对象,单例模式*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPoolUtils</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPoolUtils</span><span class="hljs-params">()</span></span>&#123;&#125;;<span class="hljs-comment">//私有静态方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool poolInstance = <span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">GetPoolInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(poolInstance == <span class="hljs-keyword">null</span>) &#123;poolInstance = <span class="hljs-keyword">new</span> ConnectionPool( <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/student?serverTimezone=UTC&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;233333333&quot;</span>);<span class="hljs-keyword">try</span> &#123;poolInstance.createPool();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-comment">// TODO Auto-generated catch block</span>e.printStackTrace();&#125;&#125;<span class="hljs-keyword">return</span> poolInstance;&#125;&#125;</code></pre><p>ConnectionPoolTest.java<br><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.DriverManager;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.sql.Statement;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionTest</span> </span>&#123; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">/*使用连接池创建100个连接的时间*/</span>        <span class="hljs-comment">/*// 创建数据库连接库对象</span><span class="hljs-comment">       ConnectionPool connPool = new ConnectionPool(&quot;com.mysql.jdbc.Driver&quot;,&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);</span><span class="hljs-comment">       // 新建数据库连接库</span><span class="hljs-comment">           connPool.createPool();*/</span>       ConnectionPool  connPool=ConnectionPoolUtils.GetPoolInstance();<span class="hljs-comment">//单例模式创建连接池对象</span>            <span class="hljs-comment">// SQL测试语句</span>       String sql = <span class="hljs-string">&quot;Select * from pet&quot;</span>;       <span class="hljs-comment">// 设定程序运行起始时间</span>       <span class="hljs-keyword">long</span> start = System.currentTimeMillis();             <span class="hljs-comment">// 循环测试100次数据库连接</span>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                  Connection conn = connPool.getConnection(); <span class="hljs-comment">// 从连接库中获取一个可用的连接</span>                  Statement stmt = conn.createStatement();                  ResultSet rs = stmt.executeQuery(sql);                  <span class="hljs-keyword">while</span> (rs.next()) &#123;                      String name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);                   <span class="hljs-comment">//  System.out.println(&quot;查询结果&quot; + name);</span>                  &#125;                  rs.close();                  stmt.close();                  connPool.returnConnection(conn);<span class="hljs-comment">// 连接使用完后释放连接到连接池</span>              &#125;              System.out.println(<span class="hljs-string">&quot;经过100次的循环调用，使用连接池花费的时间:&quot;</span>+ (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;ms&quot;</span>);              <span class="hljs-comment">// connPool.refreshConnections();//刷新数据库连接池中所有连接，即不管连接是否正在运行，都把所有连接都释放并放回到连接池。注意：这个耗时比较大。</span>             connPool.closeConnectionPool();<span class="hljs-comment">// 关闭数据库连接池。注意：这个耗时比较大。</span>              <span class="hljs-comment">// 设定程序运行起始时间</span>              start = System.currentTimeMillis();                            <span class="hljs-comment">/*不使用连接池创建100个连接的时间*/</span>             <span class="hljs-comment">// 导入驱动</span>              Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                  <span class="hljs-comment">// 创建连接</span>                 Connection conn = DriverManager.getConnection(                          <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);                  Statement stmt = conn.createStatement();                  ResultSet rs = stmt.executeQuery(sql);                 <span class="hljs-keyword">while</span> (rs.next()) &#123;                  &#125;                 rs.close();                 stmt.close();                 conn.close();<span class="hljs-comment">// 关闭连接</span>             &#125;             System.out.println(<span class="hljs-string">&quot;经过100次的循环调用，不使用连接池花费的时间:&quot;</span>                     + (System.currentTimeMillis() - start) + <span class="hljs-string">&quot;ms&quot;</span>);         &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();         &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;             e.printStackTrace();        &#125;&#125;</code></pre></p><p>注：关于对连接池深度的思考，对于一般的连接池最多10个就够了，基本可以应付一般的小项目。但是连接池开大过大，是不是就可以理解成没有连接池，因为缓存太多了就和没开连接池一样呢？</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈script标签的defer和async</title>
    <link href="/2020/11/28/%E6%B5%85%E8%B0%88script%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/11/28/%E6%B5%85%E8%B0%88script%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>有点意思</p><a id="more"></a><h1 id="1-什么鬼"><a href="#1-什么鬼" class="headerlink" title="1.什么鬼"></a>1.什么鬼</h1><p>今天在做一个小玩意的时候看到一句吊炸天的代码<br><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;#link(&quot;</span>xxxx/xx/home/home.js<span class="hljs-string">&quot;)&quot;</span> type=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-keyword">async</span> defer&gt;&lt;/script&gt;</code></pre></p><p>卧槽，竟然同时有async和defer属性，这尼玛是什么操作，赶快学习一下</p><h1 id="2-调查一番"><a href="#2-调查一番" class="headerlink" title="2.调查一番"></a>2.调查一番</h1><p>先看看<code>async</code>和<code>defer</code>各自的定义吧，翻开红宝书望远镜，是这么介绍的</p><h2 id="2-1-defer"><a href="#2-1-defer" class="headerlink" title="2.1 defer"></a>2.1 defer</h2><blockquote><p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置<code>defer</code>属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于<code>DOMContentLoaded</code>事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在<code>DOMContentLoad</code>时间触发前执行，因此最好只包含一个延迟脚本。</p></blockquote><h2 id="2-2-async"><a href="#2-2-async" class="headerlink" title="2.2 async"></a>2.2 async</h2><blockquote><p>这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p></blockquote><p>概括来讲，就是这两个属性都会使script标签异步加载，然而执行的时机是不一样的。引用segmentfault上的一个回答中的一张图<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1443517782-57c6928b20b56_articlex.jpg" alt=" "></p><p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p><p>也就是说<code>async</code>是乱序的，而defer是顺序执行，这也就决定了<code>async</code>比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。从图中可以看到一个普通的<code>&lt;script&gt;</code>标签的加载和解析都是同步的，会阻塞DOM的渲染，这也就是我们经常会把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部的原因之一，为了防止加载资源而导致的长时间的白屏，另一个原因是js可能会进行DOM操作，所以要在DOM全部渲染完后再执行。</p><h2 id="2-3-really？"><a href="#2-3-really？" class="headerlink" title="2.3 really？"></a>2.3 really？</h2><p><strong>然而</strong>，这张图（几乎是百度搜到的唯一答案）是不严谨的，这只是规范的情况，大多数浏览器在实现的时候会作出优化。</p><p>来看看chrome是怎么做的:</p><blockquote><p>《WebKit技术内幕》：</p><ol><li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li><li>加载器依赖网络模块建立连接，发送请求并接受答复。</li><li>WebKit接收到各种网页或者资源的数据，其中某些资源可能是同步或异步获取的。</li><li>网页被交给HTML解释器转变成一系列的词语（Token）。</li><li>解释器根据词语构建节点（Node），形成DOM树。</li><li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li><li>JavaScript代码可能会修改DOM树的结构。</li><li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载他们，但是他们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol></blockquote><p>所以，通俗来讲，chrome浏览器首先会请求HTML文档，然后对其中的各种资源调用相应的资源加载器进行异步网络请求，同时进行DOM渲染，直到遇到<code>&lt;script&gt;</code>标签的时候，主进程才会停止渲染等待此资源加载完毕然后调用V8引擎对js解析，继而继续进行<code>DOM</code>解析。我的理解如果加了async属性就相当于单独开了一个进程去独立加载和执行，而defer是和将<code>&lt;script&gt;</code>放到<code>&lt;body&gt;</code>底部一样的效果。</p><h1 id="3-实验一发"><a href="#3-实验一发" class="headerlink" title="3. 实验一发"></a>3. 实验一发</h1><h2 id="3-1-demo"><a href="#3-1-demo" class="headerlink" title="3.1 demo"></a>3.1 demo</h2><p>为了验证上面的结论我们来测试一下</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://cdn.staticfile.org/foundation/6.0.1/css/foundation.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://lib.sinaapp.com/js/angular.js/angular-1.2.19/angular.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/backbone/0.9.2/backbone.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    ul&gt;li&#123;这是第$个节点&#125;*1000<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>一个简单的demo，从各个CDN上引用了2个CSS3个JS，在body里面创建了1000个li。通过调整外部引用资源的位置和加入相关的属性利用chrome的Timeline进行验证。</p><h2 id="放置在内"><a href="#放置在内" class="headerlink" title="放置在内"></a>放置在<head>内</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/2699686611-57c6929ae4e60_articlex.jpg" alt=""><br>异步加载资源，但会阻塞<code>&lt;body&gt;</code>的渲染会出现白屏，按照顺序立即执行脚本</p><h2 id="3-3-放置在底部"><a href="#3-3-放置在底部" class="headerlink" title="3.3 放置在底部"></a>3.3 放置在<body>底部</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/2025377632-57c692a8e1d80_articlex.jpg" alt=""><br>异步加载资源，等<body>中的内容渲染完毕后且加载完按顺序执行JS</p><h2 id="3-3-放置在头部并使用async"><a href="#3-3-放置在头部并使用async" class="headerlink" title="3.3 放置在头部并使用async"></a>3.3 放置在<head>头部并使用async</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/1609828464-57c692b36943c_articlex.jpg" alt=""><br>异步加载资源，且加载完JS资源立即执行，并不会按顺序，谁快谁先上</p><h2 id="3-4-放置在头部并使用defer"><a href="#3-4-放置在头部并使用defer" class="headerlink" title="3.4 放置在头部并使用defer"></a>3.4 放置在<head>头部并使用defer</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/3039840796-57c692be0062f_articlex.jpg" alt=""><br>异步加载资源，在DOM渲染后之后再按顺序执行JS</p><h2 id="3-5-放置在头部并同时使用async和defer"><a href="#3-5-放置在头部并同时使用async和defer" class="headerlink" title="3.5 放置在头部并同时使用async和defer"></a>3.5 放置在<head>头部并同时使用async和defer</h2><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure//img/3802019618-57c692c9d447e_articlex.jpg" alt=""><br>表现和async一致，开了个脑洞，把这两个属性交换一下位置，看会不会有覆盖效果，结果发现是一致的 = =、</p><p>综上，在webkit引擎下，建议的方式仍然是把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部，如果需要使用百度谷歌分析或者不蒜子等独立库时可以使用async属性，若你的<code>&lt;script&gt;</code>标签必须写在<code>&lt;head&gt;</code>头部内可以使用defer属性</p><h1 id="4-兼容性"><a href="#4-兼容性" class="headerlink" title="4. 兼容性"></a>4. 兼容性</h1><p>那么，同时写上的原因是什么呢，兼容性?</p><p>上caniuse，async在IE&lt;=9时不支持，其他浏览器OK；defer在IE&lt;=9时支持但会有bug，其他浏览器OK；现象在这个issue里有描述，这也就是“望远镜”里建议只有一个defer的原因。所以两个属性都指定是为了在async不支持的时候启用defer，但defer在某些情况下还是有bug。</p><blockquote><p>The defer attribute may be specified even if the async attribute is specified, to cause legacy Web browsers that only support defer (and not async) to fall back to the defer behavior instead of the synchronous blocking behavior that is the default.</p></blockquote><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><p>其实这么讲来，最稳妥的办法还是把<code>&lt;script&gt;</code>写在<code>&lt;body&gt;</code>底部，没有兼容性问题，没有白屏问题，没有执行顺序问题，高枕无忧，不要搞什么defer和async的花啦~<br>目前只研究了chrome的webkit的渲染机制，Firefox和IE的有待继续研究，图片和CSS以及其他外部资源的渲染有待研究</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache地址映射与计算方式</title>
    <link href="/2020/11/01/cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/01/cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Cache地址映射</p><a id="more"></a><h1 id="什么是Cache地址映射"><a href="#什么是Cache地址映射" class="headerlink" title="什么是Cache地址映射"></a>什么是Cache地址映射</h1><p>&emsp;&emsp;主存的容量比Cache要大的多，所以我们得采用多个主存块映射到同一个Cache行中的方法，将要访问的局部主存区域取到Cache中。映射方法有：直接映射，全相联映射，组相链映射</p><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>直接映射是最简单粗暴的办法：</p><blockquote><p>(块地址)mod(cache中的块数)</p></blockquote><p>&emsp;&emsp;一个内存块地址始终映射到一个固定的Cache 地址。下图中主存被分为了0-2047个内存块，缓存块或者说cache line有16块。那么第0，16，n*16块因为mod16都为0，所以他们对应到的Cache行号都为0。如果我们要访问第16号内存块(内存块从0开始计数的)，只要它在缓存块里面，那么它必定是在0号缓存块，也就是行号为0.<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162001890-759184579.png" alt=""></p><p>&emsp;&emsp;知道了映射方法，那么如何规定主存地址呢？其实对于取模运算，我们只需要取低位字节就可以了。在十进制里面如果对16取余，那么结果定是两位数以内，并且不会大于15。比如说Cache有16行，16是2的4次方，那么我们就可以直接取主存块号的低四位作为Cache行号。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162127959-1713738037.png" alt=""></p><p>&emsp;&emsp;17对应的cache行号就是1.但当我们读取某一个缓存行时，我们怎么知道他是0块群的还是其他块群的呢？其实正如主存块号中包含了Cache行号一样，其低四位之前的高位就可以作为区分的Tag(主存标记)使用。最后一点就是，CPU读取数据只是要读取它需要的字(Word)而已，那么这个字具体是在Cache line的哪里，我们还需要一个偏移量来纪录它。所以直接映射的主存地址应该由三部分组成：主存子块标记，Cache子块标记，字块内地址。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162153262-921590979.png" alt=""></p><blockquote><p>现在我们来自己动手做一做：假设数据在主存和Cache间的传送单位为512B，Cache大小为$2^{13}$B，主存大小为$2^{20}$B。</p></blockquote><p>&emsp;&emsp;因为主存大小为$2^{20}$B,且以512B为传送单位。那么$2^{20}$B=2048块$ \times $512B/块，主存可以划分为2048块，主存地址为20位二进制数。因为我们需要确定要取的是块中的哪个字，又$512=2^9$，所以需要9位作为偏移量，或者说字块内地址。 Cache可以划分出16行($2^{13}$=16行 $\times$ 512B/行)，也就是说划出4位作为行号标记，或者说Cache字块地址。剩下的7位自然就作为主存字块标记啦。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162214235-403548343.png" alt=""></p><p>优缺点：</p><ul><li>电路实现简单，命中时间短</li><li>无需考虑替换问题</li><li>Cache的存储空间没有得到充分使用，命中率低</li></ul><h2 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h2><p>&emsp;&emsp;针对直接映射Cache空间利用率低的问题，我们有一种简单粗暴的办法提升空间的利用率。那就是主存中的任意一块都可以映射到Cache中的任意一个位置。有空位置你就坐下，随意，映射位置不在固定。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162229663-269157985.png" alt=""></p><p>&emsp;&emsp;那么我们唯一要做的就是知道Cache中是对应主存中的哪一块和字块内地址就行。因为是随便映射，所以我们把直接映射中的Cache字块标记合并到主存字块标记中。</p><p><code>全相联映射主存地址只有两部分：主存字块标记，字块内地址。</code></p><p>优缺点：</p><ul><li>不存在冲突缺失，命中率高</li><li>电路复杂，速度慢</li></ul><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p>&emsp;&emsp;综合前两种方法的就是组相联映射，具体做法是：将Cache中的行分组，主存块映射到固定的行中，但行中的位置可以随意。也就是组间直接映射，组内全相联映射。</p><blockquote><p>Cache组号=主存块号 mod Cache组数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162251696-1669819464.png" alt=""></p><p>&emsp;&emsp;那么问题来了怎么确定Cache中的字块是对应主存的那一块呢？首先我们仍需要字块内地址，需要区分组号，那么剩下的地址就可以作为主存字块标记使用。</p><blockquote><p>容量为64块的Cache，采用组相联方式映像，字块大小为128字，每4块为一组。若主存容量为4096块，且以字编址，那么主存地址该如何划分？</p></blockquote><p>&emsp;&emsp;因为$4096=2^{19}$，所以主存地址应该为19位，Cache总共有16组，所以需要4位确定组号。又字块大小为$128$字，$128=2^7$，所有字块内地址为7位，剩下的$19-7-4=8$位作为主存字块标记。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/1932912-20200702162305856-386316918.png" alt=""></p><p>优缺点：</p><ul><li>电路较简单，速度较快，命中率较高，属于比较理想的方式</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟地址和物理地址</title>
    <link href="/2020/10/16/virtual_address/"/>
    <url>/2020/10/16/virtual_address/</url>
    
    <content type="html"><![CDATA[<p>计算机中虚拟地址与物理地址</p><a id="more"></a><h1 id="一、了解基本概念"><a href="#一、了解基本概念" class="headerlink" title="一、了解基本概念"></a>一、了解基本概念</h1><h2 id="1-地址空间"><a href="#1-地址空间" class="headerlink" title="1.地址空间"></a>1.地址空间</h2><p>&emsp;&emsp;我们最开始接触地址的时候，应该是在我们学习数组的时候。地址空间其实是一个比较抽象的概念，我们可以把它想象成一个长的数组，每个数组元素占一个字节。那么这个数组的长度就由地址空间长度来决定。例如：我们32位的系统的地址空间就是我们的$2^{32}$字节(4GB),而64位的地址空间大小就是$2^{64}$个字节。这也就解释了在我们32位的操作系统，为什么最大只能支持4GB的有效内存。</p><p><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/15774762-3a7d9d5ef4e0d886.webp" alt=" "></p><h2 id="2-虚拟地址的由来"><a href="#2-虚拟地址的由来" class="headerlink" title="2.虚拟地址的由来"></a>2.虚拟地址的由来</h2><p>&emsp;&emsp;在早期的计算机中，程序是直接运行到物理内存（可以理解为内存条上的内存）上的。也就是说，程序运行的时候直接访问的就是物理地址。如果，我们的一个计算机只运行一个程序，那么只有这个程序所需要的内存空间不超过物理内存空间的大小，就不会有问题。但是，我们正在希望的是在某个时候同时运行多个程序。那么这个时候，就会有个一个问题，计算机如何把有限的物理内存分配给多个程序使用呢？<br>&emsp;&emsp;某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A,接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。<br>&emsp;&emsp;问题1：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。<br>&emsp;&emsp;问题2：内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。<br>&emsp;&emsp;问题3：程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。但是我们的某些硬件是需要在固定的地址上去开始运行的，但是如果这个地址后边被我们的程序占有，那么我们对这块内存的修改，就可能导致某些硬件不可用了。<br>&emsp;&emsp;为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><h1 id="二、虚拟地址和物理地址映射"><a href="#二、虚拟地址和物理地址映射" class="headerlink" title="二、虚拟地址和物理地址映射"></a>二、虚拟地址和物理地址映射</h1><p>&emsp;&emsp;了解了我们的虚拟地址和物理地址的由来，下面我们来总结一下，他们的概念.<br>&emsp;&emsp;物理地址：物理地址空间是实在的存在于计算机中的一个实体，在每一台计算机中保持唯一独立性。我们可以称它为物理内存；如在32位的机器上，物理空间的大小理论上可以达到$2^{32}$字节(4GB)，但如果实际装了512的内存，那么其物理地址真正的有效部分只有$512MB = 512 \times 1024 KB = = 512 \times 1024 \times 1024 B (0x00000000\sim0x1fffffff)$。其他部分是无效的。<br>&emsp;&emsp;虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是$0x00000000\sim0xFFFFFFFF$.每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，<br>这样做到了有效的隔离。<br>&emsp;&emsp;在上面我们提到了合理的内存管理机制。我们这里虚拟地址和物理地址之间的映射是通过MMU（内存管理单元）来完成的。<br><img src="https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/15774762-b0ec5de9cf127f27.webp" alt=" "><br>&emsp;&emsp;我们平时操作的内存其实都是通过操作虚拟地址的内存单元。通过通过MMU的映射来间接的操作我们的物理地址。</p><h1 id="对虚地址的理解"><a href="#对虚地址的理解" class="headerlink" title="对虚地址的理解"></a>对虚地址的理解</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><ol><li>每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。</li><li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。</li><li>每个进程已经分配的内存空间，都与对应的磁盘空间映射。<br><br><br>问题：计算机明明没有那么多内存（n个进程的话就需要$n\times4$G）内存建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！</li></ol><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><ol><li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li><li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li><li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。</li><li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。</li><li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处。</li><li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。</li><li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li></ol><p>&emsp;&emsp;另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码<br>（比如.text .data段）.拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）,等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，<br>要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超级源点与超级汇点</title>
    <link href="/2020/09/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(3)/"/>
    <url>/2020/09/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(3)/</url>
    
    <content type="html"><![CDATA[<p>超级源点与超级汇点<br><a id="more"></a></p><h1 id="背景1"><a href="#背景1" class="headerlink" title="背景1"></a>背景1</h1><p>给出题目，在一张图中有多个点起点，一个终点，求所有起点到终点的最短距离。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>跑N边单源最短路，但是这样是不行的肯定超时。</li><li>floyd求出所有最短路，枚举每个起点到终点的距离，这个似乎比法1更慢。</li><li>反向建边，反向跑一遍Dijkstra，或者SPFA，这样就能求到终点到起点的距离，在枚举最小的一个即可，时间复杂度为一遍最短路加枚举N。</li><li>建立超级源点，虚拟出一个点作为源点，源点到所有起点的距离都是0，那么这样求超级源点到终点的最短距离就是所有起点到终点的距离的最短一个，时间复杂度为一遍最短路。</li></ol><h1 id="背景2"><a href="#背景2" class="headerlink" title="背景2"></a>背景2</h1><p>给出一张图中有一个起点，有多个终点，求一个起点到所有终点的最短距离。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ol><li>直接忽略floyd</li><li>一遍最短路（SPFA或Dijkstra），枚举N。</li><li>建立超级汇点，所有终点到汇点的距离为0，一遍最短路即可的出答案。</li></ol><h1 id="背景3"><a href="#背景3" class="headerlink" title="背景3"></a>背景3</h1><p>给出一张图，图中有若干起点与若干终点，在所有终点到起点的距离中的最短距离。</p><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ol><li>跑若干遍最短路，找到所有最短距离，比较得出最小值</li><li>建立超级源点，建立超级汇点，一遍Dijkstra或SPFA即可。</li></ol><p>通过上面我们大致知道超级源点超级汇点的建立的条件，而且通过超级源点（汇点）可以极大的减少题目的时间复杂度，在图论中用的比较多。最后我们用图的方式表示源点及汇点的建立。</p><p><img src="/img/short-path/super1.png" alt="如图"></p><p><img src="/img/short-path/super2.png" alt="如图"></p>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径之Dijkstra</title>
    <link href="/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/"/>
    <url>/2020/09/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(2)/</url>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><p>&emsp;&emsp;在上一篇文章当中我们讲解了bellman-ford算法和spfa算法，其中spfa算法是我个人比较常用的算法，比赛当中几乎没有用过其他的最短路算法。但是spfa也是有缺点的，我们之前说过它的复杂度是<br>$O(kE)$，这里的E是边的数量。但有的时候边的数量很多，E最多能够达到$V^2$，这会导致超时，所以我们会更换其他的算法。这里说的其他的算法就是Dijkstra。</p><h1 id="Dijkstra算法的前提："><a href="#Dijkstra算法的前提：" class="headerlink" title="Dijkstra算法的前提："></a>Dijkstra算法的前提：</h1><ol><li>首先，Dijkstra处理的是带正权值的<code>有权图</code>，那么，就需要一个二维数组（如果空间大用list数组）存储各个点到达(边)的权值大小。<code>(邻接矩阵或者邻接表存储)</code></li><li>其次，还需要一个<code>bool数组</code>判断那些点已经确定最短长度，那些点没有确定。<code>int数组</code>记录距离<code>(在算法执行过程可能被多次更新)</code>。</li><li>需要<code>优先队列</code>加入<code>已经确定点的周围点</code>。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。(优化后)</li></ol><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>&emsp;&emsp;在上一篇文章当中我们曾经说过Bellman-ford算法本质上其实是动态规划算法，我们的状态就是每个点的最短距离，策略就是可行的边，由于一共最多要松弛V-1次，所以整体的算法复杂度很高。当我们用队列维护可以松弛的点之后，就将复杂度降到了<br>$O(kE)$，也就是spfa算法。<br>&emsp;&emsp;Dijkstra算法和Bellman-ford算法虽然都是最短路算法，但是核心的逻辑并不相同。Dijkstra算法的底层逻辑是贪心，也可以理解成贪心算法在图论当中的使用。<br>&emsp;&emsp;其实Dijstra算法和Bellman-ford算法类似，也是一个松弛的过程。即一开始的时候除了源点s之外，其他的点的距离都设置成无穷大，我们需要遍历这张图对这些距离进行松弛。所谓的松弛也就是要将这些距离变小。假设我们已经求到了两个点u和v的距离，我们用<br>dis[u]表示u到s的距离，dis[v]表示v的距离。</p><p>&emsp;&emsp;假设我们有dis[u] &lt; dis[v]，也就是说u离s更近，那么我们接下来要用一个新的点去搜索松弛的可能，u和v哪一个更有可能获得更好的结果呢？当然是u，所以我们选择u去进行新的松弛，这也就是贪心算法的体现。如果这一层理解了，算法的整个原理也就差不多<br>了。</p><p>我们来整理一下思路来看下完整的算法流程：</p><ol><li>我们用一个数组dis记录源点s到其他点的最短距离，起始时dis[s] = 0，其他值设为无穷大</li><li>我们从未访问过的点当中选择距离最小的点u，将它标记为已访问</li><li>遍历u所有可以连通的点v，如果dis[v] &lt; dis[u] + l[u] [v]，那么更新dis[v]</li><li>重复上述2，3两个步骤，直到所有可以访问的点都已经访问过</li></ol><p>怎么样，其实核心步骤只有两步，应该很好理解吧？我找到了一张不错的动图，大家可以根据上面的流程对照一下动图加深一下理解。</p><p><img src="/img/short-path/dijkstra.gif" alt="如图"><br>我们根据原理不难写出代码：<br>C++版本：<br><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> g[N][N];<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">int</span> st[N];<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);        dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp;(t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j])) &#123;                t = j;            &#125;        &#125;        st[t] = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            dis[j] = min(dis[j], dis[t] + g[t][j]);        &#125;    &#125;        <span class="hljs-keyword">if</span>(dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dis[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);    <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        g[a][b] = min(g[a][b], c);    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, dijkstra());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><p>Pyhon版本：<br><pre><code class="hljs Python">INF = sys.maxsizeedges = [[]] <span class="hljs-comment"># 邻接表存储边</span>dis = [] <span class="hljs-comment"># 记录s到其他点的距离</span>visited = &#123;&#125; <span class="hljs-comment"># 记录访问过的点</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    mini = INF    u = <span class="hljs-number">0</span>    flag = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 遍历所有未访问过点当中距离最小的</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V):        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited <span class="hljs-keyword">and</span> dis[i] &lt; mini:            mini, u = dis[i], i            flag = <span class="hljs-literal">True</span>                <span class="hljs-comment"># 如果没有未访问的点，则退出</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:        <span class="hljs-keyword">break</span>         visited[u] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        dis[v] = <span class="hljs-built_in">min</span>(dis[v], dis[u] + l)</code></pre></p><p>&emsp;&emsp;虽然我们已经知道算法没有反例了，但是还是可以思考一下。主要的点在于我们每次都选择未访问的点进行松弛，有没有可能我们松弛了一个已经访问的点，由于它已经被松弛过了，导致后面没法拿来松弛其他的点呢？<br>&emsp;&emsp;其实是不可能的，因为我们每次选择的都是距离最小的未访问过的点。假设当前的点是u，我们找到了一个已经访问过的点v，是不可能存在dis[u] + l &lt; dis[v]的，因为dis[v]必然要小于dis[u]，v才有可能先于u访问。但是这有一个前提，就是每条边的长度不<br>能是负数。</p><h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><p>&emsp;&emsp;和Bellman-ford算法一样，Dijkstra算法最大的问题同样是复杂度。我们每次选择一个点进行松弛，选择的时候需要遍历一遍所有的点，显然这是非常耗时的。复杂度应该是$O(V^2 + E)$，这里的E是边的数量，Dijkstra中每个点只会松弛一次，也就意味着每条<br>边最多遍历一次。<br>&emsp;&emsp;我们观察一下会发现，外面这层循环也就算了，里面这层循环很没有必要，我们只是找了一个最值而已。完全可以使用数据结构来代替循环查询，维护最值的场景我们也已经非常熟悉了，当然是使用优先队列。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>一般从选定点开始抛入优先队列。（路径一般为0），<code>bool数组</code>标记0的位置(最短为0) , 然后0周围连通的点抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内<code>(如果小于就更新，大于就不动，初始第一次是无穷肯定会更新)</code>，第一次就结束了</li><li>从队列中抛出距离最近的那个点B（第一次就是0周围邻居）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为true，<code>并且将这个点的邻居加入队列</code>(下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过B点计算各个位置的<br>长度，如果小于则更新！<br><img src="/img/short-path/dijkstra1.png" alt="如图"></li><li>重复二的操作，直到所有点都确定。<br><img src="/img/short-path/dijkstra2.png" alt="如图"></li></ul><p><a class="btn" href="https://www.acwing.com/problem/content/description/852/" title="title">参考题目</a></p><p>C++版本：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;<span class="hljs-keyword">int</span> dist[N], heap[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span> (heap.size())    &#123;        PII t = heap.top();        heap.pop();        <span class="hljs-keyword">int</span> ver = t.second; <span class="hljs-comment">//distance = t.first;</span>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;        st[ver] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])        &#123;            <span class="hljs-keyword">int</span> j = e[i];            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] = dist[ver] + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dist[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dijkstra());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>Pyhon版本：</p><pre><code class="hljs Python"><span class="hljs-keyword">import</span> heapq<span class="hljs-keyword">import</span> sys<span class="hljs-comment"># 优先队列</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, item, priority</span>):</span>        <span class="hljs-comment"># 传入两个参数，一个是存放元素的数组，另一个是要存储的元素，这里是一个元组。</span>        <span class="hljs-comment"># 由于heap内部默认由小到大排，所以对priority取负数</span>        heapq.heappush(self._queue, (-priority, self._index, item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[-<span class="hljs-number">1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self._queue) == <span class="hljs-number">0</span>que = PriorityQueue()INF = sys.maxsizeedges = [[], [[<span class="hljs-number">2</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">14</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">15</span>]], [[<span class="hljs-number">1</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">11</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>]], [[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>]]] <span class="hljs-comment"># 邻接表存储边</span>dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)] <span class="hljs-comment"># 记录s到其他点的距离</span>s = <span class="hljs-number">1</span>que.push(s, <span class="hljs-number">0</span>)dis[s] = <span class="hljs-number">0</span>visited = &#123;&#125;<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():    u, d = que.pop()    <span class="hljs-keyword">if</span> d != dis[u]:        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            que.push(v, dis[v])print(dis)</code></pre><p>Java版本：<br><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<span class="hljs-keyword">import</span> java.util.Comparator;<span class="hljs-keyword">import</span> java.util.PriorityQueue;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dijkstra</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">int</span> x; <span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> lenth;<span class="hljs-comment">//长度</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> lenth)</span> </span>&#123;<span class="hljs-keyword">this</span>.x=x;<span class="hljs-keyword">this</span>.lenth=lenth;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//记录权值，顺便记录链接情况，可以考虑附加邻接表</span>initmap(map);<span class="hljs-comment">//初始化</span><span class="hljs-keyword">boolean</span> bool[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//判断是否已经确定</span><span class="hljs-keyword">int</span> len[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">6</span>];<span class="hljs-comment">//长度</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;len[i]=Integer.MAX_VALUE;&#125;Queue&lt;node&gt;q1=<span class="hljs-keyword">new</span> PriorityQueue&lt;node&gt;(com);len[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//从0这个点开始</span>q1.add(<span class="hljs-keyword">new</span> node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//计算执行了几次dijkstra</span><span class="hljs-keyword">while</span> (!q1.isEmpty()) &#123;node t1=q1.poll();<span class="hljs-keyword">int</span> index=t1.x;<span class="hljs-comment">//节点编号</span><span class="hljs-keyword">int</span> length=t1.lenth;<span class="hljs-comment">//节点当前点距离</span>bool[index]=<span class="hljs-keyword">true</span>;<span class="hljs-comment">//抛出的点确定</span>count++;<span class="hljs-comment">//其实执行了6次就可以确定就不需要继续执行了  这句可有可无，有了减少计算次数</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;map[index].length;i++)&#123;<span class="hljs-keyword">if</span>(map[index][i]&gt;<span class="hljs-number">0</span>&amp;&amp;!bool[i])&#123;node node=<span class="hljs-keyword">new</span> node(i, length+map[index][i]);<span class="hljs-keyword">if</span>(len[i]&gt;node.lenth)<span class="hljs-comment">//需要更新节点的时候更新节点并加入队列</span>&#123;len[i]=node.lenth;q1.add(node);&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;System.out.println(len[i]);&#125;&#125;<span class="hljs-keyword">static</span> Comparator&lt;node&gt;com=<span class="hljs-keyword">new</span> Comparator&lt;node&gt;() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(node o1, node o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o1.lenth-o2.lenth;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initmap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] map)</span> </span>&#123;map[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]=<span class="hljs-number">3</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>;map[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;map[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">3</span>;&#125;&#125;</code></pre></p><p>&emsp;&emsp;这里用visited来判断是否之前访问过的主要目的是为了防止负环的产生，这样程序会陷入死循环，如果确定程序不存在负边的话，其实可以没必要判断。因为先出队列的一定更优，不会存在之后还被更新的情况。如果想不明白这点加上判断也没有关系。<br>&emsp;&emsp;我们最后分析一下复杂度，每个点最多用来松弛其他点一次，加上优先队列的调整耗时，整体的复杂度是$O(V \log V+E)$，比之前$O(V^2+E)$的复杂度要提速了很多，非常适合边很多，点相对较少的图。有时候spfa卡时间了，我们会选择Dijkstra。</p>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径之bellman-ford&amp;SPFA</title>
    <link href="/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/"/>
    <url>/2020/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84(1)/</url>
    
    <content type="html"><![CDATA[<p>最短路径算法</p><a id="more"></a><h1 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h1><p>&emsp;&emsp;最短路问题也属于图论算法之一，解决的是在一张有向图当中点与点之间的最短距离问题。最短路算法有很多，比较常用的有bellman-ford、dijkstra、floyd、spfa等等。这些算法当中主要可以分成两个分支，其中一个是<br>bellman-ford及其衍生出来的spfa，另外一个分支是dijkstra以及其优化版本。floyd复杂度比较高，一般不太常用。<br>&emsp;&emsp;这次就先简单说一下bellman-ford和SPFA算法。</p><h1 id="First"><a href="#First" class="headerlink" title="First"></a>First</h1><h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>我们要对一张有向图计算最短路，那么我们首先要做的就是将一张图存储下来。关于图的存储的数据结构，常用的方法有很多种。最简单的是邻接矩阵，所谓的邻接矩阵就是用一个二维矩阵存储每两个点之间的距离。如果两个点之间没有边相连，那么设为无穷大。</p><p><img src="/img/short-path/save-Graph.png" alt="如图"></p><p>&emsp;&emsp;这种方法的好处就是<code>非常直观</code>，实现也很简单，但是这中方法所消耗的时间复杂度也是很高的 $V^2$,这里的V指的是顶点的数量当顶点的数量稍稍大一些之后，带来的开销是非常庞大的。一般情况下我们的图的边的密集程度是不高<br>的，也就是说大量点和点之间没有边相连，我们浪费了很多空间。<code>一般情况下当边是顶点的10倍时(也就是稠密图)我们选择这种存图方式,此外我们就选择邻接表的方式来存储稀疏图</code></p><p>&emsp;&emsp;所谓的邻接表也就是说我们把顶点一字排开存入数组当中，每个顶点对应一条链表。这条链表当中存储了这个点可以到达的其他点的信息。邻接表的好处是可以最大化利用空间，有多少条边存储多少信息。但是也有缺点，除了实现稍稍复<br>杂一点之外，另外一个明显的缺点就是我们<code>没办法直接判断两点之间是否有边存在</code>，必须要遍历链表才可以。除了邻接矩阵和邻接表之外，还有一些其他的数据结构可以完成图的存储。比如前向星、边集数组、链式前向星等等。这些数据结构并没有<br>比邻接表有质的突破，对于非算法竞赛同学来说，能够熟练用好邻接表也就足够了。</p><h2 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman-ford算法"></a>bellman-ford算法</h2><p>&emsp;&emsp;刚才上面描述当中提到的算法除了floyd算法是计算的所有点对之间的最短距离之外，其他算法解决的都是单源点最短路的问题。所谓的单源点可以简单理解成单个的出发点，也就是说我们求的是从图上的一个点出发去往其他每个点的最短<br>距离。既然如此，我们的出发点以及到达点都是确定的，不确定的只是它们之间的距离而已。</p><p>&emsp;&emsp;为什么我们会将bellman-ford算法和dijkstra算法区分开呢？因为两者的底层逻辑是不同的，bellman-ford算法的底层逻辑是动态规划， 而dijkstra算法的底层逻辑是贪心。</p><p>&emsp;&emsp;bellman-ford算法的得名也和人有关，我们之前在介绍KMP算法的时候曾经说过。由于英文表意能力不强，所以很多算法和公式都是以人名来取名。bellman-ford是Richard Bellman 和 Lester Ford 分别发表的，实际上还有一个<br>叫Edward F. Moore也发表了这个算法，所以有的地方会称为是Bellman-Ford-Moore 算法。</p><p>&emsp;&emsp;算法的原理非常简单，利用了动态规划的思想来维护源点出发到各个点的最短距离。</p><p>&emsp;&emsp;它的核心思维是松弛，所谓的松弛可以理解成找到了更短的路径对原路径进行更新。对于一个有V个节点的有向图进行V-1轮松弛，从而找到源点到所有点的最短距离。</p><p>&emsp;&emsp;初始的时候我们会用一个数组记录源点到其他所有点的距离，对于与源点直接相连的点来说，这个距离就是它和源点的距离否则则是无穷大。对于第一轮松弛来说，我们寻找的是源点出发经过一个点到达其他点的最短距离。我们用s代表源<br>点，我们寻找的就是s经过点a到达点b，使得距离小于s直接到b的距离。</p><p>&emsp;&emsp;第二轮松弛就是寻找的s经过两个点到达第三个点的最短距离，同理，对于一个有V个点的图来说，两个点之间最多经过V-1个点，所以我们需要V-1轮松弛操作。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;    <span class="hljs-keyword">for</span> (var j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;//对m条边进行循环      var edge = edges[j];      // 松弛操作      <span class="hljs-keyword">if</span> (distance[edge.to] &gt; distance[edge.<span class="hljs-keyword">from</span>] + edge.weight )&#123;         distance[edge.to] = distance[edge.<span class="hljs-keyword">from</span>] + edge.weight;      &#125;    &#125;&#125;</code></pre><p>&emsp;&emsp;Bellman-ford的算法很好理解，实现也不难，但是它有一个缺点就是复杂度很高。我们前面说了一共需要V-1轮松弛，每一轮松弛我们都需要遍历E条边，所以整体的复杂度是$O(VE)$，E指的是边的数量。想想看，假设对于一个有1w个顶点，10w条边的<br>图来说，这个算法是显然无法得出结果的。</p><p>&emsp;&emsp;所以为了提高算法的可用性，我们必须对这个算法进行优化。我们来分析一下复杂度巨大的原因，主要在两个地方，一个地方是我们松弛了V-1次，另外一个地方是我们枚举了所有的边。松弛V-1次是不可避免的，因为可能存在极端的情况需要V-1次松弛<br>才可以达成。但我们每次都枚举了所有的边感觉有点浪费，因为其中大部分的边是不可能达成新的松弛的。那有没有办法我们筛选出来可能构成新的松弛的边呢？</p><p>&emsp;&emsp;针对这个问题的思考和优化引出了新的算法——spfa。</p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>&emsp;&emsp;SPFA算法的英文全称是Shortest Path Faster Algorithm，从名字上我们就看得出来这个算法的最大特点就是快。它比Bellman-ford要快上许多倍，它的复杂度是$O(kE)$，这里的k是一个小于等于2的常数。</p><p>&emsp;&emsp;SPFA的核心原理和Bellman-ford算法是一样的，也是对点的松弛。只不过它优化了复杂度，优化的方法也很简单，用一个队列维护了可能存在新的松弛的点。这样我们每次从这些点出发去寻找其他可以松弛的点加入队列，这里面的原理<br>很简单，只有被松弛过的点才有可能去松弛其他的点。</p><p>&emsp;&emsp;SPFA的代码也很短，实现起来难度很低，单单从代码上来看和普通的宽搜区别并不大。</p><p>Python版本：<br><pre><code class="hljs Python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queueque = Queue()<span class="hljs-comment"># 邻接表存储边</span>edges = [[]]<span class="hljs-comment"># 维护是否在队列当中</span>visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V)]dis = [sys.maxsize <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V)]dis[s] = <span class="hljs-number">0</span>que.put(s)visited[s] = <span class="hljs-literal">True</span><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.emtpy():    u = que.get()    <span class="hljs-keyword">for</span> v, l <span class="hljs-keyword">in</span> edges[u]:        <span class="hljs-keyword">if</span> dis[u] + l &lt; dis[v]:            dis[v] = dis[u] + l            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[v]:                que.add(v)                visited[v] = <span class="hljs-literal">True</span>                    visited[u] = <span class="hljs-literal">False</span></code></pre></p><p><a class="btn" href="https://www.acwing.com/problem/content/853/" title="title">参考题目</a></p><p>C++版本：<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> h[N], e[N], ne[N], w[N], idx;<span class="hljs-keyword">int</span> dis[N];<span class="hljs-keyword">bool</span> st[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    q.push(<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> ( !q.empty() ) &#123;        <span class="hljs-keyword">int</span> t = q.front();        q.pop();                st[t] = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;            <span class="hljs-keyword">int</span> j = e[i];                        <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i]) &#123;                dis[j] = dis[t] + w[i];                st[j] = <span class="hljs-literal">true</span>;                q.push(j);            &#125;        &#125;    &#125;        <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[n];    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);        <span class="hljs-keyword">while</span> ( m -- ) &#123;        <span class="hljs-keyword">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        add(a, b, c);    &#125;        <span class="hljs-keyword">int</span> t = spfa();        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, t);&#125;</code></pre></p><p>Python版；<br><pre><code class="hljs python">n, m, k = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<span class="hljs-comment">## 用一个list 记录所有边的信息即可</span>g = []dist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):    a, b, w = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())    g.append([a, b, w])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bellman_ford</span>():</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>    <span class="hljs-comment">## 循环几次代表最多用几条边</span>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):        <span class="hljs-comment">## 必须backup 防止在过程中会更新dist里面的数据导致并不是最多k条边</span>        backup = dist[:]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):            a, b, w = g[i][<span class="hljs-number">0</span>], g[i][<span class="hljs-number">1</span>], g[i][<span class="hljs-number">2</span>]            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w)bellman_ford()print(dist[n] <span class="hljs-keyword">if</span> dist[n] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;impossible&quot;</span>)</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公告 | 🔊 置顶</title>
    <link href="/2020/09/15/%E7%BD%AE%E9%A1%B6/"/>
    <url>/2020/09/15/%E7%BD%AE%E9%A1%B6/</url>
    
    <content type="html"><![CDATA[<p>&emsp;</p><a id="more"></a><style>section {    width: 100%;    height: 100px;    /*border: 1px solid red;*/    display: flex;    justify-content: space-around;    align-items: center;}section .section_item {    /*border: 1px solid blue;*/    position: relative;    display: flex;    justify-content: center;    align-items: center;    transition: filter 0.5s, transform 0.5s;}section .section_item .a {    color: #ffffff;    font-size: 2vw;    top: 0;    opacity: 1;    transition: top 0.5s, opacity 0.5s;}section .section_item .a:nth-child(1) {    position: absolute;    clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%);}section .section_item .a:nth-child(2) {    position: relative;    clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%);}/*出发景深效果*/section:hover .section_item {    filter: blur(10px);    transform: scale(0.8);    transition: filter 0.5s, transform 0.5s;}/*对应取消景深效果*/section .section_item:hover {    filter: blur(0px);    transform: scale(1.1);    transition: filter 0.5s, transform 0.5s;}section .section_item:hover .a:nth-child(1) {    top: -40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item:hover .a:nth-child(2) {    top: 40px;    opacity: 0.5;    transition: top 0.5s, opacity 0.5s;}section .section_item a {    position: absolute;    color: #fff;    text-decoration: none;    opacity: 0;    transition: opacity 0.5s;}section .section_item a:hover {    text-decoration: underline;}section .section_item:hover a {    opacity: 1;    transition: opacity 0.5s;}.Photo img{    border-radius:25px;    box-shadow: 10px 10px 10px rgba(0,0,0,.5);    -moz-box-shadow: 10px 10px 10px rgba(0,0,0,.5) outset;    -webkit-box-shadow: 10px 10px 10px rgba(0,0,0,.5);}</style><p><div class = "Photo"></p><center>    <p class="count"></p>    <img src = "https://cdn.jsdelivr.net/gh/Wulnut/Figure/img/Top-2.jpg" alt = "photo" /></center><br><br><br><center><!-- 生老病死，衣食住行，这是我的奋斗，也是你的奋斗 -->一旦你决定好职业，你必须全心投入工作中，你必须爱你的工作，千万不要有怨言，你必须穷尽一生磨练技能，这就是成功的秘诀，也是让大家尊敬你的关键。</center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何配置与安装maven</title>
    <link href="/2020/07/11/maven%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/07/11/maven%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>介绍以下如何安装与配置maven</p><a id="more"></a><h1 id="一、-安装本地Maven"><a href="#一、-安装本地Maven" class="headerlink" title="一、 安装本地Maven"></a>一、 安装本地Maven</h1><ol><li><p>进入<a href="https://maven.apache.org/download.cgi">Apache maven官网</a>下载maven</p></li><li><p>点击左侧Download </p></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_download.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">下载</div></center><ol><li><p>点击这个连接然后下载</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_download2.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">下载</div></center></li><li><p>下载完成之后，任意找一个文件夹存入然后解压</p></li><li>然后就开始配置环境变量了<ul><li>系统变量：MAVEN_HOME = ..\apache-maven-3.63</li><li>系统变量：path: %MAVEN_HOME%\bin</li></ul></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_path3.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置变量</div></center><h1 id="二、配置settings文件"><a href="#二、配置settings文件" class="headerlink" title="二、配置settings文件"></a>二、配置settings文件</h1><ol><li>在你放置maven文件的文件夹里找到conf文件夹然后可以在conf文件夹中找到setting文件</li><li>找到第52行，这里是设置maven默认的默认本地仓库。<center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li></ol><ol><li>我们复制第53行</li></ol><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/path/to/local/repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>将它拿到注释外并将中间的内容改成你需要的路径，如图</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>F:/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre><p>注意这个repository需要自己建,这里的路径随便设置，注意这里是正斜杠</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo2.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning)</li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阿里云仓库 --&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-comment">&lt;!--或者--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre><ol><li><p>如图，要夹在两个mirrors标签之间</p><center> <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"  src="/img/maven_repo3.png"> <br> <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">配置</div></center></li><li><p>在最后配置jdk，也要夹在两个profiles标签之间</p></li></ol><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- java版本 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_repo4.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center><ol><li>配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功</li></ol><p>最后，如果你使用的idea作为Java的IDE， 我们是可以将idea的maven仓库设置为本地仓库。<br>File -&gt; Build, Execution, Deployment -&gt; Maven修在下面两个参数就可以了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/maven_idea.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">配置</div></center>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半年记</title>
    <link href="/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
    <url>/2020/07/02/%E5%8D%8A%E5%B9%B4%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>简单的总结一下这荒废的半个学期</p><a id="more"></a><h1 id="一切都是要从蝙蝠说起"><a href="#一切都是要从蝙蝠说起" class="headerlink" title="一切都是要从蝙蝠说起"></a>一切都是要从蝙蝠说起</h1><p>&emsp;&emsp;由于2019年起的一只蝙蝠，我们的生活出现了天翻地覆的变化。在家隔离遵守防疫要求，争取不给国家添乱。在家度过了我最为魔幻的一个寒假，虽然在家但是我丝毫没感受到无聊，相反还发生了很多有趣的事情，我觉得我有必要对期间发生的经过找时间好好记录一下。</p><h2 id="这可能是高中时所期盼的"><a href="#这可能是高中时所期盼的" class="headerlink" title="这可能是高中时所期盼的"></a>这可能是高中时所期盼的</h2><p>&emsp;&emsp;上高中的时候总想着能在大学过的舒服，还能有超长的假期，每次在寒暑假结束的时候大家总会调侃：“嗯你假期余额已不足请及时充值”。不过很对不这个恐怖故事真的出现了.</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear2.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><p>&emsp;&emsp;虽然没有上图那么恐怖，但是我寒假确实涨了不少这一涨就是一个学期。线下教学也随之敲定转为线上。刚开始上网课，还每天幻想<br>嗯等等3月份学校就会要我们回去了。但是在一次和周老师的聊天中得知广东那边的学校可能会在6月底开学，一开始对这个差异的消息还是还保持着<br>怀疑态度，每天上课老师也在和我们预测学校会在什么时候开学，武汉什么时候解封这样的话题。但是慢慢的，随着北师大说今年上半年不开学、听<br>到华科的朋友说他们辅导员发长文警告那些期待等回学校再补课的同学要好好学习的截图，时我才意识到今年武汉上边年不开学，可能是真的了做好打持久战的准备是一定的了。<br>&emsp;&emsp;果然随着所有课程全部转入线上教学的开始，上半年在家学习也就真的出现了。但是我对线上教学有着强烈的抵触情绪，根本没有想跟着老师的节奏好好在家里学习本学期既定的课程，“我上不了985，我看985的网课还不行么”这句话虽然搞笑，但确十分真实。线上上课老师和学校也是绞尽脑汁，督促学生好好在线上学习，不要逃课。可是呢？有些老师总喜欢用着骗三岁小孩的话来骗我们，制定了一些十分好笑的条条框框，什么早自习打卡啊、晚自习打卡啊等等吧。打完卡再去睡觉然后等到开课在起床这样操作，不用说也有人会做。但是有些人就是爱与面子，说自己按时打卡学习早读，晚自习。当然我也认识真正这样做的人。为此我也背上了逃早自这样的搞笑的名号。嗯大三了我看大家谁，睡得香~<br>&emsp;&emsp;虽然说我不想听老师线上的讲课，但是我又害怕错过一些知识。说白了就是“贱”，上网课就挂在那里假惺惺的听老师的讲课然后把声音调到最小，自己看各大名校的网课视频。这也算是我在名校学习了吧Hhhh。不得不说中科大概率真香，听课真如醍醐灌顶一样，想我基础这么差的，在学习玩之后也能明白个八九不离十，还有翁恺的程序课，不说了质量真的高，比上课讲所谓的算法题要实在的多，带你一步一步实现一个小小的项目，并学习其中的一些关键词和用法。比上课听理论，缺乏实践要来的实在的多，虽然不能说我做题一定能做对，但是我用一定用的恰到好处。<br>&emsp;&emsp;当然也是由于课程安排的原因周么也就只能休息一天，不过我大部分时间也是花在了学习网课上了，其实去完成自己的兴趣也是极少<br>并没有我想的那种可以搞搞别的事情，学习一下新的知识。也不知道该怎么形容，新的看的眼馋，旧也不想丢。两手抓，最终还是没干成一样。</p><h2 id="在家时间过的真的很快"><a href="#在家时间过的真的很快" class="headerlink" title="在家时间过的真的很快"></a>在家时间过的真的很快</h2><p>&emsp;&emsp;不得不说在家学习的时间过的真的很快虽然天天在上课，但是循环往复时间也就一下没了。到了5月份参加了一些无聊的比赛，每天熬夜到深夜，感觉自己很充实每天都很忙，要做好多事情。但是呢其实我啥也没干成，自己还累的够呛。感觉那段时间自己写了7、8万字，每天都在对着键盘打字。因为时间紧迫，外加上学长的催促。就想机器一样每天都在赶工期完成以下我都不知道我在干什么的东西。(退坑了退坑了，后面不能再参加了)<br>&emsp;&emsp;晃一晃这个学期就没几周了，扫清了比赛的事情之后就是专心的学习，我尝试认真的听老师上课，但是我还是放弃了。上一次课3、4<br>个小时的煎熬，虽然老师讲的很拖沓，但是知识含量太高一下子真的接受不了。还是自己看吧….</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear3.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;当然这🐕学习通，真是想个毒瘤一样。学习通上的成堆的视频，都要计入平时分今年平时分还是55开(上香)。我也就开始了疯狂的补补课模式，可能是我高估了学校期末考试的难度。总感觉自己的掌握程度不够，在文库找题做，针对知识点练习一下。我也很离奇的开始梳理知识结构因为我是真的觉得学的知识很乱，感觉没有形成知识体系。但是目前来说到现在我都没有形成知识体系。</p><h2 id="都是大佬"><a href="#都是大佬" class="headerlink" title="都是大佬"></a>都是大佬</h2><p>&emsp;&emsp;也就预习了尽一个月吧，中途周末实在是不行听课，就开车出去玩了一下。还是很开心的~然后就开始期末考试了，有人就喜欢🐕叫</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear4.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>当然我也是个儒雅随和的人，不和他计较。有冇搞错，管你咩事。我也在每次出成绩之后问了一下谁是最高分，我也没有听到你的名字呀。还专门买课本，在我这种垃圾面前卖弄自己了解到的知识。知识也分高低贵贱？</p><p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/halfyear5.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">恐怖故事</div></center><br>&emsp;&emsp;我也很庆幸我有一些很要好的朋友，和三个优秀的室友。虽然各有专攻但是大家在一起交流总是很快乐的。在不断学习的过程中，有人愿你和你解释交流，我觉得是一件很美好的事情。而不是自己守着自己所谓的优势，谦卑谦卑再谦卑。这也是我慢慢明白的，不是因为你知道的有多少，懂得有多少。我才会说你牛逼是大佬，你出来溜溜交流一下，光说不练假把式嘛，这一下子便高判立下。这个月我也感觉自己实在是浮躁，以前都说我浮躁，但是我总是不明白浮躁到是为什么。这个假期我也好像慢慢明白理解所谓的浮躁。脚踏实地，似乎才是最难实现的东西。为了一些论文<br>每天忙活，似乎还不如早点开始学习专业方向。认真学习一下什么是机器学习。复制百度百科我们谁都会。</p><p>&emsp;&emsp;先就说到这吧</p>]]></content>
    
    
    <categories>
      
      <category>day</category>
      
    </categories>
    
    
    <tags>
      
      <tag>day</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL入门训练题</title>
    <link href="/2020/05/25/sql%E8%AE%AD%E7%BB%83/"/>
    <url>/2020/05/25/sql%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>sql训练题</p><p><a href="https://www.jianshu.com/p/476b52ee4f1b">https://www.jianshu.com/p/476b52ee4f1b</a></p><a id="more"></a><h2 id="数据表介绍"><a href="#数据表介绍" class="headerlink" title="数据表介绍"></a>数据表介绍</h2><p>—1.学生表<br>Student(SId,Sname,Sage,Ssex)<br>—SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别</p><p>—2.课程表<br>Course(CId,Cname,TId)<br>—CId 课程编号,Cname 课程名称,TId 教师编号</p><p>—3.教师表<br>Teacher(TId,Tname)<br>—TId 教师编号,Tname 教师姓名</p><p>—4.成绩表<br>SC(SId,CId,score)<br>—SId 学生编号,CId 课程编号,score 分数</p><h2 id="学生表-Student"><a href="#学生表-Student" class="headerlink" title="学生表 Student"></a>学生表 Student</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sname <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),Sage datetime,Ssex <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-12-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-12-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-01-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;09&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span> , <span class="hljs-string">&#x27;2017-12-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;10&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2017-12-25&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;11&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span> , <span class="hljs-string">&#x27;2012-06-06&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span> , <span class="hljs-string">&#x27;赵六&#x27;</span> , <span class="hljs-string">&#x27;2013-06-13&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;13&#x27;</span> , <span class="hljs-string">&#x27;孙七&#x27;</span> , <span class="hljs-string">&#x27;2014-06-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);</code></pre><h2 id="科目表-Course"><a href="#科目表-Course" class="headerlink" title="科目表 Course"></a>科目表 Course</h2><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">SId</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),CId <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>),score <span class="hljs-built_in">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);</code></pre><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><ol><li>查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数<br>1.1 查询同时存在” 01 “课程和” 02 “课程的情况</li></ol><p>1.2 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null )</p><p>1.3 查询不存在” 01 “课程但存在” 02 “课程的情况</p><ol><li><p>查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</p></li><li><p>查询在 SC 表存在成绩的学生信息</p></li><li><p>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</p></li></ol><p>4.1 查有成绩的学生信息</p><ol><li><p>查询「李」姓老师的数量</p></li><li><p>查询学过「张三」老师授课的同学的信息</p></li><li><p>查询没有学全所有课程的同学的信息</p></li><li><p>查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息</p></li><li><p>查询和” 01 “号的同学学习的课程 完全相同的其他同学的信息</p></li><li><p>查询没学过”张三”老师讲授的任一门课程的学生姓名</p></li><li><p>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</p></li><li><p>检索” 01 “课程分数小于 60，按分数降序排列的学生信息</p></li><li><p>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</p></li><li><p>查询各科成绩最高分、最低分和平均分：</p></li><li><p>以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</p></li><li><p>及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</p></li><li><p>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺</p></li><li><p>按各科成绩进行排序，并显示排名， Score 重复时合并名次</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时保留名次空缺</p></li><li><p>查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</p></li><li><p>统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</p></li><li><p>查询各科成绩前三名的记录</p></li><li><p>查询每门课程被选修的学生数</p></li><li><p>查询出只选修两门课程的学生学号和姓名</p></li><li><p>查询男生、女生人数</p></li><li><p>查询名字中含有「风」字的学生信息</p></li><li><p>查询同名同性学生名单，并统计同名人数</p></li><li><p>查询 1990 年出生的学生名单</p></li><li><p>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</p></li><li><p>查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩</p></li><li><p>查询课程名称为「数学」，且分数低于 60 的学生姓名和分数</p></li><li><p>查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</p></li><li><p>查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数</p></li><li><p>查询不及格的课程</p></li><li><p>查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名</p></li><li><p>求每门课程的学生人数</p></li><li><p>成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</p></li><li><p>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</p></li><li><p>查询每门功成绩最好的前两名</p></li><li><p>统计每门课程的学生选修人数（超过 5 人的课程才统计）。</p></li><li><p>检索至少选修两门课程的学生学号</p></li><li><p>查询选修了全部课程的学生信息</p></li><li><p>查询各学生的年龄，只按年份来算</p></li><li><p>按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</p></li><li><p>查询本周过生日的学生</p></li><li><p>查询下周过生日的学生</p></li><li><p>查询本月过生日的学生</p></li><li><p>查询下月过生日的学生</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑规则总结</title>
    <link href="/2020/05/23/logist/"/>
    <url>/2020/05/23/logist/</url>
    
    <content type="html"><![CDATA[<p>简单总结逻辑推理规则与规律</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>&emsp;&emsp;由于数字逻辑种得推理规则与离散数学中得推理规则几乎是一模一样得。<br>对此讲有关逻辑推理部分进行总结。</p><h1 id="数字逻辑与离散数学"><a href="#数字逻辑与离散数学" class="headerlink" title="数字逻辑与离散数学"></a>数字逻辑与离散数学</h1><div class="table-container"><table><thead><tr><th>数字逻辑</th><th>离散数学</th></tr></thead><tbody><tr><td>或：$A$ $\cdot$  $B$</td><td>或: A $ \and B$</td></tr><tr><td>与: $A+B$</td><td>与: A $  \or B$</td></tr><tr><td>非:   $\overline{A}$</td><td>非: $ \neg A$</td></tr></tbody></table></div><h1 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h1><h2 id="基本公理"><a href="#基本公理" class="headerlink" title="基本公理"></a>基本公理</h2><ul><li>交换律：$A + B = B + A$   $or$  $A \cdot B = B \cdot A$</li><li>结合率：$(A + B)+C = A+(A+B)$   $or$   $(A \cdot B) \cdot C = A \cdot (B \cdot C)$</li><li>分配率：$A + (B \cdot C) = (A + B) \cdot (A + C)$    $or$   $A \cdot(B + C) = A \cdot B + A \cdot C$</li><li>$0-1$律：$A + 0 = A$  $or$  $A \cdot 1 = A$  $or$  $A + 1 = 1$  $or$  $A \cdot 0 = 0$</li><li>互补律：$\overline{A} + A = 1$  $or$  $\overline{A} \cdot A = 0$</li></ul><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><ul><li>定理1： $0 + 0 = 0$ 、$0 + 1 = 1$、 $1 + 0 = 1$、 $1 + 1 = 1$、$0 \cdot 0 = 0$、$0 \cdot 1 = 0$、 $1 \cdot 0 = 0$、 $1 \cdot 1 = 1$</li><li>重叠律： $A + A = A$   $or$  $A \cdot A = A$</li><li>吸收率： $A + A \cdot B = A$  $or$  $A \cdot(A + B) = A$</li><li>消因子法: $A + \overline{A} \cdot B = A + B$  $or$  $A \cdot(\overline{A} + B) = A \cdot B$</li><li>并项法： $A \cdot B + A \cdot \overline{B} = A$  $or$  $(A + B) \cdot (A + \overline{B}) = A$</li><li>消项法： $A \cdot B + \overline{A} \cdot C + B \cdot C = A \cdot B + \overline{A} \cdot C$  $or$  $(A + B) \cdot (\overline{A} + C) \cdot(B + C) = (A + B) \cdot (\overline{A} + C)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快读</title>
    <link href="/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"/>
    <url>/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>快读的一些方法</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在做数据结构、算法题的时候会遇见比较大的数，有的时候数据大小已经超过了int所能储存的范围，这样的大数如果比较多情况下如果使用普通的输入或者输出，超时就可能会发生，如果出现这样的错误，在算法时间复杂度没有问题的前提下出现这样的问题是非常令人头疼的一件事情。</p><p>这里我将从Java和C++两中语言入手，在减少这样的问题出现</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一、StreamTokenizer实现快速输入</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;</code></pre><p>定义如下：</p><pre><code class="hljs java">StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));</code></pre><p>StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：!@#$%^&amp;*()[]{})无法识别，会显示null</p><p>StreamTokenizer可以<strong>获取输入</strong>流并根据空格和回车分割成Token（标记），用nextToken方法读取下一个标记 </p><p>如果标记是字符串，用st.sval获取标记，如果是数字用st.nval获取标记，st.navl是double类型</p><p>示例</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));        st.nextToken();        String s=st.sval;        System.out.println(s);        st.nextToken();        <span class="hljs-keyword">double</span> n=st.nval;        System.out.println(n);        <span class="hljs-comment">/**输入内容</span><span class="hljs-comment">         * hollow 1233</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow</span><span class="hljs-comment">         * 1233.0</span><span class="hljs-comment">         */</span>            &#125; &#125;</code></pre><p>二、BufferedReader实现快速输入读一行</p><p>需要导入的jar</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;</code></pre><p>定义：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</code></pre><p>常用方法：</p><pre><code class="hljs java">inBuff.readLine()<span class="hljs-comment">//读取一行内容，返回字符串</span></code></pre><p>实例：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        String s=inBuff.readLine();        System.out.println(<span class="hljs-string">&quot;有问题吗&quot;</span>+s+<span class="hljs-string">&quot;没有吧&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world!</span><span class="hljs-comment">         * 有问题吗hollow world!没有吧</span><span class="hljs-comment">         */</span></code></pre><p>三、PrintWriter实现快速输出</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;</code></pre><p>定义如下：</p><pre><code class="hljs java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));</code></pre><p>常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 输出分为两步：</span><span class="hljs-comment">// 1、先通过print()或println()方法把需要输出的内容放入缓冲区，</span><span class="hljs-comment">// 2、然后通过flush()将缓冲区的内容输出到控制台</span>print(需要输出的内容)<span class="hljs-comment">//不换行输出，只是把需要的内容放入缓冲，</span>println(需要输出的内容)<span class="hljs-comment">//换行输出</span>flush()<span class="hljs-comment">//刷新缓冲区，把缓冲区的内容输出到控制台，</span></code></pre><p>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> CCPC;<span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));        String s=<span class="hljs-string">&quot;hollow world&quot;</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">12344</span>;        out.print(s+<span class="hljs-string">&quot; &quot;</span>+i);        out.flush();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 输出内容</span><span class="hljs-comment">         * hollow world 12344</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre><p>一个例子<br><strong>一般建议使用BufferedRead()</strong><br><pre><code class="hljs java"><span class="hljs-comment">// https://www.acwing.com/problem/content/790/</span><span class="hljs-comment">// 使用BufferedReader读入的方法</span><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex4</span> </span>&#123;    <span class="hljs-comment">// 全局变量</span><span class="hljs-comment">//    static int N = 100010;  // 数据规模为 10w</span><span class="hljs-comment">//    static int[] arr = new int[N];</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-comment">// parseInt将字符串转为int</span>        <span class="hljs-comment">// parseDouble将字符转为double</span>        <span class="hljs-keyword">int</span> n = Integer.parseInt(reader.readLine());        String[] arrStr = reader.readLine().split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;            arr[i] = Integer.parseInt(arrStr[i]);        &#125;        reader.close();        <span class="hljs-keyword">long</span> ans = mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        System.out.println(ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> res = mergesort(arr, l, mid) + mergesort(arr,mid + <span class="hljs-number">1</span>, r);        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k ++] = arr[i ++];            <span class="hljs-keyword">else</span> &#123;                res += mid - i + <span class="hljs-number">1</span>;                temp[k ++] = arr[j ++];            &#125;        &#125;        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = arr[i ++];        <span class="hljs-keyword">while</span> (j &lt;=   r) temp[k ++] = arr[j ++];        <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) &#123;            arr[i] = temp[j];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="getchar读入"><a href="#getchar读入" class="headerlink" title="getchar读入"></a>getchar读入</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> , ch = getchar();    <span class="hljs-keyword">while</span>( !<span class="hljs-built_in">isdigit</span>( ch ) ) ch = getchar();    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">isdigit</span>( ch ) ) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span> , ch = getchar();    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>用时28.74s</p><h3 id="fread读入优化"><a href="#fread读入优化" class="headerlink" title="fread读入优化"></a>fread读入优化</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ibuf[<span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span>] , * s;    io()    &#123;        fread( s = ibuf , <span class="hljs-number">1</span> , <span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span> , <span class="hljs-built_in">stdin</span> );    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>( * s &lt; <span class="hljs-number">48</span> ) s++;        <span class="hljs-keyword">while</span>( * s &gt; <span class="hljs-number">32</span> )            u = u * <span class="hljs-number">10</span> + * s++ - <span class="hljs-number">48</span>;        <span class="hljs-keyword">return</span> u;    &#125;&#125; ip;</code></pre><p>用时1.535s</p><h3 id="当然如果觉得以上的方法比较麻烦可以："><a href="#当然如果觉得以上的方法比较麻烦可以：" class="headerlink" title="当然如果觉得以上的方法比较麻烦可以："></a>当然如果觉得以上的方法比较麻烦可以：</h3><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::ios::sync_with_stdio(<span class="hljs-literal">false</span>);</code></pre><p>通过对cin和cout的解除绑定可以达到和scanf于printf一样的速度有时候会更快</p><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><p><strong>cout</strong></p><p>用时102.2s</p><p><strong>printf</strong></p><p>用时27.36s</p><p><strong>puts（直接当字符串输出）</strong></p><p>用时2.001s</p><h3 id="putchar输出优化"><a href="#putchar输出优化" class="headerlink" title="putchar输出优化"></a>putchar输出优化</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);        x=-x;    &#125;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)        print(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);&#125;</code></pre><p>用时3.339s</p><h3 id="fwrite输出优化"><a href="#fwrite输出优化" class="headerlink" title="fwrite输出优化"></a>fwrite输出优化</h3><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">( <span class="hljs-keyword">register</span> T u )</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> * q = a;        <span class="hljs-keyword">if</span>( !u ) * t++ = <span class="hljs-number">48</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>( u &lt; <span class="hljs-number">0</span> )                * t++ = <span class="hljs-number">45</span> , u *= <span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span>( u ) * q++ = u % <span class="hljs-number">10</span> + <span class="hljs-number">48</span> , u /= <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>( q != a )                * t++ = * --q;        &#125;    &#125;</code></pre><p>用时0.6653s</p><p><strong>由此可以看出，fwrite对比其他读入方式有极大的差距</strong></p><p>不过由于一般输出量都比较小，所以输出优化意义不大</p><h2 id="inline-define-register"><a href="#inline-define-register" class="headerlink" title="inline,define,register"></a>inline,define,register</h2><p>register就是把东西放到寄存器里面</p><p>比如for( int i = 1 ; i &lt;= n ; i++ )</p><p>可以写成for( register int i = 1 ; i &lt;= n ; i++ )</p><p>但是这个不一定有用，因为这个int可能编译器会帮你放寄存器里面</p><p><strong>for register short可能比for register int慢，因为short的寄存器更少..</strong><br><strong>大家for循环里面还是int比较好</strong></p><p>register在大部分情况下（特别是开了O2的时候）并没有明显的优化效果，如果加错了反而可能负优化</p><p>如果一个简单函数调用次数很多，属于瓶颈，调用时的传参可能会大大影响程序效率</p><p>这种情况下可以把这个函数给inline掉</p><p>inline就是把一个函数内联，可以减少跳转和传参的代价</p><p>但是如果这个函数过于复杂，可能并不会inline，可以考虑<strong>attribute</strong> ( ( always_inline ) )或者手动展开，或者define掉（注意define别爆炸）</p><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/qq_40079933/article/details/79419065">https://blog.csdn.net/qq_40079933/article/details/79419065</a></li><li><a href="https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua">https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Text Format</title>
    <link href="/2020/05/05/scenes1/"/>
    <url>/2020/05/05/scenes1/</url>
    
    <content type="html"><![CDATA[<p>manim 入门</p><a id="more"></a><h1 id="Text-format"><a href="#Text-format" class="headerlink" title="Text format"></a>Text format</h1><pre><code class="hljs 注意```:">&#96;&#96;&#96;python3from big_ol_pile_of_manim_imports import *</code></pre><p>在第一行</p><h2 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h2><pre><code class="hljs python3">class WriteText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/WriteText.gif" alt=" "></p><pre><code class="hljs python3">class AddText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.add(text)        self.wait(3)</code></pre><p><img src="/img/AddText.gif" alt=" "></p><pre><code class="hljs python3">class Formula(Scene):     def construct(self):         formula &#x3D; TexMobject(&quot;This is a formula&quot;)        self.play(Write(formula))        self.wait(3)</code></pre><p><img src="/img/Formula.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $this is a formula$,            $$this is a formula$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText2(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText2.gif" alt=" "></p><pre><code class="hljs python3">class DisplayFormula(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\displaystyle\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/DisplayFormula.gif" alt=" "></p><pre><code class="hljs python3">class TextInCenter(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInCenter.gif" alt=" "></p><pre><code class="hljs python3">class TextOnTopEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnTopEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnBottomEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnBottomEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnRightEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnRightEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextOnLeftEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(LEFT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnLeftEdge.gif" alt=" "></p><pre><code class="hljs python3">class TextInUpperRightCorner(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP+RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInUpperRightCorner.gif" alt=" "></p><pre><code class="hljs python3">class TextInLowerLeftCorner(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;Text&quot;)         text.to_edge(LEFT+DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInLowerLeftCorner.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(0.25*UP)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/CustomPosition1.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(1*UP+1*RIGHT)        self.play(Write(textM),Write(textC))        self.wait(1)        textM.move_to(1*UP+1*RIGHT)         self.play(Write(textM))        self.wait(3)</code></pre><p><img src="/img/CustomPosition2.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.next_to(textC,LEFT,buff&#x3D;1)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition1.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP*0.1)        self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition2.gif" alt=" "></p><pre><code class="hljs python3">class RotateObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP)        textM.rotate(PI&#x2F;4) # &lt;- Radians        # You can use .rotate(45*DEGREES) too        self.play(Write(textM),Write(textC))        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI)        self.wait(2)</code></pre><p><img src="/img/RotateObject.gif" alt=" "></p><pre><code class="hljs python3">class FlipObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textM.flip(UP)        self.play(Write(textM))        self.wait(2)</code></pre><p><img src="/img/MirrorObject.gif" alt=" "></p><pre><code class="hljs python3">class SizeTextOnLaTeX(Scene):    def construct(self):        textHuge &#x3D; TextMobject(&quot;&#123;\\Huge Huge Text 012.\\#!?&#125; Text&quot;)        texthuge &#x3D; TextMobject(&quot;&#123;\\huge huge Text 012.\\#!?&#125; Text&quot;)        textLARGE &#x3D; TextMobject(&quot;&#123;\\LARGE LARGE Text 012.\\#!?&#125; Text&quot;)        textLarge &#x3D; TextMobject(&quot;&#123;\\Large Large Text 012.\\#!?&#125; Text&quot;)        textlarge &#x3D; TextMobject(&quot;&#123;\\large large Text 012.\\#!?&#125; Text&quot;)        textNormal &#x3D; TextMobject(&quot;&#123;\\normalsize normal Text 012.\\#!?&#125; Text&quot;)        textsmall &#x3D; TextMobject(&quot;&#123;\\small small Text 012.\\#!?&#125; Texto normal&quot;)        textfootnotesize &#x3D; TextMobject(&quot;&#123;\\footnotesize footnotesize Text 012.\\#!?&#125; Text&quot;)        textscriptsize &#x3D; TextMobject(&quot;&#123;\\scriptsize scriptsize Text 012.\\#!?&#125; Text&quot;)        texttiny &#x3D; TextMobject(&quot;&#123;\\tiny tiny Texto 012.\\#!?&#125; Text normal&quot;)        textHuge.to_edge(UP)        texthuge.next_to(textHuge,DOWN,buff&#x3D;0.1)        textLARGE.next_to(texthuge,DOWN,buff&#x3D;0.1)        textLarge.next_to(textLARGE,DOWN,buff&#x3D;0.1)        textlarge.next_to(textLarge,DOWN,buff&#x3D;0.1)        textNormal.next_to(textlarge,DOWN,buff&#x3D;0.1)        textsmall.next_to(textNormal,DOWN,buff&#x3D;0.1)        textfootnotesize.next_to(textsmall,DOWN,buff&#x3D;0.1)        textscriptsize.next_to(textfootnotesize,DOWN,buff&#x3D;0.1)        texttiny.next_to(textscriptsize,DOWN,buff&#x3D;0.1)        self.add(textHuge,texthuge,textLARGE,textLarge,textlarge,textNormal,textsmall,textfootnotesize,textscriptsize,texttiny)        self.wait(3)</code></pre><p><img src="/img/SizeTextOnLaTeX.gif" alt=" "></p><pre><code class="hljs python3">class TextFonts(Scene):    def construct(self):        textNormal &#x3D; TextMobject(&quot;\\textrm&#123;Roman serif text 012.\\#!?&#125; Text&quot;)        textItalic &#x3D; TextMobject(&quot;\\textit&#123;Italic text 012.\\#!?&#125; Text&quot;)        textTypewriter &#x3D; TextMobject(&quot;\\texttt&#123;Typewritter text 012.\\#!?&#125; Text&quot;)        textBold &#x3D; TextMobject(&quot;\\textbf&#123;Bold text 012.\\#!?&#125; Text&quot;)        textSL &#x3D; TextMobject(&quot;\\textsl&#123;Slanted text 012.\\#!?&#125; Text&quot;)        textSC &#x3D; TextMobject(&quot;\\textsc&#123;Small caps text 012.\\#!?&#125; Text&quot;)        textNormal.to_edge(UP)        textItalic.next_to(textNormal,DOWN,buff&#x3D;.5)        textTypewriter.next_to(textItalic,DOWN,buff&#x3D;.5)        textBold.next_to(textTypewriter,DOWN,buff&#x3D;.5)        textSL.next_to(textBold,DOWN,buff&#x3D;.5)        textSC.next_to(textSL,DOWN,buff&#x3D;.5)        self.add(textNormal,textItalic,textTypewriter,textBold,textSL,textSC)        self.wait(3)</code></pre><p><img src="/img/TextFonts.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一期半月谈</title>
    <link href="/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/"/>
    <url>/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/</url>
    
    <content type="html"><![CDATA[<p>这是是我对现在的简单思考</p><a id="more"></a><p>&emsp;&emsp;现在是5月1号，距离上次更新博客已经很久了。因为在家上课，所以时间非常自由。因为想参加一下蓝桥杯，来看看自己的专业水平到底怎么样。所以就慢慢开始准备学习算法起来了。</p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>&emsp;&emsp;在学习算法的过程种，我慢慢的对我自己的真实能有了比较全面的了解。从简单的基本算法开始到数据结构到图论</p><script type="math/tex; mode=display">基本算法\rightarrow 数据结构 \rightarrow 图论 \rightarrow \dots</script><p>说实话没得一步是简单的，是真的举步维艰。基本算法中的枚举、模拟、递归、分治$\dots$ 我感觉我到现在都没有真正学会其中的思想，每天坚持通过训练的方式来提高自己的对一些算法的理解，但是半天下来可能也就做了一两个题目，有时候思路开阔可能也就三四个，但是大部分时间也就是一两个的样子。可能是在家的原因，调板子没啥效率。但是这种挫败感是太真实了，随着渐渐对这种方向的深入了解。也就慢慢的明白自己知道东西实在是太少了，不断的从一些教学视频里面慢慢的学习前人总结出的经验。</p><p>但是这确实很可笑，你感觉你学会了一种算法，但是题目给你变一变，你就立马懵逼了。如果说做算法题可以类比成你高中的数学题的话，可能就是你题型见的不够多，总结的很少导致的。但这也是困难所在，虽然算法就那么多你这么能正真理解一个题目到底想怎么考你去使用这个算法是十分困难的。就拿前缀和为例</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> arr[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i], arr[i] += arr[i - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>前缀和就是那样很简单，就是一个arr[i] = arr[i - 1] + arr[i];的一个公式，在仔细看看其实是就是前$N$项求和，但是它有什么用？怎么用？可以干啥一般都是怎么处理的。</p><p>完完全全就需要你自己去总结思考，但是可能这种小技巧也只会出现在你解决某个题目中的一个小步骤中，但是有些人总是能把这种小技巧玩的出神入化，来降低时间复杂度。这就要看各位对这种技巧的理解了，没人能帮助你。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在知乎上经常能看到有人发这样的问题，“大神都是如何刷leetcode的”。我才这样的问这样问题的人都是一些为了找工作而去刷题的人。因为正真的大佬早已经在ACM类比赛中把算法这东西玩的炉火纯青了，你可能还在第一层，人家已经到了第五层了。其中有个人的回答很是亮眼，他说：你把打好的青春都浪费在刷LeetCode上那你为什么不把那些时间去研究一下新技术，学习一下技术的底层实现呢？看到一个题目思考了10分钟还没思路那就去看题解理解这个题目，花费那么长时间浪费在这上面不那么值得。就像郭杰瑞那期视频一样老郭做了江苏高考英语试卷但是到最后结果和大家想的一样，错了很多，是他英语差吗不是，那是人家的母语那是什么是缺乏这方面的训练。也就是说为什么我们刚开始学算法的时候为什么会那么痛苦，没有接收相关的训练很难一开始就上手完成的很好，针对的训练是至关重要的。</p><p>但是我反观一下自己，把大把的时间花在学习这些东西上是否也是一种浪费？当然不是，那是我以后吃饭的东西花费时间在这上面怎么算是浪费呢？但是我觉得我缺走上了歧途，什么歧途？</p><p>C++:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span>;&#125;</code></pre><p>Java:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">public</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);    &#125;&#125;</code></pre><p>Python:</p><pre><code class="hljs python">print(<span class="hljs-string">&quot;Hello World&quot;</span>)</code></pre><p>JavaScript:</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello World&quot;</span>);</code></pre><p>我现在会四种语言来写出Hello World这个词，说明我了解了很多不同种类的编程语言但是，我确实不明白为什么我们要一开始去写一个Hello World。是因为他简单？其实并不是，学习编程每个人的目的是不同的，为什么现在社会上有那么多培训班，在短短是几个星期里面就能教出一个人去公司里面上班每个月拿着一两万的工资？因为现在很多东西被模式化了，</p><p>UADC(update, add, delete, create)这样的模式几乎符合任何情况，并不是人们想的通过编程来改变世界。如果说你被这种混口饭吃的想法所束缚，那你的发展也就那样的。那科班生和培训班的人也就没什么两样的了，科班生不只是有很多时间去打磨自己的能力，更多的是有时间去创造。这些语言归根到底是一种我们所特有的一种工具，而这种工具用来帮助我们把现实生活中的一些常见问题给抽象出来我们通过算法来反复重复的解决这种问题来方便我们。这才是我们的学习的正真目的，为什么说各个行业都需要会写程序的人，但是这些领域有时候又和计算机专业完全不沾边。但是就有人能去创造它方便行业快速发展，而这就是创造力。而不是仅仅的为了那一两行算法代码。这也是为什么说我<strong>没趣、死板、不懂审美</strong>$\dots$ 的原因。</p><p>被这种看起来死板的东西所束缚了，不能走出这种圈子，去学习了解更多的东西来正真成就自己。</p><p>$未完\dots$</p>]]></content>
    
    
    <categories>
      
      <category>半月谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆，杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p>快快快~</p><a id="more"></a><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>问题描述：</p><p>&emsp;&emsp;求$A^B$的最后三位数的整数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果我们直接通过循环的方法来解决我们会发现</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;            result = result * base;      &#125;        <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>如果给出$base = 2$ $power = 100$ 的时候我们就就会发现函数$f(x) = a^{b}$是一个指数函数后期的增长速度是非常快的所以我们需要对此进行优化。</p><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p>取模运算有以下 性质：</p><ol><li><p>$(a + b)\%c = ((a\%c) + (b\%c))\%c$</p></li><li><p>$(a \times b)\%c = ((a\%c) \times (b\%c))\%c$</p></li><li><p>$(a - b)\%c = ((a\%c)-(b\%c))\%c$</p><p>总成依据话就是，在取模运算的时候我们在中间过程每次都取模，在得出答案之后我们再取一次模。</p><p>我们通过性质性质2来优化我们的代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;        result *= base;        result %= <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>通过这样的运算优化，我们发现这种取模运算中如果我们中间进行取模的话是可以防止出现溢出的情况的。</p></li></ol><h2 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h2><p>&emsp;&emsp;快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。从而达到快速计算的目的。</p><p>例如：</p><p>$3^{10} = 3\times3\times3\times3\times3\times3\times3\times3\times3\times3$</p><p>我们可以尽可能的将其指数降下来，来简化运算。</p><p>$3^{10} = (3\times3)\times(3\times3)\times(3\times3)\times(3\times3)\times(3\times3)$</p><p>$3^{10} = (3\times3)^5$</p><p>其实这种方法也在平常也是十分常见的，比如我们向计算$2^4$我们肯定不会一个一个的乘$2$我们一般都会去直接计算$4\times4$从而快速的计算出结果，其实两者的关系是一样的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = base;        whlie (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果指数为偶数</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//把指数缩小为一半</span>            base = base * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//底数变大成原来的平方</span>        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">//如果指数为奇数</span>            power = power - <span class="hljs-number">1</span>;<span class="hljs-comment">//把指数减去1，使其变成一个偶数</span>            result = result * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//此时记得要把指数为奇数时分离出来的底数的一次方收集好</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//此时指数为偶数，可以继续执行操作</span>            base = base * base % <span class="hljs-number">1000</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最终优化"><a href="#最终优化" class="headerlink" title="最终优化"></a>最终优化</h2><p>&emsp;&emsp;我们知到判断奇偶性除了使用 $\%$看其余数是否为$0$ $or$ $1$来进行判断之外，我们还可以通过位运算来进行计算，例如：power&amp;1。因为如果power为偶数，则其二进制表示的最后一位一定是0；如果power是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是power二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1=1；而6是偶数，则6&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p>&emsp;&emsp;同样对于除以$2$的运算我们也可以使用位运算来进行优化power /= 2可以使用右移power = power &gt;&gt; 1实现，右移动1就是除以2，如果右移2就是除以4，同理左移就是乘，左移1就是乘以2左移2就是乘以4；</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>求$m^k$ $\% $ $p$ 时间复杂度为$O(logk)$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p, t = m;        <span class="hljs-keyword">while</span> (k) &#123;                <span class="hljs-comment">//如果为奇数</span>        <span class="hljs-keyword">if</span> (k &amp;  <span class="hljs-number">1</span>) res = res * t % p;                t = t * t % p;        k &gt;&gt; <span class="hljs-number">1</span>;    &#125;        <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向BFS</title>
    <link href="/2020/03/28/%E5%8F%8C%E5%90%91BFS/"/>
    <url>/2020/03/28/%E5%8F%8C%E5%90%91BFS/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="搜索-双向BFS"><a href="#搜索-双向BFS" class="headerlink" title="搜索-双向BFS"></a>搜索-双向BFS</h1><ul><li>双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率。</li><li>同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案</li><li><font color="red">但是双向BFS在针对于小型数据范围时就会退化成BFS,如果双向BFS的两个端点完全没有连接，时间复杂度也会和BFS相同</font></li></ul><p><img src="/img/BFS.png" alt=" "></p><p>当两种颜色相遇的时候，说明两个方向的搜索树遇到一起，这个时候就搜到了答案。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>简单理入门：</p><p><strong>问题描述</strong>：<br>一个迷宫由$R$行$C$列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。<br>给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。</p><p><strong>输入</strong></p><p>第一行是两个整数，$Ｒ$和$Ｃ$，代表迷宫的长和宽。$（1≤R，C≤40)$<br>接下来是$Ｒ$行，每行$Ｃ$个字符，代表整个迷宫。<br>空地格子用‘.’表示，有障碍物的格子用‘#’表示。<br>迷宫左上角和右下角都是‘.’。</p><p><strong>输出</strong></p><p>输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点</p><p><strong>输入样例</strong></p><pre><code class="hljs clean"><span class="hljs-number">5</span> <span class="hljs-number">5</span>..####....#.#.##.#.##.#..</code></pre><p><strong>输出样例</strong></p><pre><code class="hljs plain">9</code></pre><p><strong>普通BFS：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">100000</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[MAX][MAX];<span class="hljs-keyword">int</span> d[MAX][MAX];<span class="hljs-comment">//表示起点到各个位置的最短距离 </span><span class="hljs-keyword">int</span> sx, sy, gx, gy;<span class="hljs-comment">//表示起点和终点坐标 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,- <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; d[x][y]==INF &amp;&amp; <span class="hljs-built_in">map</span>[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">queue</span>&lt;P&gt; que;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)d[i][j] = INF;que.push(P(sx, sy));d[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!que.empty()) &#123;P p = que.front(); que.pop();<span class="hljs-keyword">if</span>(p.first == gx &amp;&amp; p.second == gy)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = p.first + dx[i];<span class="hljs-keyword">int</span> ny = p.second + dy[i];<span class="hljs-keyword">if</span>(Check(nx, ny)) &#123;que.push(P(nx,ny));d[nx][ny] = d[p.first][p.second] + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> d[gx][gy]; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];sx = <span class="hljs-number">0</span>, sy = <span class="hljs-number">0</span>;gx = n<span class="hljs-number">-1</span>, gy = m<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> res = bfs(); <span class="hljs-built_in">cout</span> &lt;&lt; res+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>双向BFS</strong>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//记录下当前状态, 从前往后搜索值为1，从后往前搜索值为2，如果某状态下，当前节点和准备扩展节点的状态相加为3，说明相遇</span><span class="hljs-built_in">queue</span> &lt;P&gt; q1, q2; <span class="hljs-keyword">int</span> r, c, ans, dis[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>], vst[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">char</span> m[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dbfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">bool</span> flag;q1.push(P(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), dis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, vst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//从前搜</span>q2.push(P(r, c)), dis[r][c] = <span class="hljs-number">1</span>, vst[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">//从后搜</span><span class="hljs-keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;<span class="hljs-keyword">int</span> x0, y0;<span class="hljs-keyword">if</span>(q1.size() &gt; q2.size()) &#123; <span class="hljs-comment">//每次扩展搜索树小的队列 flag=1扩展前搜的队列，flag=0扩展后搜的队列</span>x0 = q2.front().first, y0 = q2.front().second;q2.pop();flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;x0 = q1.front().first, y0 = q1.front().second;q1.pop();flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = x0 + dx[i];<span class="hljs-keyword">int</span> ny = y0 + dy[i];<span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; m[nx][ny] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(!dis[nx][ny]) &#123;dis[nx][ny] = dis[x0][y0] + <span class="hljs-number">1</span>;vst[nx][ny] = vst[x0][y0];<span class="hljs-keyword">if</span>(flag) q1.push(P(nx, ny));<span class="hljs-keyword">else</span> q2.push(P(nx, ny));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(vst[x0][y0] + vst[nx][ny]== <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//相遇</span>ans = dis[nx][ny] + dis[x0][y0];<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; r &gt;&gt; c;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++)<span class="hljs-built_in">cin</span> &gt;&gt; m[i][j];dbfs(); <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a herf = "https://leetcode-cn.com/problems/word-ladder/">力扣第127题：单词接龙</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code class="hljs clean">输入:beginWord = <span class="hljs-string">&quot;hit&quot;</span>,endWord = <span class="hljs-string">&quot;cog&quot;</span>,wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]输出: <span class="hljs-number">5</span>解释: 一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>,     返回它的长度 <span class="hljs-number">5</span>。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs makefile"><span class="hljs-section">输入:</span>beginWord = <span class="hljs-string">&quot;hit&quot;</span>endWord = <span class="hljs-string">&quot;cog&quot;</span>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<span class="hljs-section">输出: 0</span><span class="hljs-section">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span></code></pre><p>&emsp;&emsp;如果只是单纯的使用BFS经行操作那么时间复杂度将会为$O(M\times N)$ $M$表示单词的长度, $N$表示单词列表中单词的个数.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;      <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s; <span class="hljs-comment">// 可以块数查找</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : wordList) s.insert(i);      <span class="hljs-comment">// first 表示字符</span>      <span class="hljs-comment">// second 表示走过的路长</span>      <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;      q.push(<span class="hljs-built_in">make_pair</span>(beginWord, <span class="hljs-number">1</span>));      <span class="hljs-built_in">string</span> temp;      <span class="hljs-keyword">int</span> step; <span class="hljs-comment">// 表示用暂时存贮走过的步子</span>      <span class="hljs-keyword">while</span> (!q.empty()) &#123;          <span class="hljs-keyword">if</span> (q.front().first == endWord) <span class="hljs-keyword">return</span> q.front().second;          temp = q.front().first;          step = q.front().second;          q.pop();          <span class="hljs-keyword">char</span> ch;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= temp.size(); ++ i) &#123;              ch = temp[i];              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                  <span class="hljs-keyword">if</span> (ch == a) <span class="hljs-keyword">continue</span>;                  temp[i] = a;                  <span class="hljs-keyword">if</span> (s.find(temp) != s.end()) &#123; <span class="hljs-comment">// 这里表示如果找到了可以转换的两个单词，就把该数存放入队列里</span>                      q.push(<span class="hljs-built_in">make_pair</span>(temp, step + <span class="hljs-number">1</span>));                      s.erase(temp); <span class="hljs-comment">// 删掉结点的意思防止找到重复</span>                  &#125;                  temp[i] = ch;              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>如果使用双向BFS：</p><ul><li>$O(M \times N)$，其中 MM 是单词的长度 $N$是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 $M \times N$ 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</li></ul><p>算法：</p><ul><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p></li></ul><blockquote><p> 双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote><ul><li>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dbfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;       <span class="hljs-function"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">dict</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;       <span class="hljs-keyword">if</span> (dict.find(beginWord) != dict.end()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//初始化</span>       <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; beginSet, endSet, tmp, visited;       beginSet.insert(beginWord);       endSet.insert(endWord);       <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (!beginSet.empty() &amp;&amp; !endSet.empty()) &#123;           <span class="hljs-keyword">if</span> (beginSet.size() &gt; endSet.size()) &#123;               tmp = beginSet;               beginSet = endSet;               endSet = tmp;           &#125;           tmp.clear();           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> word : beginSet) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.size(); ++ i) &#123;                   <span class="hljs-keyword">char</span> old = word[i];                   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; a &lt; <span class="hljs-string">&#x27;z&#x27;</span>; ++ a) &#123;                       <span class="hljs-keyword">if</span> (old == a) <span class="hljs-keyword">continue</span>;                       word[i] = a;                       <span class="hljs-keyword">if</span> (endSet.find(word) != endSet.end()) &#123;                           <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;                       &#125;                       <span class="hljs-keyword">if</span> (visited.find(word) == visited.end() &amp;&amp; dict.find(word) != dict.end()) &#123;                           tmp.insert(word);                           visited.insert(word);                       &#125;                   &#125;                   word[i] = old;               &#125;           &#125;           beginSet = tmp;           ++ len;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于set与unordered-set"><a href="#关于set与unordered-set" class="headerlink" title="关于set与unordered_set"></a>关于set与unordered_set</h3><ul><li><strong>set函数(集合)</strong>：这里的set表示集合的意思，和数学中的集合是一个意思，集合中不允许有重复出现的元素，由于set函数底层通常以红黑树实现，红黑树具有自动排序的功能，因此set内部所有的数据，在任何时候，都是有序的。</li><li><strong>unordered_set函数</strong>： 是含有 Key 类型唯一对象集合的关联容器，依赖于哈希表。搜索、插入和移除拥有平均常数时间复杂度。在内部，元素并不以任何特别顺序排序，而是组织进桶中，元素被放进哪个桶完全依赖其值的哈希。允许对单独元素的快速访问，因为一旦哈希，就能够准确指代元素被放入的桶。不可修改容器元素（即使通过非 const 迭代器），因为修改可能更改元素的哈希，并破坏容器。代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</li></ul><h4 id="下面几种情况一般使用set："><a href="#下面几种情况一般使用set：" class="headerlink" title="下面几种情况一般使用set："></a>下面几种情况一般使用set：</h4><ol><li>需要有序的数据(元素不同)。</li><li>需要按顺序打印/访问数据。</li><li>需要元素的前任或后继。</li></ol><h4 id="下面几种情况一般使用unordered-set："><a href="#下面几种情况一般使用unordered-set：" class="headerlink" title="下面几种情况一般使用unordered_set："></a>下面几种情况一般使用unordered_set：</h4><ol><li>需要保留一组不同的元素，不需要排序。</li><li>需要访问单个元素，不要遍历。</li></ol><h3 id="关于map与unordered-map"><a href="#关于map与unordered-map" class="headerlink" title="关于map与unordered_map"></a>关于map与unordered_map</h3><ul><li><strong>map函数（映射）</strong>： map函数在缺省下，按照递增的排序顺序，并且内部采用了自平衡的BST（二叉搜索树）的数据结构，实现了数据排序。所以在搜索的时候时间复杂度为$Olog(n)$</li><li><strong>unordered_map函数</strong>：unordered_map函数不进行排序二内部采用了哈希表的数据结构在搜索的时候时间复杂度为$O(1)$，但是在特殊情况下时间复杂度就会退化为$O(n)$</li></ul><p>因此如果你想要一个具有排序后的数据的话，通常可以选择map这种类型。或者想要打印具有一定顺序的元素。如果你只想记录数据而不是想要将数据进行排序的话，那么就可以选择unordered_map这种数据结构。</p><p><a herf="https://blog.csdn.net/weixin_43501684/article/details/90147421">.</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cellular automata</title>
    <link href="/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/"/>
    <url>/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>STL函数，内部用二分查找实现</p><a id="more"></a><h1 id="有关lower-bound-函数的使用"><a href="#有关lower-bound-函数的使用" class="headerlink" title="有关lower_bound()函数的使用"></a>有关lower_bound()函数的使用</h1><p>lower_bound()函数需要加载头文件#include<algorithm>,其基本用途是查找有序区间中第一个大于或等于某给定值的元素的位置，其中排序规则可以通过二元关系来表示。</p><pre><code class="hljs C++">函数原型：<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span>   <span class="hljs-function">ForwardIterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _First, </span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _Last,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">const</span> Type&amp; _Val</span></span><span class="hljs-function"><span class="hljs-params">   )</span></span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;</span>   <span class="hljs-function">ForwardIterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _First, </span></span><span class="hljs-function"><span class="hljs-params">      ForwardIterator _Last,</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">const</span> Type&amp; _Val,</span></span><span class="hljs-function"><span class="hljs-params">      BinaryPredicate _Comp</span></span><span class="hljs-function"><span class="hljs-params">   )</span></span>;传入参数说明：   _First 要查找区间的起始位置_Last 要查找区间的结束位置_Val 给定用来查找的值_Comp 自定义的表示小于关系的函数对象，根据某个元素是否满足小于关系而返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span></code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>例如，有如下序列：<br>$a[i]={12,15,17,19,20,22,23,26,29,35,40,51}$;<br>用值21调用lower_bound(),返回一个指向22的iterator。用值22调用lower_bound(),也返回一个指向22的iterator。第一个版本使用底层 &lt; (小于)操作符，第二个版本根据comp进行排序和比较。</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>调用lower_bound之前必须确定序列为有序序列，否则调用出错。第一个版本排序根据底层的 &lt;(小于)操作符，第二个版本根据comp进行排序。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/sdtc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);   <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p>上面的例子是针对容器的，注意返回的是距离元素3最近的指针it，输出的是*it结果为元素4，假如我想得到位置而非具体的元素应该怎么办呢？这里有一个指针偏移的技巧，只需要减去起始位置的指针即可，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)          v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的  </span>    <span class="hljs-comment">//vector&lt;int&gt;::iterator it = lower_bound(v.begin(), v.end(), 3);  </span>    <span class="hljs-keyword">int</span> pos = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>)-v.begin();      <span class="hljs-built_in">cout</span> &lt;&lt; pos&lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>结果和容器的时候是一样的。</p><p>对于4个参数的情形，最后一个参数的自己定义的表示大小关系函数的对象，常用的逆序可以加载头文件#include<functional>,里边有一个greater<int>()函数即可对逆序求最近位置。假如说像上边一样元素为2 4 6 8，逆序则是8 6 4 2，那么求距离3最近表示的是与3最近的小于等于3的元素，输出结果则是元素2了，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &gt;<span class="hljs-number">0</span>; i--)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());     <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们知道map容器是根据键值进行排序的</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><p>这两个函数常用于multimap容器，用来获取某个键对应的所有元素</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; m;    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">2</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">3</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">1</span>));    m.insert(<span class="hljs-built_in">make_pair</span>((<span class="hljs-built_in">string</span>)<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-number">2</span>));    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = m.begin();    <span class="hljs-keyword">while</span>(it != m.end())    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;        it++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it1 = m.lower_bound(<span class="hljs-string">&quot;China&quot;</span>),it2 = m.upper_bound(<span class="hljs-string">&quot;China&quot;</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;it1-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it1-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;it2-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it2-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲</title>
    <link href="/2020/03/26/AC%E9%80%89%E8%AE%B2/"/>
    <url>/2020/03/26/AC%E9%80%89%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>最近AC题目的分析</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><blockquote><p>示例1：</p></blockquote><pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><blockquote><p>示例2:</p></blockquote><pre><code>输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;<strong>这种在数组空间上进行各种操作的题目，一般可以利用双指针进行解决。</strong><br>&emsp;&emsp;这个题目比较困难的地方再于各种边界的判定于操作，以及如何快速高效的进行合并。<br>&emsp;&emsp;双指针再解决这类问题的时候总有着很清晰的思路，首先我们要减少复杂情况，所以先排序形成一个有序的状态。我们先设双指针<br>第一个$save$用于保留和扩展另一个用$scan$来进行扫描</p><p>&emsp;&emsp;因为我们排序之后这个序列肯定是有序的所以我们就可以不用考虑左边界所有就剩下三种情况了</p><ul><li>eg:  $\overbrace{[1,3],[4,5]}^{save}$这种情况最为简单，两个区间不相交，因此我们就可以把$save$指针所指向的数据压入result数组种，然后再将$save$移动到<br>scan指针所指的地方：$[1,3],\overbrace{[4,5]}^{save}, \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save}, \overbrace{[2,3]}^{scan}$,这种是一种不被包含的情况，因此我们呢不需要操作$save$指针，$scan$ 指针继续往后移动即可：$\overbrace{[1,4]}^{save}, [2,3], \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save},\overbrace{[3,5]}^{scan}$,这种情况是相对比较复杂的情况，即我们需要对于$save$指针指向的数组进行扩展，所以我们需要修改数组为$\overbrace{[1,4]}^{save} \rightarrow \overbrace{[1,5]}^{save}$, 然后将$scan$指向下一个,也就是:  $\overbrace{[1,5]}^{save}, [3,5], \overbrace{[X,X]}^{scan}$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;        <span class="hljs-comment">// 对于特殊情况的特判</span>        <span class="hljs-keyword">if</span> (intervals.size() == <span class="hljs-number">0</span> || intervals.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;        <span class="hljs-comment">// 双指针</span>        <span class="hljs-keyword">int</span> save = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于保存的数组</span>        <span class="hljs-keyword">int</span> scan = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用户扫描的数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;        sort (intervals.begin(), intervals.end());        <span class="hljs-keyword">while</span> (scan &lt; intervals.size()) &#123;            <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">0</span>] &gt; intervals[save][<span class="hljs-number">1</span>]) &#123;                result.emplace_back(intervals[save]);                save = scan;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">1</span>] &lt;= intervals[save][<span class="hljs-number">1</span>]) &#123;                ++ scan;            &#125; <span class="hljs-keyword">else</span> &#123;                intervals[save][<span class="hljs-number">1</span>] = intervals[scan][<span class="hljs-number">1</span>]; <span class="hljs-comment">//将数组扩充</span>                ++ scan;            &#125;        &#125;        result.emplace_back(intervals[save]); <span class="hljs-comment">// 当scan扫描到最后一个区间之后会跳出循环也就是说还有一个区间没有压入向量</span>        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;三种情况种第一种情况是一般情况，后面两种是特殊情况，我们只需要对特殊情况经行处理称一般情况，然后让一般情况操就行了。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Largest Rectangle in Histogram</title>
    <link href="/2020/03/21/MaximalRectangle/"/>
    <url>/2020/03/21/MaximalRectangle/</url>
    
    <content type="html"><![CDATA[<p>Largest Rectangle in Histogram解析</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/img/rectangle2.png" alt=" "></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="/img/rectangle1.png" alt=" "></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>示例:</p><p>输入: [2,1,5,6,2,3]</p><p>输出: 10</p></blockquote><h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p><img src="/img/rectangle.png" alt=" "></p><p>height的内容是 [5,6,7,8,3]，特点是除了最后一个，前面全部保持递增，且最后一个立柱的高度小于前面所有立柱高度。对于<br>这种特点的柱状图，如果使用上面所说的“挨个使用每一个柱状图的高度作为矩形的高度，求面积”的方法，还需要用嵌套循环吗？</p><p>&emsp;&emsp;我们知道除了最后一个，从第一个到倒数第二个立柱的高度都在升高，那么如果挨个使用每一个柱的高度作为矩形的<br>高度，那么依次能得到的矩形的宽度就可以直接算出来：使用5作为高度可以使用前四个立柱组成 $4\times5$的矩形，高度6可以<br>组成$3\times6$的矩形… 因此只需要遍历一次，选出最大面积即可。对于这种类型的柱状图，最大矩形面积的时间复杂度是O(n)。我们将这种特点的柱状图称为“波峰图”。</p><p>从而算法设计步骤：</p><p>(1) 在height尾部添加一个0，也就是一个高度为0的立柱。作用是在最后也能凑成上面提的那种“波峰图”。</p><p>(2) 定义了一个stack，然后遍历时如果height[i] 大于stack.top()，进栈。反之，出栈直到栈顶元素小于height[i]。</p><p>由于出栈的这些元素高度都是递增的，我们可以求出这些立柱中所围成的最大矩形。更妙的是，由于这些被弹出的立柱处于“波峰”之上(比如弹出i 到 i+k，那么所有这些立柱的高度都高于 i-1和 i+k+1的高度)，因此，如果我们使用之前所提的“左右延伸找立<br>柱”的思路解，以这些立柱的高度作为整个矩形的高度时，左右延伸出的矩形所包含的立柱不会超出这段“波峰”，因为波峰外的立柱<br>高度都比他们低。“波峰图”其实就是求解最大矩形的“孤岛”，它不会干扰到外部。</p><p>(3) 由于比height[i]大的元素都出完了，height[i]又比栈顶元素大了，因此再次进栈。如此往复，直到遍历到最后那个高度为0的柱，触发最后的弹出以及最后一次面积的计算，此后stack为空。</p><p>(4) 返回面积最大值。</p><p>&emsp;&emsp;栈中存的不是高度，而是height的索引，这样做的好处是不会影响宽度的计算，索引值相减 = 宽度。</p><h2 id="但是对于面积的计算，还需要再多少几句"><a href="#但是对于面积的计算，还需要再多少几句" class="headerlink" title="但是对于面积的计算，还需要再多少几句"></a>但是对于面积的计算，还需要再多少几句</h2><p><img src="/img/rectangle3.png" alt=" "></p><p>矩形的面积=高*宽。<br>我们的发现，在这个分支情况下，我们已经知道高为2了，那么宽度如何求呢？<br>通过观察，我们发现矩形的左边沿是左边第一个高比2小的柱子，右边沿是右边第一个高比2小的柱子（将高为3的柱子的右面看作还<br>有一个高为0的柱子）如此它的宽度是$6 -（1+1）=4$</p><h2 id="如何寻找柱子的左右边"><a href="#如何寻找柱子的左右边" class="headerlink" title="如何寻找柱子的左右边"></a>如何寻找柱子的左右边</h2><p>我们已经说了，左边沿是左边第一小与本柱子高的柱子的右边，右边沿也是同理。<br>这正好可以用单调栈。<br>当第i个柱子进栈时，如果栈顶柱子（此处记作柱子A）的高度低于或等于第i个柱子，则第i个柱子进栈；<br>如果高于第i个柱子，则出栈，并计算以柱子A为高的矩形最大面积。</p><ul><li>高度：就是柱子A的高度</li><li>右边沿：正好是i（由于单调栈的性质，第i个柱子就是右边第一个矮于A的柱子）</li><li>左边沿：单调栈中紧邻A的柱子。（如果A已经出栈，那么左边沿就是A出栈后的栈顶）而且是该柱子的右边，所以要+1.</li></ul><p>因此，完全覆盖第index个柱子的最大矩形的面积如下（stk是单调栈）</p><pre><code>maxArea = heights[index] * (i - (stk.top() +1))</code></pre><p>还有一种情况。当A出栈后，单调栈为空时，那就是说明，A的左边没有比它矮的。左边沿就可以到0.</p><pre><code>maxArea = heights[index] * (stk.empty() ? i : (i - stk.top() -1)))</code></pre><p>可能你还有点不明白就是，那实际代码是怎么计算的？其实自习想一下就明白了，因为是取得top元素进行计算所以计算是从右边逐<br>渐往左边延伸。所以当整个栈排空的时候也就计算了距离右边最远的边界。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>栈实现：</strong></p><pre><code>int largeRectangleArea(vector&lt;int&gt;&amp; h) &#123;    stack&lt;int&gt; s;    h.push_back(0);    int sum = 0;    for (int i = 0; i &lt; h.size(); ++ i) &#123;        if (s.empty() || h[i] &gt; h[s.top()]) s.push(i);        else &#123;            int tmp = s.top();            s.pop();            sum = max(sum, h[tmp] * (s.empty() ? i : i - s.top() - 1));            i --;        &#125;    &#125;    return sum;&#125;</code></pre><p><strong>分治解法：</strong></p><pre><code>    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;        if(heights.empty()) return 0;        return maxArea(heights,0,(int)heights.size()-1);    &#125;    int maxArea(vector&lt;int&gt;&amp; heights,int start, int end)&#123;        if(start &gt; end)            return 0;        int minIndex=start;        bool sorted = true;        for(int i=start+1;i&lt;=end;++i)&#123;            if(heights[i]&lt;heights[i-1])                sorted=false;            if(heights[i] &lt; heights[minIndex])&#123;                minIndex=i;            &#125;         &#125;        if(sorted)&#123;//如果有序则不需要再作进一步的分治            int mx=0;            for(int i=start;i&lt;=end;++i)            mx = max(mx,(end-i+1)*heights[i]);            return mx;        &#125;        return max( (end-start+1)*heights[minIndex],                max( maxArea(heights,start, minIndex-1),maxArea(heights,minIndex+1, end) ) );//分治    &#125;</code></pre><h1 id="算01-矩阵中包含最多1-的矩形"><a href="#算01-矩阵中包含最多1-的矩形" class="headerlink" title="算01 矩阵中包含最多1 的矩形"></a>算01 矩阵中包含最多1 的矩形</h1><p>接下来还有道Maximal Rectangle 的题，这道题的实用价值很大：算01 矩阵中包含最多1 的矩形。</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>有了上一题的基础，这道题就可等效为上一题，对于矩阵每一行，我们将其看作直方图，立柱的高度就是行中元素往上数包含的连续1的个数。</p><p>因此每一行都可以利用上一题方法计算最大矩形，最后求出各行结果的最大值就好了。时间复杂度 O(n2)</p><pre><code>    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;                if(matrix.size() == 0 || matrix[0].size() == 0) return 0;        int H = matrix.size(), W = matrix[0].size();        int height[W+1];        int i, j , MAX = 0, leftarea = 0, rightarea = 0;        stack&lt;int&gt; st;        for(i = 0; i &lt;= W; height[i] = 0, ++i);        for(i = 0; i &lt; H; ++i)&#123;            while(!st.empty()) st.pop();            for(j = 0; j &lt; W; ++j)&#123;                if(matrix[i][j] == &#39;1&#39;) height[j]++;                else height[j] = 0;            &#125;            for(int j = 0; j &lt;= W; ++j)&#123;                while(!st.empty() &amp;&amp; height[st.top()] &gt; height[j])&#123;                    int tmp = st.top();                    st.pop();                    leftarea = (st.empty() ? tmp + 1 : tmp - st.top()) * height[tmp];                    rightarea = (j - tmp - 1) * height[tmp];                    if((leftarea + rightarea) &gt; MAX) MAX = (leftarea + rightarea);                &#125;                st.push(j);            &#125;        &#125;        return MAX;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode小技巧</title>
    <link href="/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>vscode 快捷键</p><a id="more"></a><h1 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h1><h1 id="如果懒"><a href="#如果懒" class="headerlink" title="如果懒"></a>如果懒</h1><p>不想看我bb就直接这样做就直接⬇；</p><p>ctrl k + ctrl s = 打开快捷键一览表。</p><p>在这里面、你可以查看、搜索、修改快捷键。</p><h2 id="列出当前可执行的动作"><a href="#列出当前可执行的动作" class="headerlink" title="列出当前可执行的动作"></a>列出当前可执行的动作</h2><p>显示 Errors或 Warnings，也可以 Ctrl+Shift+M:跳转到行数，也可以 Ctrl+G 直接进入</p><p>跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入</p><p>根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入” : “进入</p><p>根据名字查找 symbol，也可以 Ctrl+T</p><p>代码行向左或向右缩进:   Ctrl+[ 、 Ctrl+]</p><p>复制或剪切当前行/当前选中内容:   Ctrl+C 、 Ctrl+V</p><p>代码格式化:   Shift+Alt+F</p><p>向上或向下移动一行:   Alt+Up 或 Alt+Down</p><p>向上或向下复制一行:   Shift+Alt+Up 或 Shift+Alt+Down</p><p>在当前行下方插入一行:   Ctrl+Enter</p><p>在当前行上方插入一行:   Ctrl+Shift+Enter</p><p>Ctrl+Shift+P,F1 展示全局命令面板</p><p>Ctrl+P 快速打开最近打开的文件</p><p>Ctrl+Shift+N 打开新的编辑器窗口</p><p>Ctrl+Shift+W 关闭编辑器</p><p>Ctrl + X 剪切</p><p>Ctrl + C 复制</p><p>Alt + up/down 移动行上下</p><p>Shift + Alt up/down 在当前行上下复制当前行</p><p>Ctrl + Shift + K 删除行</p><p>Ctrl + Enter 在当前行下插入新的一行</p><p>Ctrl + Shift + Enter 在当前行上插入新的一行</p><p>Ctrl + Shift + | 匹配花括号的闭合处，跳转</p><p>Ctrl + ] 或 [ 行缩进</p><p>Home 光标跳转到行头</p><p>End 光标跳转到行尾</p><p>Ctrl + Home 跳转到页头</p><p>Ctrl + End 跳转到页尾</p><p>Ctrl + up/down 行视图上下偏移</p><p>Alt + PgUp/PgDown 屏视图上下偏移</p><p>Ctrl + Shift + [ 折叠区域代码</p><p>Ctrl + Shift + ] 展开区域代码</p><p>Ctrl + / 添加关闭行注释</p><p>Shift + Alt +A 块区域注释</p><p>Alt + Z 添加关闭词汇包含</p><h2 id="导航快捷键"><a href="#导航快捷键" class="headerlink" title="导航快捷键"></a>导航快捷键</h2><p>Ctrl + T 列出所有符号</p><p>Ctrl + G 跳转行</p><p>Ctrl + P 跳转文件</p><p>Ctrl + Shift + O 跳转到符号处</p><p>Ctrl + Shift + M 或 Ctrl + J 打开问题展示面板</p><p>F8 跳转到下一个错误或者警告</p><p>Shift + F8 跳转到上一个错误或者警告</p><p>Ctrl + Shift + Tab 切换到最近打开的文件</p><p>Alt + left / right 向后、向前</p><p>Ctrl + M 进入用Tab来移动焦点</p><p>Ctrl + F 查询</p><p>Ctrl + H 替换</p><p>F3 / Shift + F3 查询下一个/上一个</p><p>Alt + Enter 选中所有出现在查询中的</p><p>Ctrl + D 匹配当前选中的词汇或者行，再次选中-可操作</p><h2 id="多行光标快捷键"><a href="#多行光标快捷键" class="headerlink" title="多行光标快捷键"></a>多行光标快捷键</h2><p>Alt + Click 插入光标-支持多个</p><p>Ctrl + Alt + up/down 上下插入光标-支持多个</p><p>Ctrl + U 撤销最后一次光标操作</p><p>Shift + Alt + I 插入光标到选中范围内所有行结束符</p><p>Ctrl + I 选中当前行</p><p>Ctrl + Shift + L 选择所有出现在当前选中的行-操作</p><p>Ctrl + F2 选择所有出现在当前选中的词汇-操作</p><p>Shift + Alt + right 从光标处扩展选中全行</p><p>Shift + Alt + left 收缩选择区域</p><p>Shift + Alt + (drag mouse) 鼠标拖动区域，同时在多个行结束符插入光标</p><p>Ctrl + Shift + Alt + (Arrow Key) 也是插入多行光标的<code>[方向键控制]</code></p><p>Ctrl + Shift + Alt + PgUp/PgDown 也是插入多行光标的<code>[整屏生效]</code></p><p>Esc Esc 连续按两次Esc键取消多行光标</p><p>Shift + Alt + F 格式化代码</p><p>F12 跳转到定义处</p><p>Alt + F12 代码片段显示定义</p><p>Ctrl + K F12 在其他窗口打开定义处</p><p>Ctrl + . 快速修复部分可以修复的语法错误</p><p>Shift + F12 显示所有引用</p><p>F2 重命名符号</p><p>Ctrl + Shift + . / , 替换下个值</p><h2 id="编辑器管理快捷键"><a href="#编辑器管理快捷键" class="headerlink" title="编辑器管理快捷键"></a>编辑器管理快捷键</h2><p>Ctrl + F4, Ctrl + W 关闭编辑器</p><p>Ctrl + |切割编辑窗口</p><p>Ctrl + 1/2/3 切换焦点在不同的切割窗口</p><p>Ctrl + Shift + PgUp/PgDown 切换标签页的位置</p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++笔记</title>
    <link href="/2020/03/18/C++note/"/>
    <url>/2020/03/18/C++note/</url>
    
    <content type="html"><![CDATA[<p>记录C++中遇到的问题</p><a id="more"></a><h2 id="关于auto"><a href="#关于auto" class="headerlink" title="关于auto"></a>关于auto</h2><p>(1)auto</p><p>auto即 for(auto x:range)  这样会拷贝一份range元素，而不会改变range中元素；</p><p>但是！（重点)  使用for(auto x:vector<bool>)时得到一个proxy class,操作时会改变vector<bool>本身元素。应用：for(bool x:vector<bool>)</p><p>(2)auto&amp;</p><p>当需要修改range中元素，用for(auto&amp; x:range)</p><p>当vector<bool>返回临时对象，使用auto&amp;会编译错误，临时对象不能绑在non-const l-value reference （左值引用）需使用auto&amp;&amp;,初始化右值时也可捕获</p><p>(3)const auto&amp;   </p><p>当只想读取range中元素时，使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range   </p><p>(4)const auto</p><p>当需要拷贝元素，但不可修改拷贝出来的值时，使用 for(const auto x:range)，避免拷贝开销.</p><hr><p>当我们在遍历容器的时候</p><pre><code>for(auto i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>但我知道这不必要的——不必要,因为我只需要打印 vec ——复制的值</p><p>编辑 : vec的每个元素，所以我可以这样做</p><pre><code>for(auto &amp;i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>但是我想确保 vec的值从未被修改并遵守 const-correctness，所以我可以：</p><pre><code>for(const auto &amp;i : vec)&#123;std::cout &lt;&lt;i &lt;&lt;std::endl;&#125;</code></pre><p>我的问题是:如果我只需要看看一些容器的值,不会最后循环( const auto &amp;i ) 总是首选由于增加effieciency没有额外的副本(编辑 : vec的每个元素？</p><pre><code>T//I&#39;m copying thisT&amp;//I&#39;m modifying thisconst T&amp;//I&#39;m reading this</code></pre><p>这些是你的”默认值”。当 T 是基本类型( 内置) 时，你通常只需要恢复 const T ( 无引用)，因为副本比别名更便宜。</p><h1 id="对vector进行排序"><a href="#对vector进行排序" class="headerlink" title="对vector进行排序"></a>对vector进行排序</h1><p>源码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;vector&lt;int&gt; vec;//比较函数，这里的元素类型要与vector存储的类型一致bool compare(int a,int b)&#123;return a&lt;b; //升序排列&#125;std::sort(vec.begin(),vec.end(),compare);</code></pre><blockquote><p>注意：由于sort()函数如果不声明比较函数就是默认升序，从小到大。</p></blockquote><h2 id="利用标准库函数find-对vector进行查找"><a href="#利用标准库函数find-对vector进行查找" class="headerlink" title="利用标准库函数find()对vector进行查找"></a>利用标准库函数find()对vector进行查找</h2><pre><code>vector&lt;int&gt; vec;int a=10;vector&lt;int&gt;::iterator it=find(vec.begin(),vector.end(),a);</code></pre><h2 id="构造类型在vector中的排序与查找"><a href="#构造类型在vector中的排序与查找" class="headerlink" title="构造类型在vector中的排序与查找"></a>构造类型在vector中的排序与查找</h2><p>&emsp;&emsp;将构造类型，比如struct的对象存储在vector中，查找时，需要重载等于运算符（operator==），具体实现参考如下代码。</p><pre><code>struct Element &#123;public:    int a;    int b;    Element(int a,int b)&#123;        this-&gt;a = a;        this-&gt;b = b;    &#125;;    bool operator == (const Element&amp; ele)&#123;        return a == ele.a &amp;&amp; b == ele.b;    &#125;;&#125;;//自定义比较函数bool compare(const Element&amp; left,const Element&amp; right)&#123;    return left.a &lt; right.a; //升序排列&#125;//重载输出操作符&lt;&lt;，格式化输出Elementostream&amp; operator &lt;&lt; (ostream&amp; coutU,const Element&amp; ele)&#123;    coutU &lt;&lt; &quot;a:&quot; &lt;&lt; ele.a &lt;&lt; &quot;,b:&quot; &lt;&lt; ele.b;    return coutU;&#125;int main() &#123;    vector&lt;Element&gt; vecEle;    vecEle.push_back(Element(4,4));    vecEle.push_back(Element(1,1));    vecEle.push_back(Element(2,2));    vecEle.push_back(Element(3,3));    //sort    std::sort(vecEle.begin(),vecEle.end(),compare);    for(int i=0; i&lt;vecEle.size(); ++ i) &#123;        cout &lt;&lt; vecEle[i] &lt;&lt; endl;    &#125;    //查找Element(4,4)    vector&lt;Element&gt;::iterator it = find(vecEle.begin(),vecEle.end(),Element(4,4));    cout &lt;&lt; &quot;found &quot; &lt;&lt; *it &lt;&lt; endl;&#125;</code></pre><blockquote><p>程序输出：<br>a:1,b:1<br>a:2,b:2<br>a:3,b:3<br>a:4,b:4<br>found a:4,b:4</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滴滴~</title>
    <link href="/2020/03/15/20%E5%B2%81/"/>
    <url>/2020/03/15/20%E5%B2%81/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p><center></p><p><font size="#e78e97"><br>迈入二十大关</font><br>&lt;/center&gt;<br>你往往只能看到正面，而背面你缺一无所知。<br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /></p><!---------------------------能看到这说明你更愿意去了解背后的故事。而这些的开始，往往可能也就是一种冲动-------------------------------------><p>$\ldots$</p>]]></content>
    
    
    <categories>
      
      <category>day</category>
      
    </categories>
    
    
    <tags>
      
      <tag>day</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忆第一次美赛</title>
    <link href="/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
    <url>/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p>这不仅仅只是一次比赛那么简单</p><a id="more"></a><p>&emsp;&emsp;会战的失败原因是拿破仑一世对敌情侦察不够，临战前分散兵力，初战不利便改变决心，指挥不果断。惠灵顿<br>在进行会战决策、选择阵地、组织防御和协调联军作战方面显示了统帅才能。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>&emsp;&emsp;到我开始写这篇回忆的时候已经，已经距离美赛结束9个小时左右了。当我点下发送的那一刻，我们这场耗时80个小时三天零8个小时的比赛就真的全部结束了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/mail.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">提交</div></center><p>&emsp;&emsp;在关掉电脑之后我狠狠的删自己一巴掌之后，倒上床了就睡了过去。</p><h1 id="前夜"><a href="#前夜" class="headerlink" title="前夜"></a>前夜</h1><p>&emsp;&emsp;由于今年疫情的特殊原因，这次本应该在线下的比赛。被迫转移到了线上，腾讯会议是我和两个好伙伴交流与<br>讨论的唯一途径。在阿凡群里面我们对我们的设备做好了最后的调试，也大概确定了我们所希望努力的方向。就只等3月7号上<br>午出题了，大家还开玩笑说自己已经买好咖啡做好通宵的准备。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/coffee.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">阿凡的饮料</div></center><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>&emsp;&emsp;当拿到题目的时候已经是翻译好的了，由于我们的队伍均是有CS专业同学组成的队伍，且我和阿凡都是第一次参加建模比赛。我们在比赛之前，也了解到每个题目的总体大概所需要的知识。对于C题来说相对我们来说相对友好一些。我也了解到，C题会用到数据挖掘、数据清洗、python。我觉得我在寒假期间稍微学习了一下python的基础知识，对于读懂python的基本语法应没有什么问题。但是看到题目的时候，复杂程度对于我来说几乎是没辙。怎么剔除文本中的乱码情况，怎么对给的数据进行清洗，什么是.tsv文件$\ldots$, 一系列问题我完全傻了。什么正则表达式，什么情感分析。我完全都不懂。</p><p>&emsp;&emsp;这原本是我觉得可以在前期帮助到我们队伍的东西，完全用了。负责建模的阿凡也就揽了过去，要我和阿豪去看后的题目。谁知道第一题我和阿豪就看的非常懵…问的很笼统。随后还是在知乎上有人解读才慢慢似懂非懂的大概知道第一题要我们干什么，上午我们也很快的解决的了第一题，下午便开始对后面的主要部分开始了思考，在赛前我说我会$\LaTeX$，可以负责写作。也在一个月的时间里系统的学习了，之前简单了解的知识。但是我对写作的理解太片面了。赛前准备的时候，看到网上的教程说，写作的同学不能不懂建模，不然写不出来，虽然不直接参与建模但是要对整个模型要明白。我觉得我明白了后一段话，而前段话我到现在才明白。第一天我们对题目的分析之后也就大概解决了第一题。<br>&emsp;&emsp;在第一天结束的时候,我对我这一天进行了总结，因为我感觉我很懵，感觉自己一直在神游，除了可以提一提建议，可以说没有做别的任何事。决定他们在建模的时候了解大概的思路，我就去找找文献，看一下所用到的方法。可以为后面的写作做好准备。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>&emsp;&emsp;因为第二题中a问用到了NLP文本情感分析，在了解学习之后需要需要用到python来进行机器学习。我想我学习过python看看能不能在网上找一下代码看看，能不能跑。但是我又再次错了，我装上了库。库不能运行，我也一直找不出问题。寻求开发者文档也没有结果。到最后我也跑成功，除了知道了大家用了什么方法，想干什么之外。我还是什么也不知道干什么。直到晚上我才明白，我应该开始写作。把要用到的图表先画上去，把$\LaTeX$用的图片环境都给配置好。为后面写作做节省时间。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>&emsp;&emsp;到第三天，也就到最后的冲刺阶段了，但是我们在之前的b题出现了一些新的问题，感觉在后面的拟合效果不好是不是我们的方法出现了问题，这也导致我们本就不自信的c题和d题，需要有所改动。当时我时我知道如果我们不加快进度可能时间会不太够。因为我们在第二天晚上就开始写了问题分析，稍微解决了一些写作上的问题，但是后面主题部分，模型的建立，模型的步骤、推广、在问题中的实际应用，也都没写，也就是我的失职。本应该同时经行的地方我确把这写东西寄托在别人身上。</p><h1 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h1><p>&emsp;&emsp;到了晚上8点，也就是说我们距离美赛结束还剩最后的16个小时。我们的主题部分，还又最为重要的摘要还没写。我从8点开始写摘要一直到10点才写完。我本人为自己写的很好。但是实际确实，完全没不了。完全不可能用在我们的论文中。这也就浪费了很多时间。在模型的建立部分我只是从阿凡那里获得，几乎是他所完成的。当时我们也比较急，当时他说你到低干了啥的时候确实十分内疚，我真的干了啥，我真的有在做什么…<br>&emsp;&emsp;之后我最不愿意看到的地方出现了，<code>我的</code> $\LaTeX$ <code>编译不了了</code>，这也是我从来没有遇到过的问题。我写了100次的$\LaTeX$也遇见过一些问题，但是今天在翻译复制上的之后出现的问题我也是第一次遇到，一直编译不过我是真的急了，当时看到时间已经凌晨了，如果再不解决我们就很有可能面临着无法提交的问题。我试用了各种方法，来解决。但是就是无法解决…然后我下载了TeXstduio,看看能不能有所改进，然后我才发现是“_”的问题，我也没有转义就一直无法编译…<br>&emsp;&emsp;但是这还没完，我在机翻复制之后表格环境还是出现了问题。因为实在不知道怎么解决，只能手画了…，然后还是阿凡，不断给我法写好的表格代码，才稍微加快的进度。眼看时间已经2点了，距离比赛还剩6个小时了。我还在翻译a题，我真的很慌，再加上不时出现的图片浮动位置变化的问题，对于复杂公式我也开始不能快速的书写出来，可以说完全写不了。还是只能在帮助下才能完成….</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我终于在7点左右把所有的问题都给完成了，我的两个好朋友也陪着我一起整整一夜没有睡觉。我也很感谢他们在最后也没有没指责我，因为我的原因，导致了整个队伍在最后如此狼狈的完成了这次的比赛。到了最后大家还在讨论是否能在最后把我们的论文做一下改进，做一下优化。直到最后在发送比赛邮件的时候，这似乎真的都成了历史，真的是一次非常难忘且独特的经历，看到大家那么努力的建模，却在最后应该我负起责任的时候出现了这么严重了的问题。这本来就是一个团队每个人每个环节都应该认真完成的比赛，要是有一环出现问题，那么到最后也是功亏一篑。而我就是那最后一环，原本想用$\LaTeX$来进行一次完美的排版，到了最后确实这样的结果。</p><h1 id="明白"><a href="#明白" class="headerlink" title="明白"></a>明白</h1><p>&emsp;&emsp; 原本我是不打算写这边回忆的，但是不记录一下却又十分而可惜，由于我的参与感太低，几乎在整个团队中没有做到一点贡献，到了我在应该。<br>做出贡献的时候我确掉了链子，掉链子似乎真的成为了我的专有名词，大家都说我靠不住。一开始我还不理解，直到现在我才<br>明在为什么，从赛前准备开始我的准备就不足，虽然知道自己的在哪方面存在问题存在不足。但是我还是存在不足的问题，感<br>觉自己已经准备好了，但是自己完全认识到事情真正是什么情况。总是逃避问题，不愿意去认识到错误。总觉得自己懂，觉得自己可以，但往往还是不明白。“哦，你又懂了”我一直告诉自己要谦逊，要虚心接受。但是我直到，现在我还没有想到问题的<br>本质是什么。但是通过这件事情，我才明白我为什么无法明白，是因为一直都逃避，不愿意接受别人本来就比自己强，自己本来就不明白，却非要不懂装懂。这才是我无法虚心接受的原因，如果对一些知识没了解过，就完全没有资格去说自己明白了，说别人说不对。<br>&emsp;&emsp;学长说我太浮躁，也是我一直的诟病。我也一直把阿凡作为我的现在榜样，希望能赶超他。如果我现在还是这种，对自己一直自我感觉良好的的状态，别说是望其项背了，可能就是只剩下望尘莫及了。直面逃避的问题，才是我应该做的。而不是说我要好好努力就行了。通过这次比赛我明白了很多，真正认识到了自己应该去努力的方向。寒假认识了GZTime,<br>我也应该明白了我后面发展方向。感觉就之前的经历都没有美赛这么锻炼人，虽然很难但是我认为我有必要再参加一次。好好的向我的两位好朋友好好道歉。在后面的时日里好好努力，去消除那本来就很大的差距，去弥补那缺失的学习能力.去成为一<br>为一个稳健且说到做到的人。</p><h2 id="后面是因为我而没用上的插图"><a href="#后面是因为我而没用上的插图" class="headerlink" title="后面是因为我而没用上的插图"></a>后面是因为我而没用上的插图</h2><p><img src="/img/WordArt.jpeg" alt=" "><br><img src="/img/WordArt1.jpeg" alt=" "><br><img src="/img/WordArt2.jpeg" alt=" "><br><img src="/img/WordArt3.jpeg" alt=" "><br><img src="/img/WordArt4.jpeg" alt=" "></p><font color="#7ea497">致谢：阿凡、阿豪</font><font color="#f4f4f4">(虽然我不喜欢这种阿什么什么的称呼）</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mcm写作基本流程</title>
    <link href="/2020/03/05/mcm%E5%86%99%E4%BD%9C/"/>
    <url>/2020/03/05/mcm%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>美赛的基本写作流程</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过对优秀文章的阅读，美赛的文章有相对固定的写作套路。大部分都分为：</p><ul><li>摘要</li><li>问题重述<ul><li>问题背景</li><li>问题重述</li></ul></li><li>问题分析<ul><li>对问题一分析</li><li>对问题二分析</li><li>对问题三分析</li></ul></li><li>模型假设</li><li>符号说明</li><li>模型的建立与求解<ul><li>问题一</li><li>问题二</li><li>问题三</li></ul></li><li>模型的分析建议</li><li>模型的评估与优化</li><li>参考文献</li><li>附录</li></ul><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>摘要一般第一段写对问题总体环境的概述，第二段开始一般是回答第一个问题，第二段对第二个问题进行分析，第三段对三个问题分析。一般摘要的三段或四段都是与题目相对应。题目一般都是循序渐进，逐步解决问题。最后就是$\textbf{keywords}$ 这个就主要写所使用的模型。</p><h1 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h1><p>这个没什么好说得，就直接把问题重新再抄写一下就可以了，分为问题背景和问题重述</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>问题分析这部分就是对每个小问题，分别建模讨论使用得模型对所寻找的数据或题目所给的数据进行分析。然后再对得到的数据进行预测建立模型，</p><p>….</p><p>后面的就是独家内容了，嘿嘿嘿。晚点再更新….</p>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用LaTex编写流程图</title>
    <link href="/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/"/>
    <url>/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>简单介绍如何使用$\LaTeX$进行流程图的绘制</p><a id="more"></a><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/img/流程图.png" alt=" "></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="hljs crmsh">\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;tikz&#125; %%主要宏包\usetikzlibrary&#123;shapes,arrows&#125;\begin&#123;document&#125;\pagestyle&#123;empty&#125; % 无页眉页脚\tikzstyle&#123;startstop&#125; = [rectangle,rounded corners, minimum <span class="hljs-attr">width=</span><span class="hljs-number">3</span>cm,minimum <span class="hljs-attr">height=</span><span class="hljs-number">1</span>cm,text centered, <span class="hljs-attr">draw=</span>black,<span class="hljs-attr">fill=</span>red!<span class="hljs-number">30</span>]\tikzstyle&#123;io&#125; = [trapezium, trapezium left angle = <span class="hljs-number">70</span>,trapezium right <span class="hljs-attr">angle=</span><span class="hljs-number">110</span>,minimum <span class="hljs-attr">width=</span><span class="hljs-number">3</span>cm,minimum <span class="hljs-attr">height=</span><span class="hljs-number">1</span>cm,text centered,<span class="hljs-attr">draw=</span>black,<span class="hljs-attr">fill=</span>blue!<span class="hljs-number">30</span>]\tikzstyle&#123;process&#125; = [rectangle,minimum <span class="hljs-attr">width=</span><span class="hljs-number">3</span>cm,minimum <span class="hljs-attr">height=</span><span class="hljs-number">1</span>cm,text centered,text width =<span class="hljs-number">3</span>cm,<span class="hljs-attr">draw=</span>black,<span class="hljs-attr">fill=</span>orange!<span class="hljs-number">30</span>]\tikzstyle&#123;decision&#125; = [diamond,minimum <span class="hljs-attr">width=</span><span class="hljs-number">3</span>cm,minimum <span class="hljs-attr">height=</span><span class="hljs-number">1</span>cm,text centered,<span class="hljs-attr">draw=</span>black,<span class="hljs-attr">fill=</span>green!<span class="hljs-number">30</span>]\tikzstyle&#123;arrow&#125; = [thick,-&gt;,&gt;=stealth]\begin&#123;tikzpicture&#125;[<span class="hljs-keyword">node</span> <span class="hljs-title">distance</span>=<span class="hljs-number">2</span>cm]\<span class="hljs-keyword">node</span> <span class="hljs-title">(start</span>) [startstop] &#123;<span class="hljs-literal">Start</span>&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(input1</span>) [io,below <span class="hljs-attr">of=</span><span class="hljs-literal">start</span>] &#123;Input&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(process1</span>) [process,below <span class="hljs-attr">of=</span>input1] &#123;Process <span class="hljs-number">1</span>&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(decision1</span>) [decision,below <span class="hljs-attr">of=</span>process1,<span class="hljs-attr">yshift=</span>-<span class="hljs-number">0.5</span>cm] &#123;Decession <span class="hljs-number">1</span>&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(process2a</span>) [process,below <span class="hljs-attr">of=</span>decision1,<span class="hljs-attr">yshift=</span>-<span class="hljs-number">0.5</span>cm] &#123;Process <span class="hljs-number">2</span>aaaaaa aaaaaaa aaaa&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(process2b</span>) [process,right of =decision1,<span class="hljs-attr">xshift=</span><span class="hljs-number">2</span>cm] &#123;Process <span class="hljs-number">2</span>b&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(out1</span>) [io,below <span class="hljs-attr">of=</span>process2a] &#123;Output&#125;;\<span class="hljs-keyword">node</span> <span class="hljs-title">(stop</span>) [startstop,below <span class="hljs-attr">of=</span>out1] &#123;<span class="hljs-literal">Stop</span>&#125;;\draw [arrow] (<span class="hljs-literal">start</span>) -- (input1);\draw [arrow] (input1) -- (process1);\draw [arrow] (process1) -- (decision1);\draw [arrow] (decision1) -- <span class="hljs-keyword">node</span><span class="hljs-title">[anchor</span>=east] &#123;yes&#125; (process2a);\draw [arrow] (decision1) -- <span class="hljs-keyword">node</span><span class="hljs-title">[anchor</span>=south] &#123;no&#125; (process2b);\draw [arrow] (process2b) |- (process1);\draw [arrow] (process2a) -- (out1);\draw [arrow] (out1) -- (<span class="hljs-literal">stop</span>);\end&#123;tikzpicture&#125;\end&#123;document&#125;</code></pre><h2 id="using-package"><a href="#using-package" class="headerlink" title="using package"></a>using package</h2><p>$\LaTeX$中绘图均要引入<code>tikz</code>宏包</p><pre><code class="hljs dust"><span class="xml">\usepackage</span><span class="hljs-template-variable">&#123;tikz&#125;</span><span class="xml">\usetikzlibrary</span><span class="hljs-template-variable">&#123;shapes.geometric, arrows&#125;</span></code></pre><h2 id="对节点node进行定义"><a href="#对节点node进行定义" class="headerlink" title="对节点node进行定义"></a>对节点node进行定义</h2><pre><code class="hljs arduino">\tikzstyle&#123;<span class="hljs-built_in">process</span>&#125; = [rectangle,minimum <span class="hljs-built_in">width</span>=<span class="hljs-number">3</span>cm,minimum <span class="hljs-built_in">height</span>=<span class="hljs-number">1</span>cm,<span class="hljs-built_in">text</span> centered,<span class="hljs-built_in">text</span> <span class="hljs-built_in">width</span> =<span class="hljs-number">3</span>cm,draw=black,<span class="hljs-built_in">fill</span>=orange!<span class="hljs-number">30</span>]</code></pre><h3 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h3><pre><code class="hljs avrasm"><span class="hljs-symbol">rectangle:</span>矩形，可加圆角(rounded corners)<span class="hljs-symbol">trapezium:</span>平行四边形<span class="hljs-symbol">diamond:</span>菱形</code></pre><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><pre><code class="hljs arduino">minimum <span class="hljs-built_in">width</span>minimum <span class="hljs-built_in">height</span></code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code class="hljs applescript"><span class="hljs-built_in">text</span> centered:文本居中</code></pre><h3 id="文本宽度"><a href="#文本宽度" class="headerlink" title="文本宽度"></a>文本宽度</h3><pre><code class="hljs apache"><span class="hljs-attribute">text</span> width=<span class="hljs-number">3</span>cm:文本超过<span class="hljs-number">3</span>cm时会自动换行</code></pre><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><pre><code class="hljs ebnf"><span class="hljs-attribute">draw</span></code></pre><h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><pre><code class="hljs arduino"><span class="hljs-built_in">fill</span></code></pre><h2 id="对箭头进行定义"><a href="#对箭头进行定义" class="headerlink" title="对箭头进行定义"></a>对箭头进行定义</h2><pre><code>tikzstyle&#123;arrow&#125; = [thick,-&gt;,&gt;=stealth]</code></pre><h3 id="线粗"><a href="#线粗" class="headerlink" title="线粗"></a>线粗</h3><pre><code>thick:粗thin:细</code></pre><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><pre><code>-&gt;:反向箭头&lt;-:正向箭头&lt;-&gt;:双向箭头</code></pre><h3 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h3><pre><code>dashed</code></pre><h3 id="箭头形状"><a href="#箭头形状" class="headerlink" title="箭头形状"></a>箭头形状</h3><pre><code>&gt;=stealth</code></pre><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><pre><code>\node (decision1) [decision,below of=process1,yshift=-0.5cm] &#123;Decession 1&#125;;</code></pre><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><pre><code>(decision1):这个节点的name，后面需要用这个name调用这个节点。</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>decision：需要调用的节点的属性</code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><pre><code>below of=process1：定义节点的位置left of:right of:</code></pre><h3 id="偏移-对位置进行微调"><a href="#偏移-对位置进行微调" class="headerlink" title="偏移,对位置进行微调"></a>偏移,对位置进行微调</h3><pre><code>yshift:xshift:</code></pre><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><pre><code>&#123;Decession 1&#125;:结果显示的标题</code></pre><h2 id="画箭头"><a href="#画箭头" class="headerlink" title="画箭头"></a>画箭头</h2><pre><code>\draw [arrow] (decision1) -- node[anchor=east] &#123;yes&#125; (process2a);</code></pre><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><pre><code class="lang-[arrow]:需要调用的箭头的属性```">```(decision1)：箭头的其实位置</code></pre><pre><code class="lang-(process2a)：箭头的末端位置```">### 线型<pre><code class="hljs 1c">--：直线<span class="hljs-string">|-：先竖线后横线</span>-<span class="hljs-string">|：向横线后竖线</span></code></pre>### 文字：如果需要在箭头上添加文字```&#123;yes&#125;:需要添加的文字</code></pre><h3 id="文字的位置-上南下北左东右西-与地图方位不一致"><a href="#文字的位置-上南下北左东右西-与地图方位不一致" class="headerlink" title="文字的位置,上南下北左东右西(与地图方位不一致)"></a>文字的位置,上南下北左东右西(与地图方位不一致)</h3><pre><code>[anchor=east]：[anchor=south]：[anchor=west]：[anchor=north]：[anchor=center]：</code></pre>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cellular automata</title>
    <link href="/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>元胞自动机(cellular automata，CA) 是一种时间、空间、状态都离散，空间相互作用和时间因果关系为局部的网格动力学<br>模型，具有模拟复杂系统时空演化过程的能</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>元胞自动机是一个空间和状态都是离散的模型。该模型可以用一个四元组表示：</p><script type="math/tex; mode=display">C=(L_a, S, N_n, f)</script><p>其中：</p><ul><li>$S$表示细胞状态，是一个有限的、离散的状态集合；</li><li>$L_a$表示元胞空间，$a$是一个整数，表示细胞空间的维数；</li><li>$N$表示领域内元素的组合，$n$表示邻居的个数</li><li>$f$表示状态转移函数，即状态转移规则</li></ul><h2 id="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。"><a href="#对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。" class="headerlink" title="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元(有时也称作邻居)。"></a>对于一个元胞，在空间位置上与它相邻的元胞称为它的<strong>邻元</strong>(有时也称作邻居)。</h2><p>邻域和邻元的定义可以是多样的</p><p>下图为一维CA网格邻域定义<br><img src="/img/一维CA网格.png" alt=" "></p><p>下图为二维CA网格邻域定义<br><img src="/img/二维CA网格.png" alt=" "></p><p>每个元胞有若干个状态，如：</p><ul><li>物理系统：（分子）固态，液态</li><li>生物系统：（细胞）死or活</li><li>社会系统： （个人）相信与不相信谎言</li><li>政治系统： （国家）战争与妥协…</li></ul><hr><p>&emsp;&emsp;在各种CA模型中，每个等份（单元格）代表一个元胞，CA的网格可以有不同的形式(维数，大小)。</p><ul><li>一维的CA模型是将直线分成若干相同的等份；</li><li>二维的CA模型是将一个平面分成许多正方形、六边形或三角行的网格（最常见的是将其划分成正方形）；</li><li>三位的CA模型将空间划分成许多立体网格。</li></ul><p><img src="/img/一维CA模型.png" alt=" "> &emsp;&emsp; <img src="/img/二维CA模型.png" alt=" "></p><hr><p>根据每个元胞及邻元的不同状态，由于状态更新规则决定这个元胞下一个时刻的状态。</p><p>序号$i$个体在$t=1,\dots,n$时刻的状态:</p><script type="math/tex; mode=display">S_t^{t+1}=f(S_i^t,N^t)=f(S_i^t,S_1^t,S_2^t,\dots,S_n^t)</script><p>其中$S_i^t,S_1^t,S_2^t,\dots,S_n^t$为个体$i$的邻元在$t$时刻的状态。</p><hr><p>规则可以是确定型的，也可以是随机型的。对于一个一维的CA，一个细胞具有两种可能的状态如生or死，相信或者不相信等等，表示为0or1.<br>如果规则一：我使用下图的左边的邻元定义<br>定义其状态更新规则：当一个个体的两个邻元都活或都死，该个体在下一时刻为死；反之，他的状态在下一时刻变为活。<br><img src="/img/规则表.png" alt=" "></p><p>再如规则二：我仍然使用当前左边邻元定义，但重新定义其状态<br>更新规则为：当个体的两个邻元都活或都死，该个体再下一时刻<strong>改变状态</strong>;反之，<strong>该个体的状态在下一时刻保持不变</strong>。<br><img src="/img/规则表（2）.png" alt=" "></p><hr><p>模型的构建</p><p>考虑以下问题：</p><ul><li>确定系统中有那些个体，如何分类？</li><li>个体有几种状态，分别是什么；</li><li>个体所处空间形式，是一位，二维还是多为；</li><li>个体的邻元形式及个数，这与网格形式及交互群体规模有关</li><li>根据个体状态、网格形式及邻元，确定个体状态的演变规则。<br>此外，还需确定：</li><li>系统中的个体与单元格是否一致。<br>简单的、经典的CA模型中，单元格与个体不加区分，每个单位格就是一个个体，个体始终在单元格中，个体的状态即为单元格的状态。但在一些复杂系统中，尤其在个体可以移动的系统中，将个体与单元格区分更为方便。</li><li>系统中是否离散事件。<br>采用CA模型描述的系统，每个时刻都需根据规则确定伟哥元胞的状态。除此之外，有的系统中某些个体会在特定时刻（有条件或无条件）发生状态变化，此时可以采用离散时间仿真方法，将该时刻列入事件表，根据事件表处理该类事件。</li></ul><font color="#f4f4f4"><a href="https://wenku.baidu.com/view/86050cb9aeaad1f347933f28.html">推荐</a></font><font color="#f4f4f4">python 库中pandas 如果使用 pip install pandas 可以能会无法下载。如果无法下载则使用</font><pre><code class="hljs routeros">pip <span class="hljs-attribute">--default-time</span>=100 install pandas</code></pre><font color="#f4f4f4">这行命令，可以进行下载。</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力-2</title>
    <link href="/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148814143&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;First a city with a population of 11 million was shut down and than a country of 1.4 billion people came to a halt. Most people have shown concern and understanding. Whenever there is a public health concern, people tend to react strongly, however some have allowed the fear to turn into bias. But sometimes the reaction is over the top. people have effectively closed borders, shouted hateful words and drive others away indiscriminately. Some have called the novel coronavirus the China Virus. We wrongly called the 1918 pandemic the Spanish Flu, and with better knowledge and conscience we never call AIDS or Ebola an African virus, because we don’t want people to associate a pathogen with a place or people, and we shouldn’t.<br>&emsp;&emsp;Coronacirus is feeding bias and discrimination against people, people from Wuhan and China, people across the aisle and in the neighborhood. It is understandable that people are panicking in the face of a big unknown. But we have a rough idea about this virus; it is highly infectious, and not as deadly as SARS. We wash hands, wear masks, keep our hygiene and keep ourselves happy to let the immune system do its work. Draconian isolation policy during the 14-day incubation will help us identify more cases. And hopefully the virus will burn out eventually or its impact will be mitigated when our immune systems with the help of supportive care will win out at last.<br>&emsp;&emsp;But discrimination will take its toll. The disregard of AIDS patients during the 1970s drove them underground and undetected, resulting in a large outbreak. And similar messaging on Ebola<br>made matters worse in 2014 in West Africa. In history we have treated leprosy, AIDS and even flu patients like outcast, partly because we were unable to deal with the disease, but largely because we could not understand the threat. But now we do.<br>&emsp;&emsp;Virus know no boundaries, be it AIDS, the flu SARS or 2019-nCoV. An epidemic of global scale demands the sharing of information, resources and moral support. Quarantines might work for a while, but it won’t last and it won’t solve all problems. We are now in a gigantic prisoner’s dilemma, the incentive to turn against each other is so strong even though banding together works better. Bias hurts your interests, you just don’t know yet.<br>&emsp;&emsp;In our modern, borderless world. We aren’t living in villages anymore. Even though we may pay a price dealing with strangers, we still do and we are better off because of it. </p><p><i>This is the time for facts, not fear. This is the time for science, not rumors. This is the time for solidarity, not stigma.</i><br>$\textbf{Dr.Tedros Adhanom Gheberyesus}—Director-General World Health Organization$</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wget、yum、rpm、apt-get都是啥？</title>
    <link href="/2020/02/27/yum/"/>
    <url>/2020/02/27/yum/</url>
    
    <content type="html"><![CDATA[<p>简略介绍wget、yum、rpm、apt-get。<br>详细了解yum</p><a id="more"></a><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p><strong>wget</strong>:类似于迅雷，是一种<code>下载工具</code>，通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理 名字是World Wide Web”与“get”的结合。</p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><strong>yum</strong>: 是redhat, centos 系统下的<code>软件安装方式</code>，基于Linux,全称为 Yellow dog Updater, Modified,是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器,基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><h3 id="yum常用选项和参数"><a href="#yum常用选项和参数" class="headerlink" title="yum常用选项和参数"></a>yum常用选项和参数</h3><h4 id="列举包文件"><a href="#列举包文件" class="headerlink" title="列举包文件"></a>列举包文件</h4><hr><pre><code class="hljs mipsasm">yum list <span class="hljs-comment">#列出资源库中所有可以安装或更新的rpm包</span>yum list updates　<span class="hljs-comment">#列出资源库中所有可以更新的rpm包</span>yum list <span class="hljs-keyword">installed　</span>　<span class="hljs-comment">#列出已经安装的所有的rpm包</span>yum list <span class="hljs-keyword">extras　</span>　<span class="hljs-comment">#列出已经安装的但是不包含在官方资源库中的rpm包，例如安装了epel源的rpm包会列出来</span></code></pre><h4 id="列举资源信息"><a href="#列举资源信息" class="headerlink" title="列举资源信息"></a>列举资源信息</h4><hr><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> <span class="hljs-literal">info</span>　　<span class="hljs-comment">#列出资源库中所有可以安装或更新的rpm包的信息</span>yum <span class="hljs-literal">info</span> perl　　<span class="hljs-comment">#列出perl包信息</span>yum <span class="hljs-literal">info</span> perl*　　<span class="hljs-comment">#列出perl开头的所有包的信息</span>yum <span class="hljs-literal">info</span> updates　　<span class="hljs-comment">#列出资源库中所有可以更新的rpm包的信息</span>yum <span class="hljs-literal">info</span> installed　　<span class="hljs-comment">#列出已经安装的所有的rpm包的信息</span>yum <span class="hljs-literal">info</span> extras　　<span class="hljs-comment">#列出已经安装的但是不包含在资源库中的rpm包的信息</span></code></pre><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><hr><pre><code class="hljs jboss-cli">yum search perl　<span class="hljs-comment">#搜索匹配特定字符的rpm包，在包名称、包描述等中搜索</span>yum provides libstdc++<span class="hljs-string">.so.6</span>　　<span class="hljs-comment">#反查包含特定文件名的rpm包，查询命令用yum provides */ifconfig，查询文件无需*/ 也可用yum whatprovides</span></code></pre><h4 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h4><hr><ul><li>安装rpm包<pre><code class="hljs vim">yum install <span class="hljs-keyword">perl</span>　　#安装<span class="hljs-keyword">perl</span>包yum install <span class="hljs-keyword">perl</span>*　　#安装<span class="hljs-keyword">perl</span>开头的包yum <span class="hljs-built_in">remove</span> <span class="hljs-keyword">perl</span>* 　　#会删除<span class="hljs-keyword">perl</span>* 所有包，以及相关依赖的包</code></pre></li><li>软件组件管理<pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> groupinstall <span class="hljs-string">&quot;Chinese Support&quot;</span>　　<span class="hljs-comment">#安装指定的组</span>yum groupupdate <span class="hljs-string">&quot;Chinese Support&quot;</span>　　<span class="hljs-comment">#安装了的组成员软件包更新</span>yum grouplist　　<span class="hljs-comment">#安装了的组和可以安装的组一览显示</span>yum groupremove <span class="hljs-string">&quot;Chinese Support&quot;</span>　　<span class="hljs-comment">#删除指定的组</span>yum groupinfo <span class="hljs-string">&quot;Chinese Support&quot;</span>　　<span class="hljs-comment">#指定组所包含的软件包显示</span></code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4></li></ul><hr><pre><code class="hljs smali">yum<span class="hljs-built_in"> check-update　</span>　<span class="hljs-comment">#检查可更新的rpm包</span>yum update　　<span class="hljs-comment">#更新所有的rpm包</span>yum update kernel kernel-source　　<span class="hljs-comment">#更新指定的rpm包,如更新kernel和kernel source</span>yum upgrade　　<span class="hljs-comment">#大规模的版本升级,与yum update不同的是,连旧的淘汰的包也升级</span></code></pre><h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><hr><pre><code class="hljs glsl">yum clean packages　　<span class="hljs-meta">#清除暂存中rpm包文件</span>yum clean headers　　<span class="hljs-meta">#清除暂存中rpm头文件</span>yum clean oldheaders　　<span class="hljs-meta">#清除暂存中旧的rpm头文件</span>yum clean <span class="hljs-built_in">all</span>　　<span class="hljs-meta">#清除暂存中旧的rpm头文件和包文件</span></code></pre><h4 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h4><pre><code class="hljs haml">-<span class="ruby">q <span class="hljs-comment">#静默执行</span></span><span class="ruby">-t <span class="hljs-comment">#忽略错误</span></span><span class="ruby">-R[分钟] <span class="hljs-comment">#设置等待时间</span></span><span class="ruby">-y <span class="hljs-comment">#自动应答yes</span></span><span class="ruby">--skip-broken <span class="hljs-comment">#忽略依赖问题</span></span><span class="ruby">--nogpgcheck <span class="hljs-comment">#忽略GPG验证</span></span></code></pre><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p><code>rpm</code>:软件管理;</p><p>redhat的软件格式 <code>rpm</code>  <code>r=redhat</code>  <code>p=package</code>   <code>m=management</code> 用于安装 卸载 <code>.rpm</code>软件</p><p>串联下：<br>&emsp;&emsp;使用<code>wget</code>下载一个 <code>rpm</code>包, 然后用<code>rpm -ivh xxx.rpm</code> 安装这个软件，嫌麻烦的话，就可以直接用 <code>yum  install  sqoop</code> 来自动下载和安装依赖的 <code>rpm</code>软件。</p><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p><code>apt-get</code>:是ubuntu下的一个软件安装方式，它是基于debain.</p><h2 id="通过yum安装工具"><a href="#通过yum安装工具" class="headerlink" title="通过yum安装工具"></a>通过yum安装工具</h2><h3 id="在Centos上安装gcc"><a href="#在Centos上安装gcc" class="headerlink" title="在Centos上安装gcc"></a>在Centos上安装gcc</h3><p>安装gcc</p><blockquote><p>yum -y install gcc</p></blockquote><p>安装g++</p><blockquote><p>yum -y install gcc-c++  </p></blockquote><h3 id="在Centos上安装目录生成树工具tree"><a href="#在Centos上安装目录生成树工具tree" class="headerlink" title="在Centos上安装目录生成树工具tree"></a>在Centos上安装目录生成树工具tree</h3><p>安装tree</p><blockquote><p>yum -y install tree</p></blockquote><p>同通过tree工具可以很快的查看目录树</p><h4 id="关于tree命令选项"><a href="#关于tree命令选项" class="headerlink" title="关于tree命令选项"></a>关于tree命令选项</h4><ul><li><code>-a</code> 显示所有文件和目录。</li><li><code>-A</code> 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li><li><code>-C</code> 在文件和目录清单加上色彩，便于区分各种类型。</li><li><code>-d</code> 显示目录名称而非内容。</li><li><code>-D</code> 列出文件或目录的更改时间。W</li><li><code>-f</code> 在每个文件或目录之前，显示完整的相对路径名称。</li><li><code>-F</code> 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/”,”=”,”@”,”|”号。</li><li><code>-g</code> 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li><li><code>-i</code> 不以阶梯状列出文件或目录名称。</li><li><code>-I</code>&lt;范本样式&gt; 不显示符合范本样式的文件或目录名称。</li><li><code>-l</code> 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li><li><code>-n</code> 不在文件和目录清单加上色彩。</li><li><code>-N</code> 直接列出文件和目录名称，包括控制字符。</li><li><code>-p</code> 列出权限标示。</li><li><code>-P</code>&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</li><li><code>-q</code> 用”?”号取代控制字符，列出文件和目录名称。</li><li><code>-s</code> 列出文件或目录大小。</li><li><code>-t</code> 用文件和目录的更改时间排序。</li><li><code>-u</code> 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li><li><code>-x</code> 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li></ul><h4 id="在Centos下安装git"><a href="#在Centos下安装git" class="headerlink" title="在Centos下安装git"></a>在Centos下安装git</h4><p>首先检查机器上是否有git</p><blockquote><p>git —version</p></blockquote><p>如果出现了版本号则说明有<code>git</code>，如果是<code>bash：git：no found command</code>则说明没有<code>git</code>。</p><p>如果没有git工具：</p><blockquote><p>yum info git #查看<code>yum</code>源中的<code>git</code>版本<br>yum -y install git #安装git</p></blockquote><p>当出现<code>complete！</code>就表明安装完成</p><h4 id="在Centos下升级vim"><a href="#在Centos下升级vim" class="headerlink" title="在Centos下升级vim"></a>在Centos下升级vim</h4><h5 id="检查机器上是否有vim"><a href="#检查机器上是否有vim" class="headerlink" title="检查机器上是否有vim"></a>检查机器上是否有vim</h5><blockquote><p>rpm -qa|grep vim</p><p>如果以安装则会显示<br>vim-minimal-7.4.629-6.el7.x86_64<br>vim-filesystem-7.4.629-6.el7.x86_64<br>vim-enhanced-7.4.629-6.el7.x86_64<br>vim-common-7.4.629-6.el7.x86_64<br>vim-X11-7.4.629-6.el7.x86_64</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，则执行：<br>yum -y install vim-enhanced</p></blockquote><p>它会自动下载安装。如果上面三个包一个都没有显示，则直接输入命令：   </p><blockquote><p>yum -y install vim*</p></blockquote><h5 id="检查vim版本"><a href="#检查vim版本" class="headerlink" title="检查vim版本"></a>检查vim版本</h5><blockquote><p>vim —version</p></blockquote><p>如果想升级更高版本的vim</p><pre><code>sudo yum remove vim -y # 移除旧版本sudo yum install ncurses-devel python-devel -y # 安装必要组件git clone https://github.com/vim/vim.git  #下载源码编译安装cd vim/src./configure --with-features=huge --enable-pythoninterp=yes --enable-cscope --enable-fontset --with-python-config-dir=/usr/lib64/python2.7/config --enable-python3interp=yes --with-python-config-dir=/usr/lib/python3.6/config --enable-multibyte --prefix=/usr/local/vim/ # 根据自己实际情况设置编译参数make -j2 &amp;&amp; make install</code></pre><h1 id="conda环境"><a href="#conda环境" class="headerlink" title="conda环境"></a>conda环境</h1><h2 id="进入虚拟环境，使用"><a href="#进入虚拟环境，使用" class="headerlink" title="进入虚拟环境，使用"></a>进入虚拟环境，使用</h2><pre><code> $ conda activate spider-venv</code></pre><h2 id="退出虚拟环境，使用"><a href="#退出虚拟环境，使用" class="headerlink" title="退出虚拟环境，使用"></a>退出虚拟环境，使用</h2><pre><code> $ conda deactivate</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Centos</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力</title>
    <link href="/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/"/>
    <url>/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148815381&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" ></iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;It has been a month since Wuhan was <code>locked down</code> because of the <code>coronavirus</code>. Like a big <code>push on</code> a swing, the <code>epidemic</code> <code>tips</code> the balance in the world, and China is making effort to keep standing. The challenge <code>lies in</code> the country’s size, China is a big country with a large span, and the virus hit the center, <code>literally</code>. The <code>epicenter</code> is a <code>metropolis</code> of 16 million people in the middle of the country. To make matters worse, it is surrounded by many cities, also with millions of inhabitants.<br>&emsp;&emsp;Wuhan is a transport hub, and the virus is threatening to infect the whole surrounding area. The size of the country is a significant obstacle. But that’s only half the story. Because of its continental size, all the parts feed off each other. When Wuhan fell, the other provinces came to its aid.<br>&emsp;&emsp;As we speak, one-tenth of the intensive care doctors of the entire country is in Wuhan. A total of 40,000 medical staff moved to the center in a wartime fashion. China plans to take the virus full on.<br>&emsp;&emsp;Structure matters, another weight on scale is messaging. China has two-way traffic of communication, top-down and bottom-up. China is to do better bottom-up. When doctors in Wuhan sounded alarms of the new virus, the message got lost. An investigation is still ongoing on why. But one reason is obvious: there are too many layers, too much red tape, and too little incentives to send the messages up.<br>&emsp;&emsp;But China is strong when it comes to top-down messages. When the leadership is on the top of the problem, it has the willpower and wherewithal to make the call. And the grassroots answer. China launched a people’s war. That was exactly what was needed to deal with a traveling threat like an epidemic. China built two hospitals in 10 days, thousands of wards in a week, and shook the population into action. Top-down is fast and sharp. Nobody should argue against efficiency, especially when what’s at shake is a plague spreading. But keeping the balance is hard.<br>&emsp;&emsp; Every decision is a trade-off when it affects the lives of thousands and the livelihood of millions. We need to slow the spread. Draconian quarantines are being enforced in many parts of the country. Maintain a large network of isolation and a low rate of rogue behavior is the answer; the question is we still don’t know the exact extent of the infection. Isolating the infected while not infringing on people’s rights and decency is not an easy task.<br>&emsp;&emsp;Our economy relies on human transaction, but epidemic control depends on social distancing. We need to keep a distance, and yet we need to work together. So how do we balance saving lives and the saving economy? This is an issue that requires hard decision making. But the hardest is when to draw the line. With so little information on an adversary like the virus and so few weapons at out disposal, without treatment or vaccines, we are not able to answer the public’s question: when does it end?<br>&emsp;&emsp;Before the end of the Second World War, Winston Churchill described the war like this: <code>Victory at all costs, victory in spite of all terror, victory however long and hard the road may be, for without victory, there is no survival. Now, we are at war with a virus. And victory is still ahead of us</code>. Luckily, we still have a big country to fall back on, a world that lifts us, and s system that delivers results. There will be more hard decisions to be made. In the end, we hope those will be the best choices, and we must be proud of them. </p><hr><h3 id="词句"><a href="#词句" class="headerlink" title="词句"></a>词句</h3><ul><li><strong>locked down</strong>:锁定，封锁.</li><li><strong>coronavirus</strong>:n. 冠状病毒.</li><li><strong>push on</strong>: 推， 推进.</li><li><strong>epidemic</strong>: [ˌepɪˈdemɪk] n.流行病;(迅速的)泛滥，蔓延; adj.流行性的;极为盛行的.</li><li><strong>tip</strong>: n.尖端;尖儿;端;(装在顶端的)小部件;指点;实用的提示;</li><li><strong>lie in</strong>: 在于; lie(平躺， 撒谎).</li><li><strong>literally</strong>: adv.按字面;字面上;(强调事实可能令人惊讶)真正地，确实地;(加强即使字面意义并不真实的词语)简直;</li></ul><font size="3" color="#c2cb81"> 若有错误请在评论区指正！蟹蟹大家</font>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器</title>
    <link href="/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/"/>
    <url>/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/</url>
    
    <content type="html"><![CDATA[<p>容器简介</p><a id="more"></a><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="概述"><a href="#概述" class="headerlink" title="- 概述"></a>- 概述</h3><ul><li>Vector是一个能够存放任意类型的动态数组</li><li>Vector的数据结构和操作与数组(array)类似，在内存中的表现形式是一段地址连续的空间</li><li>Vector与数组的区别在于，数组大小往往是定义是固定的(比如：char buffer[256]);Vec支持动态空间大小调整，随着空间的变化Vector内部会自动扩充内存空间</li><li>为了试用Vector，必须试用include指令包含该头文件,并通过std空间去访问：<pre><code class="hljs cpp">include &lt;<span class="hljs-built_in">vector</span>&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span> v;&#125;</code></pre></li></ul><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空vector</td><td>std :: vector<T> v;</td></tr><tr><td>创建一个容器是n的T类型的vector</td><td>std :: vector<T> v(n);</td></tr><tr><td>创建一个容量是n的T类型的vector，并且都初始化为i</td><td>std :: vector<T> n(n, i);</td></tr><tr><td>创建一个已有v的拷贝</td><td>std :: vector<T> copyOfV(v);</td></tr><tr><td>荣国一个数组创建一个vector</td><td>int array[] = {1,2,3}; std :: vector<int> v(array, array + 10);</td></tr></tbody></table></div><h3 id="向vector添加元素"><a href="#向vector添加元素" class="headerlink" title="向vector添加元素"></a>向vector添加元素</h3><p>向vector添加元素的方法为调用其push_back()函数，表示将元素添加至其尾部：<br><pre><code class="hljs cpp"><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span> &lt;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>&gt; v3;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++ i) &#123;    <span class="hljs-built_in">std</span> :: wstringstream wss;    wss &lt;&lt; TEXT(<span class="hljs-string">&quot;String[&quot;</span>) &lt;&lt; i &lt;&lt; TEXT(<span class="hljs-string">&quot;]&quot;</span>);    v3.push_back(wss.str());&#125;</code></pre></p><h3 id="判断vector是否为空、获取vector大小"><a href="#判断vector是否为空、获取vector大小" class="headerlink" title="判断vector是否为空、获取vector大小"></a>判断vector是否为空、获取vector大小</h3><ul><li>如果要判断vector是否为空则调用empty()函数</li><li>如果要获取vector大小则调用size()函数<pre><code class="hljs arduino"><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span> &lt;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>&gt; v3;<span class="hljs-keyword">bool</span> isEmpty = v3.empty();<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<span class="hljs-built_in">std</span> :: <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-built_in">array</span>, <span class="hljs-built_in">array</span> + <span class="hljs-number">10</span>)</span></span><span class="hljs-function"><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">size</span> vSize </span>= v.<span class="hljs-built_in">size</span>();</code></pre></li></ul><h3 id="访问vector中元素"><a href="#访问vector中元素" class="headerlink" title="访问vector中元素"></a>访问vector中元素</h3><ul><li>要访问vector中的元素, 有两种方法：<ul><li>调用vector :: at()</li><li>调用vector :: operator[]</li></ul></li><li>两者的区别在于：<ul><li>operator[]提供了类似数组的存取方式，但不做边界的检查，有可能越界，但访问效率更高</li><li>at()进行边界检查，如果访问越界则抛出exception，但是访问效率不如operator[]</li></ul></li></ul><pre><code class="hljs arduino"><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&gt; v;v.reserve(<span class="hljs-number">10</span>);<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++ i) &#123;    <span class="hljs-built_in">std</span> :: wstringstream wss;    wss &lt;&lt; TEXT(<span class="hljs-string">&quot;String[&quot;</span>) &lt;&lt; i &lt;&lt; TEXT(<span class="hljs-string">&quot;]&quot;</span>);    v.push_back(wss.str());&#125;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> wsz1 = v[<span class="hljs-number">5</span>]; <span class="hljs-comment">// not bounds checked -will not throw</span>    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> wsz2 = v.at(<span class="hljs-number">5</span>); <span class="hljs-comment">// bounds checked -will throw if out of range</span>&#125;<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span> :: exception&amp; ex) &#123;    <span class="hljs-built_in">Console</span> :: WriteLine(ex.what());&#125;</code></pre><h3 id="删除vector中的元素"><a href="#删除vector中的元素" class="headerlink" title="删除vector中的元素"></a>删除vector中的元素</h3><ul><li>clear：清除一整个vector</li><li>pop_back：弹出vector为元素</li><li>erase:删除vector中某一位置的元素<ul><li>用法一：指定iterator删除某一元素<pre><code class="hljs arduino"><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; :: const_iterator it = v.<span class="hljs-built_in">begin</span>();v.erase(it + <span class="hljs-number">1</span>); <span class="hljs-comment">// erase the second element in the Vector</span></code></pre></li><li>用法二：通过某一条件函数找到vector中需要删除的元素。所谓条件函数是一个按照用户定义的条件返回true/false的函数对象。我们以remove_if为例说明。</li><li>remove_if函数定义在algorithm中，故需要include<algorithm></li><li>定义筛选器：一个一元函数对象(unary_function),关键在于重载operator()<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContainsString</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">std</span> :: unary_function &lt;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>, <span class="hljs-keyword">bool</span>&gt; &#123;    ContainsString (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&amp; wszMatch) : m_wszMatch(wszMatch) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>&amp; wszStringToMatch)</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//注意因为它重载了()所以可以当一个函数来用</span>        <span class="hljs-keyword">return</span> (wszStringToMatch.<span class="hljs-built_in">find</span>(m_wszMatch) != <span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> m_wszMatch;&#125;</code></pre></li><li>在erase函数中调用remove_if执行删除:<pre><code class="hljs arduino">v.erase (<span class="hljs-built_in">std</span> :: remove_if (    v.<span class="hljs-built_in">begin</span>(),    v.<span class="hljs-built_in">end</span>(),    ContainsString (<span class="hljs-string">L&quot;C++&quot;</span>)),  v.<span class="hljs-built_in">end</span>());</code></pre></li><li>remove_if是不是真正remove了vector中的元素呢？<br>remove_if其实真正的做的事针对ContainsString条件对给出了erase函数需要操作的iterator位置。</li></ul></li></ul><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><ul><li>概述<ul><li>Deque事一个能够存放任意类型的双向队列</li><li>Deque提供的函数与vector类似，新增了两个函数：<ul><li>push_front:在头部插入一个元素</li><li>pop_front： 在头部弹出一个元素</li></ul></li><li>Deque采用了与vector不同的内存管理方式：大块分配内存</li><li>为了试用deque，必须用include质量包含如下文件，并通过std命名空间访问：<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">deque</span> dq;&#125;</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li></ul></li><li>概述<ul><li>List是一个能够存放任意类型的双向链表(double linked list)</li><li>可以向List中接入一个子链表(sub-list)</li><li>为了使用List，必须使用include指令包含如下文件，并通过std命名空间去访问：<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">list</span> l;&#125;</code></pre></li></ul></li></ul><p>创建List</p><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空list</td><td>std :: list<T> l;</td></tr><tr><td>创建一个容量是n的T类型的list</td><td>std :: list<T> l(n);</td></tr><tr><td>创建一个容量是n的T类型的list，并且初始化都为x</td><td>std :: list<T> l(n, x);</td></tr><tr><td>创建一个已有list的拷贝</td><td>std :: list<T> copyOfList(l);</td></tr><tr><td>通过一个数组创建一个list</td><td>std :: wstring array[] = {1,2,3}; std :: list<std::wstring> l(array, array + 3)</td></tr></tbody></table></div><ul><li>向list添加元素<ul><li>向list添加元素的方式为调用其push_back, push_front函数将元素添加至其尾部或头部</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型编程</title>
    <link href="/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/"/>
    <url>/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/</url>
    
    <content type="html"><![CDATA[<p>泛型编程</p><a id="more"></a><h1 id="泛型编程-概观"><a href="#泛型编程-概观" class="headerlink" title="泛型编程-概观"></a>泛型编程-概观</h1><ul><li>泛型编程(Generic programming) 是一种编程方法，这种方法将类型(type)以一种to-be-specified-later的方式给出，等到需要调用的时候，再以参数方式，通过具体的、特定的类别实例化(instantiate)一个具体的方法或对象</li><li>泛型编程作为一种编程的想法或思想，不依赖具体的语言</li><li>大多数面向对象的语言(O O languages)都支持泛型编程，(只不过在C++种以模板的这种形式表现出来)比如：C++、C#、Java、Ada….</li><li>C++里面的泛型是通过<strong>模板</strong>以及相关性质表现出来</li></ul><h1 id="特性-Traits"><a href="#特性-Traits" class="headerlink" title="特性(Traits)"></a>特性(Traits)</h1><h2 id="什么是traits以及为什么使用traits？"><a href="#什么是traits以及为什么使用traits？" class="headerlink" title="- 什么是traits以及为什么使用traits？"></a>- 什么是traits以及为什么使用traits？</h2><p>  假设给定一个数组，计算数组种所有元素的和：<br>  A[0] | A[1] |…| A[n] &emsp;&emsp;$\sum_{k=0}^n A[k]$</p><ul><li><p>我们可以很直接地写出如下的计算函数:</p><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">inline</span> T <span class="hljs-title">Sigma</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>* start, <span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>* <span class="hljs-built_in">end</span>)</span> </span>&#123;    T total = T(); <span class="hljs-comment">// suppose T() actually creates a zero value</span>    <span class="hljs-comment">//T()是一个构造函数目的将total初始化为0；</span>        <span class="hljs-keyword">while</span> (start != <span class="hljs-built_in">end</span>) &#123;        total += *start ++ ;    &#125;    <span class="hljs-keyword">return</span> total;&#125;</code></pre></li><li><p>当我们使用char类型调用模板函数是，问题就来了：</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> szNames[] = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> nLength = <span class="hljs-built_in">strlen</span>(szNames);<span class="hljs-keyword">char</span>* p = szNames;<span class="hljs-keyword">char</span>* q = szNames + nLength;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sigma(ezNames) = %d\n&quot;</span>, Sigma(p,q));</code></pre><script type="math/tex; mode=display">294 = 0x0126</script><script type="math/tex; mode=display">0000 | 0001 | 0010 | 0110</script><p>Char类型能hold住的最大值为0xFF = 255 也就是两个字节所以0010和0110可容纳的但是abc加起来<strong>大于255</strong>就溢出到溢出到1这个bit</p></li><li><p>调用Sigma(szNames)的结果是38( = 0x26)!而并不是所期望的值(97 + 98 + 99 = 294)</p></li><li>原因显而易见的：char无法存下这个294这个值</li><li>如果要得到正确的结果，我们就不得不强制使用int类型：<pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> s = Sigma&lt;<span class="hljs-built_in">int</span>&gt;(p,q);</code></pre></li><li>但是这种不必要的转换是完全可以避免的!</li><li>解决方法是：为每个Sigma函数的参数类型T创建一种关联(association)，关联的类别就是用来储存Sigma结果的类型</li><li>这种关联可以看作是类型T的一种特性(characteristic fo the type T),因为sigma函数返回值的类型叫做T的trait</li><li>T与其trait的关系推演如下：<br>T -&gt; association -&gt; characteristic of T -&gt; another type -&gt; trait</li><li>Traits可以实现为模板类，而关联(association)则是针对每个具体类型T的特化。在这个例子里我们将trait命名为SigmaTraits, 叫做traits模板(traits template)</li></ul><p>Traits实现：<br><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span> &#123;</span> &#125;;<span class="hljs-comment">//可以人为的将返回的数值边得相对的大</span><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span>&lt;</span><span class="hljs-keyword">char</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ReturnType;&#125;;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span>&lt;</span><span class="hljs-keyword">short</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ReturnType;&#125;;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span>&lt;</span><span class="hljs-keyword">int</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> ReturnType;&#125;;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span>&lt;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ReturnType;&#125;;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SigmaTraits</span>&lt;</span><span class="hljs-keyword">float</span>&gt; &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> ReturnType;&#125;;</code></pre></p><ul><li>模板类SigmaTraits叫做traits template， 它含有其参数类型T的一个特性(trait), 即ReturnType</li><li><p>现在Sigma函数可以改写成:</p><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">typename</span> SigmaTraits&lt;T&gt; :: <span class="hljs-function">ReturnType <span class="hljs-title">Sigma</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>* start, <span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>* <span class="hljs-built_in">end</span>)</span> </span>&#123;    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> SigmaTraits&lt;T&gt; :: ReturnType ReturnType;    ReturnType s = ReturnType();    <span class="hljs-keyword">while</span> (start != <span class="hljs-built_in">end</span>) &#123;        s += *start ++;    &#125;    <span class="hljs-keyword">return</span> s;&#125;</code></pre></li></ul><h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h1><h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><p>迭代器是指针的泛化(generalization of pointers)</p><ul><li>迭代器本身就是一个对象，指向另外一个(可以被迭代的)对象</li><li>用来迭代一组对象，即如果迭代器指向一组对象种的某个元素，则通过increment以后它就可以指向下组对象中的下一个元素</li></ul><h2 id="在STL中迭代器是容器与算法之前的接口"><a href="#在STL中迭代器是容器与算法之前的接口" class="headerlink" title="在STL中迭代器是容器与算法之前的接口"></a>在STL中迭代器是容器与算法之前的接口</h2><ul><li>算法通常以迭代器作为输入参数</li><li>容器只要提供一种方式，可以让迭代器访问容器中的元素即可</li></ul><h2 id="迭代器的基本思想"><a href="#迭代器的基本思想" class="headerlink" title="迭代器的基本思想"></a>迭代器的基本思想</h2><ul><li>在STL中，迭代器最终要的思想就是分离算法和容器，使之不需要相互依赖</li><li><p>迭代器将算法和容器粘合(stick)在一起从而使得一种算法的实现可以运用到多种不同的容器上，如下面的例子,find算法接受一对迭代器，分别指向容器的开始位置和最终位置</p><pre><code class="hljs sqf">template &lt;<span class="hljs-built_in">typename</span> <span class="hljs-variable">_InIt</span>, <span class="hljs-built_in">typename</span> <span class="hljs-variable">_Ty</span>&gt;inline <span class="hljs-variable">_InIt</span> <span class="hljs-built_in">find</span>(<span class="hljs-variable">_InIt</span> <span class="hljs-variable">_First</span>, <span class="hljs-variable">_InIt</span> <span class="hljs-variable">_Last</span>, const <span class="hljs-variable">_Ty</span>&amp; <span class="hljs-variable">_Val</span>) &#123;    <span class="hljs-comment">//find first matching _Val</span>    <span class="hljs-keyword">for</span> (; <span class="hljs-variable">_First</span> != <span class="hljs-variable">_Last</span>; ++<span class="hljs-variable">_First</span>) &#123;        <span class="hljs-keyword">if</span> (*<span class="hljs-variable">_First</span> == <span class="hljs-variable">_Val</span>)          break;    &#125;    return (<span class="hljs-variable">_First</span>);&#125;</code></pre><p>find算法对于不同的容器，比如vector, list, deque均适用：</p><pre><code class="hljs arduino"><span class="hljs-built_in">std</span> :: <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(...)</span></span>;<span class="hljs-built_in">std</span> :: <span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(...)</span></span>;<span class="hljs-built_in">std</span> :: <span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(...)</span></span>;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; :: iterator itv = <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), elementToFind)<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; :: iterator itl = <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">find</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), elementToFind)<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; :: iterator it3 = <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">find</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), elementToFind)</code></pre><p>每种容器都有其对应的迭代器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类模板与操作符重载</title>
    <link href="/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-类模板"><a href="#C-类模板" class="headerlink" title="C++类模板"></a>C++类模板</h1><ul><li>与函数模板类似， 类页可以通过参数泛化，从而可以构建出一族不同类型的类实例</li><li>类模板参数可以是某一类型或常量（仅限int或者enum）</li></ul><p>一个类模板的例子：Stack<T><br><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> DefaultStackSize = <span class="hljs-number">1024</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> n = DefaultStackSize&gt;class Stack &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">void</span> Push(<span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>&amp; element);    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(T&amp; element)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Top</span><span class="hljs-params">(T&amp; element)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; m_Members;    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> m_nMaxSize = n;&#125;;</code></pre></p><ul><li>T可以是任意类别</li><li>模板实参也可以是一个int或enum的常量(此处是size_t, 本质是int类型)</li><li>n是编译时定义的常量</li><li>n可以有默认值</li><li>size_t类别的成员变量可以用n初始化</li></ul><h2 id="类模板的声明"><a href="#类模板的声明" class="headerlink" title="- 类模板的声明"></a>- 类模板的声明</h2><ul><li>声明类模板与申明函数模板类似</li><li><p>关键字class和typename都可以用，但是还是更倾向于去使用typename</p><pre><code class="hljs nim"><span class="hljs-keyword">template</span> &lt;typename T, std::size_t n&gt; class <span class="hljs-type">Stack</span><span class="hljs-meta">&#123;...&#125;</span><span class="hljs-keyword">template</span> &lt;class T, std::size_t n&gt; class <span class="hljs-type">Stack</span><span class="hljs-meta">&#123;...&#125;</span></code></pre></li><li><p>在类模板内部，T可以像其他函数类别一样(比如int , char等)定义成员变量和成员函数</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>&amp; element)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(T&amp; element)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Top</span><span class="hljs-params">(T&amp; element)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; m_Members;</code></pre></li><li>除了Copy constructor 之外，如果在类模板中需要使用到这个类本身，比如定义operator，那么就应该医用其完整的定义(Stack<T,n>)而不是省略类别T。<pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> n&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&#123;</span>  <span class="hljs-keyword">public</span>:      ...      Stack (Stack&lt;T,n&gt; <span class="hljs-keyword">const</span>&amp;); <span class="hljs-comment">//copy constructor</span>      Stack&lt;T&gt;&amp; <span class="hljs-keyword">operator</span> = (Stack&lt;T,n&gt; <span class="hljs-keyword">const</span>&amp;); <span class="hljs-comment">// assignment operator</span>      ...&#125;</code></pre></li></ul><h2 id="类模板的实现"><a href="#类模板的实现" class="headerlink" title="- 类模板的实现"></a>- 类模板的实现</h2><ul><li><p>要定义一个类模板的成员函数，则要指明其是一个模板函数</p><p>Push函数：</p><pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> nMaxSize&gt;<span class="hljs-keyword">void</span> Stack&lt;T, nMaxSize&gt; :: Push(<span class="hljs-keyword">const</span> T <span class="hljs-keyword">const</span>&amp; element) &#123;    <span class="hljs-keyword">if</span> (m_Members.<span class="hljs-built_in">size</span>() &gt;= m_nMaxSize) &#123;        <span class="hljs-comment">// error handing...</span>        <span class="hljs-keyword">return</span> ;    &#125;    m_Members.push_back(element);&#125;</code></pre><p>Pop函数：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> nMaxSize&gt;<span class="hljs-keyword">int</span> Stack&lt;T, nMaxSize&gt; :: Pop(T&amp; element) &#123;    <span class="hljs-keyword">if</span> (m_Members.empty()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    element = m_Members.back(); <span class="hljs-comment">// we have to first store the back element</span>    m_Members.pop_back(); <span class="hljs-comment">// because pop_back of a vector removes</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// the last element but doesn&#x27;t return it</span>&#125;</code></pre><p>Top函数：</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> nMaxSize&gt;<span class="hljs-keyword">int</span> Stack&lt;T, nMaxSize&gt; :: Top(T&amp; element) <span class="hljs-keyword">const</span> &#123;    <span class="hljs-keyword">if</span> (m_Members.empty()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    element = m_Members.back();    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></li></ul><h2 id="使用类模板"><a href="#使用类模板" class="headerlink" title="- 使用类模板"></a>- 使用类模板</h2><ul><li>Stack<int> stack：定义了一类型为int的Stack， 大小为默认值</li><li>Stack<int, 100> stack：定义了一个类型为int, 大小为100的Stack</li><li>将100个元素Push到Stack中<pre><code class="hljs reasonml"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>;<span class="hljs-operator"> ++ </span>i) &#123;    stack.<span class="hljs-constructor">Push(<span class="hljs-params">i</span>)</span>;&#125;</code></pre></li><li>Pop出Stack顶部元素:<pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> elementstack.<span class="hljs-constructor">Pop(<span class="hljs-params">element</span>)</span>;</code></pre></li><li>获取Stack顶部元素:<pre><code class="hljs reasonml">stack.<span class="hljs-constructor">Top(<span class="hljs-params">element</span>)</span>;</code></pre></li><li>Stack的stack定义:<pre><code class="hljs angelscript">Stack&lt;Stack&lt;<span class="hljs-built_in">int</span>&gt; &gt;<span class="hljs-built_in">int</span>StackStack; <span class="hljs-comment">// 最右边要加一个空格</span>Stack&lt;Stack&lt;<span class="hljs-built_in">int</span>&gt;&gt; <span class="hljs-built_in">int</span>StackStack; <span class="hljs-comment">// ERROR: &gt;&gt; is not allowed </span></code></pre></li></ul><h2 id="类模板特化-specializations"><a href="#类模板特化-specializations" class="headerlink" title="- 类模板特化(specializations)"></a>- 类模板特化(specializations)</h2><ul><li>允许对一个类模板的某些模板参数类型做特化</li><li>特化的作用或好处在于：<ul><li>对于某种特殊的类别，可能可以做些特别的优化或提供不同的实现</li><li>避免在实例化类的时候引起一些可能产生的诡异行为</li></ul></li><li>特化一个类模板的时候也意味着需要特化其所有参数的成员的类型</li><li>如果要特化一个类，那么做法为：<ul><li>声明一个带template&lt;&gt;的类， 即空参数列表</li><li>在类名后紧跟的尖括号中显式指明类别，例如： <pre><code class="hljs angelscript">template&lt;&gt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Stack</span>&lt;<span class="hljs-symbol">std::<span class="hljs-symbol">wstring</span></span>&gt; &#123;&#125;</code></pre></li></ul></li><li>特化后的具体体现可以和柱模板的实现不一样，比如以下的特化增加了一个成员函数，并采用list作元素存取的实现<pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> &lt;</span><span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>&gt; &#123;  <span class="hljs-keyword">public</span>:      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetStackStack</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> n)</span> </span>&#123;m_nMaxSize = n;&#125;      <span class="hljs-comment">// 添加一个新的成员函数</span>      <span class="hljs-built_in">std</span> :: <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">CurrentSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> m_Members.<span class="hljs-built_in">size</span>();&#125;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> <span class="hljs-keyword">const</span>&amp; element)</span></span>;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> <span class="hljs-keyword">const</span>&amp; element)</span></span>;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Top</span><span class="hljs-params">(<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span> <span class="hljs-keyword">const</span>&amp; element)</span> <span class="hljs-keyword">const</span></span>;  <span class="hljs-keyword">private</span>:      <span class="hljs-built_in">std</span> :: <span class="hljs-keyword">size_t</span> m_nMaxSize;      <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">list</span> &lt;<span class="hljs-built_in">std</span> :: <span class="hljs-built_in">wstring</span>&gt; m_Members;      <span class="hljs-comment">//采用list作为Stack的内部实现，取代了主模板中用vector实现的方式</span>&#125;;</code></pre></li></ul><h2 id="偏特化-Partial-specialization"><a href="#偏特化-Partial-specialization" class="headerlink" title="- 偏特化(Partial specialization)"></a>- 偏特化(Partial specialization)</h2><p>….不做了解，中间会产生二义性…晚点再说。</p><h2 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="- 默认模板实参"></a>- 默认模板实参</h2><ul><li>类似函数的默认参数，对于类模板而言也可以定义其模板参数的默认值，这些值就叫做<strong>默认模板参数</strong><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> TContainer = <span class="hljs-built_in">std</span> :: <span class="hljs-built_in">vector</span>&lt;T&gt;&gt;class Stack &#123;    <span class="hljs-keyword">private</span> : TContainer m_Container;&#125;</code></pre></li><li>Stack<int> intStack: 使用默认的vector作为实参</li><li>Stack<std :: wstring, std :: list <std :: wstring> &gt; wstrStack: 指定使用list作为容器而非默认的vector</li></ul><h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><ul><li>关键字operator定义了一种特殊的函数，该函数的行为是将操作符应用用于某一特定的类型，使之能能够通过该操作符进行操作。如果定义了string类型的operator + ，那么连接两个字符串a和b的行为就可以用a+b进行操作</li><li>操作符重载给出了操作符的不同含义</li><li>编译器通过具体类别来识别某个操作符在该类型上的意义</li><li>本质上operator重载就是函数，即如果定义了string类型的Append函数，那么string类型的a+b和a.Append(b)是等价的</li></ul><h2 id="操作符重载的一般规则"><a href="#操作符重载的一般规则" class="headerlink" title="- 操作符重载的一般规则"></a>- 操作符重载的一般规则</h2><ul><li>不可以用operator定义一种新的操作符，比如<em>* ,因为没有两个</em>的操作符</li><li>对于内置类别(built-in type)， 不能再用operator重载</li><li>操作符重载的两种情况：<ul><li>静态成员函数</li><li>静态全局函数(如果该全集函数需要访问类的private或protected成员，则必须声明为friend成员)<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexType</span> &#123;</span>    <span class="hljs-keyword">public</span>:       <span class="hljs-comment">//non-static member</span>      ComplexType <span class="hljs-keyword">operator</span> &lt; (ComplexType&amp; );      <span class="hljs-comment">//global functions</span>      <span class="hljs-keyword">friend</span> ComplexType <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">int</span>, ComplexType&amp; );&#125;</code></pre></li><li>一元操作符(Unary operators)如果声明为成员函数，则没有参数。如果声明为全局函数则有一个参数</li><li>二元操作符(Binary operator)如果声明为成员函数，则有一个参数。如果声明为全局函数，则有两个参数</li><li>如果一个操作符技能够用作一元操作，又能用作二元操作(&amp;, *, +, -)，则可以分别被重载</li><li>操作符不能带有默认参数</li><li>除了operator = ，所又其他操作符重载均可以被子类继承</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板观念与函数模板</title>
    <link href="/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-模板简介"><a href="#C-模板简介" class="headerlink" title="C++模板简介"></a>C++模板简介</h1><ul><li>模板(Templates)是C++的一种特性，允许函数或类通过泛型(generic types)的形式表现或运行</li><li>模板可以使得函数或类在因对不同类别(types)的时候可以正常工作，而无需为每个类型都写一份代码</li></ul><ul><li>一个简单的例子：<ul><li>如果要写一个取两个数中较大的函数Max，在不适用模板的情况下，我们不得不针对不同的类别(eg: int long char…)提供一种类别的重载</li></ul></li></ul><p>int 型<br><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> <span class="hljs-constructor">Max(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></p><p>long型<br><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;&#125;</code></pre></p><p>char型<br><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span> <span class="hljs-constructor">Max(<span class="hljs-params">char</span> <span class="hljs-params">a</span>, <span class="hljs-params">char</span> <span class="hljs-params">b</span>)</span> &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></p><ul><li><p>一个简单的例子</p><ul><li><p>如果使用模板，则可以省去一堆代码，从而将代码原型缩减到非常简介的表达：</p><pre><code class="hljs excel">template &lt;typename <span class="hljs-built_in">T</span>&gt; <span class="hljs-built_in">T</span> <span class="hljs-built_in">Max</span>(<span class="hljs-built_in">T</span> a, <span class="hljs-built_in">T</span> b) &#123;    return (a &gt; b) ? a <span class="hljs-symbol">:</span> b;&#125;</code></pre></li></ul></li><li><p>C++ 主要有两种类型的模板：</p><ul><li>类模板(Class template):使用泛型参数的类(classes with generic parameters)</li><li>函数模板(Function template):使用泛型参数的函数(Functions with generic parameters)</li></ul></li><li><p>模板实例化</p><ul><li>模板的声明(declaration)其实并未给出一个函数或类的完全定义(definition)，只是提供了一个函数或类的语法框架(syntactical skeleton)</li><li><p>实例化时指从模板够检出一个真正的函数或类的过程，比如：</p>   <pre><code class="hljs nim">        <span class="hljs-keyword">template</span> &lt;typename T&gt;        struct <span class="hljs-type">Object</span><span class="hljs-meta">&#123;....&#125;</span>        ```              - 可以用来构建诸如<span class="hljs-type">Object</span>&lt;<span class="hljs-built_in">int</span>&gt;, <span class="hljs-type">Object</span>&lt;<span class="hljs-built_in">char</span>&gt;, <span class="hljs-type">Object</span>&lt;<span class="hljs-built_in">int</span>*&gt;, <span class="hljs-type">Object</span>&lt;<span class="hljs-type">MyClass</span>*&gt;等等不同类别的具体实例- 实例化有两种类型：  - **显式**实例化-在代码中明确指定要正对哪位类别进行实例化  - **隐式**实例化-在首次使用时根据具体情况一种合适的型别惊醒实例化  <span class="hljs-comment">## C++函数模板</span>- 什么时函数模板？  - **函数模板**是参数化的一族函数(a family <span class="hljs-keyword">of</span> functions)  - 通过函数模板，可以定义一系列函数，这些函数都是基于同一代码，但是可以用作在不同类别的参数上</code></pre><p>template <typename T><br>inline T Max(const T&amp; a, const T&amp; b) {<br>return (a &gt; b) ? a : b;<br>}</p><pre><code class="hljs haml">-<span class="ruby"> 定义函数模板</span><span class="ruby">  - 定义一个函数模板，反水数中较大一个，该函数有两个参数：(a,b)</span><span class="ruby">  - 参数类别未定，以模板参数T表示</span><span class="ruby">  - 模板参数由关键字typename引入</span><span class="ruby">  - 也可以使用<span class="hljs-class"><span class="hljs-keyword">class</span>代替<span class="hljs-title">typename</span>来定义类型参数</span></span><span class="ruby">  - 从语法上讲使用<span class="hljs-class"><span class="hljs-keyword">class</span>和使用<span class="hljs-title">typename</span>没有区别</span></span><span class="ruby">  - 单从语义上，<span class="hljs-class"><span class="hljs-keyword">class</span>可能会导致误区，即只有类才能作为类别参数；而事实上<span class="hljs-title">T</span>所以表达的意思不仅仅只针对类，任何类别都可以</span></span><span class="ruby">  </span><span class="ruby">- 参数推导</span><span class="ruby">  - 模板参数是有传递给模板函数的实参所决定的</span><span class="ruby">  - 不允许自动类型转换：每个T必须严格匹配</span></code></pre><p>Max(1, 2) //两次实参的类型都是int<br>Max(1, 2.0) //ERROR：第一参数的类别是int第二参数类别是double</p><pre><code class="hljs cpp">- 一般有两种处理这种错误的方法：   <span class="hljs-number">1.</span> 用<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;或者强制转换参数类型以使两者匹配</code></pre><p>Max(static_cast<double>(1),2.0)</p><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 显示指定T的类别</code></pre><p>Max<double>(1, 2.0)</p><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 函数模板重载<span class="hljs-bullet">  -</span> 函数模板也可以像普通函数一样被重载<span class="hljs-bullet">  -</span> 非模板函数可以和<span class="hljs-strong">**同名**</span>的模板函数共存<span class="hljs-bullet">  -</span> 编译器同通过函数模板参数推导来决定使用调用哪个函数</code></pre><p>inline int const&amp; Max(const int const&amp; a, const int const&amp; b)</p></li></ul><p>template <typename T><br>inline T const&amp; Max(const T const&amp; a, T const&amp; b)</p><p>template <typename T><br>inline T const&amp; Max(const T const&amp; a, T const&amp; b, const T const&amp; c)<br>```</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>堆的种类有很多这里我们讨论的时最大堆和最小堆</p><a id="more"></a><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>严格来说，堆也有不同种类。这是一种叫做二叉堆的数据结构，堆就是下图这样的二叉树。<br><img src="/img/堆的例子.png" alt=""></p><p>最小堆的性质是儿子的值一定不小于父亲的值。而最大堆的性质则于其相反儿子的值一定更不大于父亲的值。<br>除此之外，树的节点时按从上到下、从左到右的顺序紧凑排列的。</p><p><img src="/img/插入数值.png" alt=""><br>如上图所示，在向堆中插入数值时，首先在堆的末尾插入该数值，然后不断向上提升直到没有大小颠倒为止。</p><p><img src="/img/取出最小值.png" alt=""><br>如上图所示，从队中删除最小值时，首先把堆的最后一个节点的数值复制到根节点上，并且删除最后一个结点。然后不断向下<br>交换直到没有大小颠倒为止。在向下交换的过程中，如果有两个儿子，那么选择数值较小的儿子（如果儿子比自己小的话）进行交换。</p><h2 id="堆的操作的复杂度"><a href="#堆的操作的复杂度" class="headerlink" title="堆的操作的复杂度"></a>堆的操作的复杂度</h2><p>堆的两种操作所花的时间都和数的深度成正比。因此，如果一共有$n$个元素，那么每个操作就可以在$O(log_n)$的时间内完成。</p><h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><p>注意:</p><ul><li>左儿子的编号是自己的编号 $×2+1$</li><li>右儿子的编号是自己的编号 $×2+2$</li></ul><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10000</span>;<span class="hljs-keyword">int</span> heap[N], sz;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-comment">//自己节点的编号</span>    <span class="hljs-keyword">int</span> i = sz ++;        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 父亲结点的编号</span>        <span class="hljs-keyword">int</span> p = (i = <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">2</span>;        <span class="hljs-comment">//如果已经没有大小颠倒则退出</span>        <span class="hljs-keyword">if</span> (heap[p] &lt;= x) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//父亲节点的数值放下来，而把自己提上去</span>        heap[i] = heap[p];        i = p;    &#125;    heap[i] = x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//最小值</span>    <span class="hljs-keyword">int</span> ret = heap[<span class="hljs-number">0</span>];    <span class="hljs-comment">//要提到根的数值</span>    <span class="hljs-keyword">int</span> x = heap[--sz];    <span class="hljs-comment">//从根开始向下交换</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((i &lt;&lt; <span class="hljs-number">2</span>) + <span class="hljs-number">1</span> &lt; sz) &#123;        <span class="hljs-comment">//比较儿子的值</span>        <span class="hljs-keyword">int</span> a = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, b = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;        <span class="hljs-comment">//如果已经没有大小颠倒则退出</span>        <span class="hljs-keyword">if</span> (heap[a] &gt;= x) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//把儿子的数值提上来</span>        heap[i] = heap[a];        i = a;    &#125;    heap[i] = x;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 mcm/icm LaTeX写作</title>
    <link href="/2020/02/15/mcm-icm/"/>
    <url>/2020/02/15/mcm-icm/</url>
    
    <content type="html"><![CDATA[<p>mcm/icm 2020新版美赛$\LaTeX$模板 </p><a id="more"></a><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>&emsp;&emsp;2020年因为武汉疫情的原因，原定于2月14日的mcm/icm比赛采用了两个时间两次给的方式，今天上午我也看了一下题，D题的数据相对比较好搜集，作为一名游戏玩家，我觉得可以从EA的FIFA球员数据库种收取数据。虽然说我的建模能力很垃圾啊。但是搜集数据和LaTeX的写作是我能给我们这个团队做出贡献的方式。所以我就做一些利索能及的事就对了。</p><h2 id="说说LaTeX"><a href="#说说LaTeX" class="headerlink" title="说说LaTeX"></a>说说LaTeX</h2><p>&emsp;&emsp;LaTeX是我开始学习写markdown的时候就了解的一种排版方式，寒假这段时间我也好好学习了一下。<br>一开始觉得美赛要不要用word写但是想到要插入公式，解决排版问题使用LaTeX还是方便的多。因为在比赛之前我也尝试自己<br>按照之前获奖文章自己做一个美赛模板。</p><p><img src="/img/mcm_model_1.png" alt=""></p><p>但是在比赛之前听过2020年的比赛写作排版有变动，一开始还有点慌。然后今天上官网看了一下。发现官方给了一个模板<br><img src="/img/mcm_code.png" alt=""><br>我一开始还以为是一个.tex文件谁知道，是这个…</p><p>我运行了一下就是这个效果（我注明一下，我把红色字体改成了黑色）</p><p><img src="/img/mcm_model.png" alt=""></p><p>效果还不错，嘿嘿。感觉这个还专门给了一个模板，可能是为了要人们知道今年的变化吧。但是我觉得应该是因为大多数中国学生，撰写论文的格式都不标准，所以今年专门给了一个word和LaTeX模板来共大家用。统一一下格式，让看论文的老师也能好看一点。</p><p>自习看了一下模板里面内容，注释也很清楚。生怕学生不会用。一开始我还在想怎么加一个content，谁知人家这个模板很贴心，已经将目录给你写好了。（只不过是注释掉了）</p><p><img src="/img/content.png" alt=""></p><p>2020和2019版的模板我也分享给大家，有需自戳。</p><ul style:"color=#336699"><li><a href="/temp/mcm-icm2020模板.zip" download="2020mcm-icm模板">2020</a></li><li><a href="/temp/mcm-icm2019模板.zip" download="2019mcm-icm模板">2019</a></li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(完全背包)</title>
    <link href="/2020/02/14/%E8%83%8C%E5%8C%85_1/"/>
    <url>/2020/02/14/%E8%83%8C%E5%8C%85_1/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题:完全背包问题</p><a id="more"></a><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href = "http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(01背包)</title>
    <link href="/2020/02/10/%E8%83%8C%E5%8C%85/"/>
    <url>/2020/02/10/%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题：01背包问题</p><a id="more"></a><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0 &lt; N$, $V \leq 1000$</p><p>$0 &lt; v_i$, $w_i \leq 1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例</strong></p><pre><code>8</code></pre><p>S</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>&emsp;&emsp;这是最基础的背包问题，特点是：<font color = #f278>每种物品仅有一件，可以选择放或不放。</font></p><h5 id="用子问题定义状态："><a href="#用子问题定义状态：" class="headerlink" title="用子问题定义状态："></a>用子问题定义状态：</h5><p>即$f[i][v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p><script type="math/tex; mode=display">f[i][v] = max \begin{cases}    f[i-1][j] \\    f[i-1][j-c[i]] + w[i]\end{cases}</script><p>&emsp;&emsp;这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f=[i-1][v-c[i]]$再加上通过放入第$i$件物品获得的价值$w[i]$。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href="http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL队列</title>
    <link href="/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>STL队列简述</p><a id="more"></a><h1 id="STL中队列-queue-的使用方法"><a href="#STL中队列-queue-的使用方法" class="headerlink" title="STL中队列(queue)的使用方法"></a><font color="#f278">STL中队列(queue)的使用方法</font></h1><h3 id="STL中队列的使用方法-queue"><a href="#STL中队列的使用方法-queue" class="headerlink" title="STL中队列的使用方法(queue)"></a><font style="text-align: 'center'">STL中队列的使用方法(queue)</font></h3><p>基本操作：</p><ul><li>push(x) 将x压入队列的末端</li><li>pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值</li><li>front() 返回第一个元素(队顶元素)</li><li>back() 返回最后被压入的元素(队尾元素)</li><li>empty() 当队列为空时，返回true</li><li>size() 返回队列的长度</li></ul><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p> 声明方法：<br>1、普通声明</p><pre><code>queue&lt;int&gt;q;</code></pre><p>2、结构体</p><pre><code>struct node&#123;    int x, y;&#125;;queue&lt;node&gt;q;</code></pre><h3 id="STL-中优先队列的使用方法-priority-queue"><a href="#STL-中优先队列的使用方法-priority-queue" class="headerlink" title="STL 中优先队列的使用方法(priority_queue)"></a>STL 中<font color="#f278">优先队列</font>的使用方法(priority_queue)</h3><p>&emsp;&emsp;优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大互小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p><p>基本操作：</p><ul><li><p>empty() 如果队列为空返回真</p></li><li><p>pop() 删除对顶元素</p></li><li><p>push() 加入一个元素</p></li><li><p>size() 返回优先队列中拥有的元素个数</p></li><li><p>top() 返回优先队列对顶元素</p></li></ul><p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p>声明方式：</p><p>1、普通方法：<br>    priority_queue<int>q;   //通过操作，按照元素从大到小的顺序出队<br>    priority_queue<int,vector<int>, greater<int> &gt;q;  //通过操作，按照元素从小到大的顺序出队</p><p>2、自定义优先级：</p><pre><code>struct cmp &#123;     　　operator bool ()(int x, int y)     　　&#123;        　　　　 return　x &gt; y; // x小的优先级高               //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高　　&#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;    //定义方法//其中，第二个参数为容器类型。第三个参数为比较函数。</code></pre><p>3、结构体声明方式：</p><pre><code>struct node &#123;     　　int x, y;     　　friend bool operator &lt; (node a, node b)     　　&#123;         　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高     　　&#125;&#125;;priority_queue&lt;node&gt;q;   //定义方法//在该结构中，y为值, x为优先级。//通过自定义operator&lt;操作符来比较元素中的优先级。//在重载“&lt;”时，最好不要重载“&gt;”，可能会发生编译错误</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拯救公主</title>
    <link href="/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/"/>
    <url>/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<p>BFS训练题</p><a id="more"></a><h2 id="拯救公主"><a href="#拯救公主" class="headerlink" title="拯救公主"></a>拯救公主</h2><p>公主被恶人抓走，被关押在牢房的某个地方。牢房用 $ N \times M (N, M \le 200)N×M(N,M\le200) $ 的矩阵来表示。矩阵中的每项可以代表道路（@）、墙壁（#）、和守卫（x）。</p><p>英勇的骑士（r）决定孤身一人去拯救公主（a）。我们假设拯救成功的表示是 “骑士到达了公主所在的位置”。由于在通往公主所在位置的道路中可能遇到守卫，骑士一旦遇到守卫，必须杀死守卫才能继续前进。</p><p>现假设骑士可以向上、下、左、右四个方向移动，每移动一个位置需要 11 个单位时间，杀死一个守卫需要花费额外的 11 个单位时间。同时假设骑士足够强壮，有能力杀死所有的守卫。</p><p>给定牢房矩阵，公主、骑士和守卫在矩阵中的位置，请你计算拯救行动成功需要花费最短时间。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>1、两个整数代表 $N$ 和 $M, (N, M \le 200)M,(N,M\le200)$.<br>2、随后 $N$ 行，每行有 $M$ 个字符。”@” 代表道路，”a” 代表公主，”r” 代表骑士，”x” 代表守卫, “#” 代表墙壁。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果拯救行动成功，输出一个整数，表示行动的最短时间。<br>如果不可能成功，输出 “Impossible”。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h3><pre><code>7 8#@#####@#@a#@@r@#@@#x@@@@@#@@#@##@@@##@@@#@@@@@@@@@@@@@@</code></pre><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h3><pre><code>13</code></pre><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h3><pre><code>13 40@x@@##x@#x@x#xxxx##@#x@x@@#x#@#x#@@x@#@xxx###x@x#@@##xx@@@#@x@@#x@xxx@@#x@#x@@x@#@x#@x#x#@@##@@x#@xx#xxx@@x##@@@#@x@@x@x@##x@@@x#xx#@@#xxxx#@@x@x@#@x@@@x@#@#x@#@#xxxxx##@@x##x@xxx@@#x@x####@@@x#x##@#@#xxx#@#x##xxxx@@#xx@@@x@xxx#@#xxx@x######x@xxxx#@x@@@@##@x#xx#xxx@#xx#@#####x#@xxx##@#@x##x##x#@x#@a#xx@##@#@##xx@#@@x@xx#x#@x@#x#@##@xrx@x#xxxx@##x##xx#@#x@xx@#x@@#@###x##x@x#@@#@@x@x@@xx@@@@##@@x@@xx#xx@x###@xxx#@#x#@@###@#@##@x#@x@#@@#@@#@#x@x#x#x###@x@@xxx####x@x##@x####xx#@x#x#@x#x######@@#x@#xxxx#xx@@@#xx#x#####@</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>7</code></pre><h3 id="ans"><a href="#ans" class="headerlink" title="ans"></a>ans</h3><pre><code>//ac#include &lt;bits/stdc++.h&gt;using namespace std;char maze[205][205];bool vis[205][205];int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;&#125;;int n, m;struct node &#123;    int x;    int y;    int d;    node(int xx, int yy, int dd) : x(xx), y(yy), d(dd) &#123;&#125;    friend bool operator &lt; (node a, node b) &#123;        return a.d &gt; b.d;    &#125;&#125;;int bfs(int x, int y) &#123;    priority_queue&lt;node&gt; q;    vis[x][y] = true;    q.push(node(x, y, 0));    while(!q.empty()) &#123;        node now = q.top();        q.pop();        for (int i = 0; i &lt; 4; ++i) &#123;            int tx = now.x + dir[i][0];            int ty = now.y + dir[i][1];            if (0 &gt; tx || tx &gt;= n || 0 &gt; ty || ty &gt;= m || maze[tx][ty] == &#39;#&#39; || vis[tx][ty])            continue;            if (maze[tx][ty] == &#39;a&#39;) &#123;                return now.d + 1;            &#125;            else if (maze[tx][ty] == &#39;x&#39;) &#123;                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 2));            &#125;            else&#123;                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 1));            &#125;        &#125;    &#125;    return -1;&#125;int main()&#123;    freopen(&quot;note.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;ans.txt&quot;, &quot;w&quot;, stdout);    int i, j;    int ans = -1;    cin &gt;&gt; n &gt;&gt; m;    for (i = 0; i &lt; n; ++i) &#123;        cin &gt;&gt; maze[i];    &#125;    for (i = 0; i &lt; n; ++i) &#123;        for (j = 0; j &lt; m; ++j) &#123;            if (maze[i][j] == &#39;r&#39;)&#123;                break;            &#125;        &#125;        if (maze[i][j] == &#39;r&#39;) break;    &#125;    ans = bfs(i, j);    if (ans == -1) &#123;        cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl;    &#125;    else&#123;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>&emsp;&emsp;这个题目的棋盘范围超过了100也就是说使用dfs算法是非常危险的方法，因为dfs的时间复杂度为 $O(2^n)$ 而bfs的时间复杂度为$O(M*N)$所以使用dfs是会为超时的。</p><p>&emsp;&emsp;所以弃用dfs是必须的，一般再求最少问题时一般都是采用dfs算法使用。但是我们注意这个棋盘的范围超过了100。对于bfs来说<br>空间复杂度问题就显现的比较明显。如果采用一般的队列方式来存储帮助bfs的实现，时肯定不行的。此时就要记住。一般这种情况下求极值问题要求优化，我们就采用用<strong>优先队列</strong>的方法。来进行优化。其实质上对空间复杂度的优化就是对时间复杂度的优化。要不断使用最优秀的数据结构来解决时间于内存上的算法优化问题。</p><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踏青</title>
    <link href="/2020/01/26/%E8%B8%8F%E9%9D%92/"/>
    <url>/2020/01/26/%E8%B8%8F%E9%9D%92/</url>
    
    <content type="html"><![CDATA[<p>DFS训练题</p><a id="more"></a><hr><p>垃圾桶和他的朋友周末相约去召唤师峡谷踏青。他们发现召唤师峡谷的地图是由一块块格子组成的，有的格子上是草丛，有的是空地。草丛通过上下左右四个方向扩展到其他草丛形成一片草地，任何一片草地中的格子都是草丛，并且所有格子之间都能通过上下左右连通。如果用’#’代表草丛，’.’表示空地，下图的峡谷有<strong>2</strong>片草地</p><pre><code>##....##</code></pre><p>处在同一个草地的<strong>2</strong>个人可以相互看到，空地看不到草地里面的人。他们发现有一个朋友不见了，现在需要分头去找，每个人负责一片草地，垃圾桶想知道他们至少需要多少人。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入 $n,m$ $(1 \le n, m \le 100)$ 表示峡谷大小。</p><p>接下来输入 $m$ 行字符串表示峡谷的地形。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输出至少需要多少个人。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5 6.#......#.....#..#...##..#....</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>5</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>DFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(7)</title>
    <link href="/2020/01/21/python_ex40/"/>
    <url>/2020/01/21/python_ex40/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是组织好的、可重复使用得、用来实现单一或相关联功能的代码。在程序中，函数的使用能提高应用的模块性、代码的重用旅和可读性。</p><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(6)</title>
    <link href="/2020/01/20/python_ex39/"/>
    <url>/2020/01/20/python_ex39/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h3 id="3-修改列表元素"><a href="#3-修改列表元素" class="headerlink" title="3.修改列表元素"></a>3.修改列表元素</h3><p>列表创建之后，可以对列表中单个元素或指定范围元素(切片)进行修改，方法是：</p><ol><li>list[index] = newValue: 对指定索引index的列表元素进行修改</li><li><p>list[::] = newList: 对指定方位的列表元素进行修改</p><pre><code> list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;] list[0] = &quot;eee&quot; print(&quot;list:&quot;,list) list[1:3] = [&quot;ggg&quot;,&quot;kkk&quot;] print(&quot;list:&quot;,list)</code></pre></li></ol><p>4.删除列表元素<br>列表创建后，可以根据需要使用列表函数，del语句或切片和删除指定袁术或所有元素。</p><ol><li>del list[index]: 删除索引为index元素</li><li>list.pop(): 删除列表末尾的元素。</li><li>list.pop(index): 删除索引的元素。</li><li>list.remove(item): 删除列表元素item。</li><li>list.clear(): 删除列表中所有元素。</li><li>list[::] = []: 对指定范围的列表元素进行</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    #del list[3]    #list.pop()    #list.pop(0)    #list.remove(&quot;aaa&quot;)    #list.clear()    #list[2:3] = []    print(&quot;list:&quot;,list)</code></pre><p>list.remove(item)<br><img src="/img/list.remove.png" alt=" "></p><p>list.clear()<br><img src="/img/list.clear.png" alt=" "></p><p>list[::] = []<br><img src="/img/list[].png" alt=" "></p><h2 id="列表复制和删除"><a href="#列表复制和删除" class="headerlink" title="列表复制和删除"></a>列表复制和删除</h2><h3 id="1-列表复制"><a href="#1-列表复制" class="headerlink" title="1.列表复制"></a>1.列表复制</h3><p>列表复制有两种方法。</p><ol><li>list_copy = list.copy(): 列表浅复制。当列表list改变时，list_copy中的元素不会随之变化。</li><li>list_copy = list: 列表复制。当列表list改变时，list_copy中的元素也会随之改变。</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    list_copy = list.copy()    print(&quot;list:&quot;,list)    print(&quot;list_copy:&quot;,list_copy)</code></pre><p><img src="/img/list.copy.png" alt=" "></p><h3 id="2-列表删除"><a href="#2-列表删除" class="headerlink" title="2.列表删除"></a>2.列表删除</h3><p>当列表不再使用后，可以使用del语句删除列表，其一般格式：</p><pre><code>del 列表名</code></pre><p>del 可以索引删除也可以全部删除</p><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    del list    print(&quot;list:&quot;,list)</code></pre><p><img src="/img/del.png" alt=" "></p><h2 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h2><ol><li>+: 将多个列表组合成一个新的列表，新列表中的元素是多个元素的有序组合。</li><li>*: 将整数n和列表相乘可以得到一个将原列表重复n次的新列表。</li><li>in: 用于判断给定对象是否再列表中，如果再则返回True：否则返回False</li><li>not in: 用于判断给定对象是否不在列表中，如果不在则返回True；否则返回False</li><li>关系运算符：两个列表可以使用&lt;,&gt;等关系运算进行比较操作，其规则是从两个列表的第1个元素开始比较，如果比较有结果就结束；否则继续继续比较两个列表后面对应位置的元素。</li></ol><h2 id="列表统计"><a href="#列表统计" class="headerlink" title="列表统计"></a>列表统计</h2><p>列表统计函数：</p><ol><li>len(list): 返回列表list中的元素个数</li><li>max(list): 返回列表list中元素的最大值</li><li>min(list): 返回列表list中元素的最小值</li><li>sum(list): 返回列表list中所有元素的和</li><li>list.count(key): 返回关键字key在列表中出现的次数</li></ol><h2 id="列表元素查找和排序"><a href="#列表元素查找和排序" class="headerlink" title="列表元素查找和排序"></a>列表元素查找和排序</h2><h3 id="1-列表元素查找"><a href="#1-列表元素查找" class="headerlink" title="1.列表元素查找"></a>1.列表元素查找</h3><p>list.index()函数用于查找并返回关键字在列表中第1次出现的位置，其一般格式为：</p><pre><code>list.index(key)</code></pre><p>其中，key为要在列表中查找的元素。</p><h3 id="2-列表元素的排序"><a href="#2-列表元素的排序" class="headerlink" title="2.列表元素的排序"></a>2.列表元素的排序</h3><p>列表创建后，可以使用一下函数更具关键字对列表中的元素进行排序、倒序或临时排序。</p><ol><li>list.sort(): 对列表中的元素按照一定的规则进行排序</li><li>list.reverse(): 对列表list中的元素按照一定的规则反向排序</li><li>sorted(list): 对列表list中的元素进行临时排序，返回副本。但是原列表中的元素次序不变</li></ol><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(5)</title>
    <link href="/2020/01/19/python_ex38/"/>
    <url>/2020/01/19/python_ex38/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表(list)是写在方括号[]之间、用于逗号隔开的元素集合。<br>列表中的元素可以是零个或多个。只有零个元素的列表称为空列表[]。<br>列表中的元素可以相同。例如：</p><pre><code>[&quot;c/c++&quot;,&quot;Python&quot;,&quot;Java&quot;]</code></pre><p>该列表中的个元素均不同。</p><pre><code>[1,1,2,3,4]</code></pre><p>该列表中有重复元素。</p><p>列表中的元素可以类型相同，如[2,4,6,8];也可以是类型不同，如列表[“Rose”,”Female”,18];还可以是复杂的数据类型，如列表[(1,0),(0,1)]</p><p>同字符串类似，列表支持元素的双向索引，正向第1个元素的索引是0，第2个元素的索引是1，以此类推。反向最后1个元素的索引是-1，倒数第2个元素的索引是-2，以此类推。</p><h2 id="列表创建"><a href="#列表创建" class="headerlink" title="列表创建"></a>列表创建</h2><p>通常使用[]运算符或list()函数创建列表。</p><h3 id="1-使用-运算符"><a href="#1-使用-运算符" class="headerlink" title="1.使用[]运算符"></a>1.使用[]运算符</h3><p>使用[]运算符创建列表的一般格式为：</p><pre><code>列表名 = [元素1, 元素2, 元素3, ....]</code></pre><p>其中列表中的元素可以是相同类型或不同类型，简单数据或组合数据。</p><pre><code>list1 = []list2 = [1, 2, 3.2]list3 = [&quot;石油&quot;,&quot;汽车&quot;,&quot;建筑&quot;,&quot;IT&quot;]list4 = [&#39;Alice&#39;,18,&#39;Beth&#39;,19]</code></pre><h3 id="2-使用list-函数创建列表"><a href="#2-使用list-函数创建列表" class="headerlink" title="2.使用list()函数创建列表"></a>2.使用list()函数创建列表</h3><p>使用内置函数list()创建列表的一般格式为:</p><pre><code>列表名 = list(sequence)</code></pre><p>其中，sequence可以是字符串、元组、结合或range()函数返回结果等迭代对象</p><h2 id="列表访问"><a href="#列表访问" class="headerlink" title="列表访问"></a>列表访问</h2><h3 id="1-访问列表"><a href="#1-访问列表" class="headerlink" title="1.访问列表"></a>1.访问列表</h3><p>(1)访问列表及元素<br>可以使用列表名访问整个列表，也可以通过list[index]访问索引为index的元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]print(&quot;carlist[2]:&quot;,carlist[2])print(&quot;carlist[-1]:&quot;,carlist[-1])</code></pre><p>(2)列表切片<br>Python支持使用切片访问列表指定范围的元素,语法格式为:</p><pre><code>arr[index_start:index_end:step]</code></pre><p>注意结束是指在结束的数字前的一个数字结束。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;carlist[2:5]:&quot;,carlist[2:5])print(&quot;carlist[2:5:2]:&quot;,carlist[2:5:2])</code></pre><p>(3)遍历列表<br>可以使用for语句遍历列表，即逐个访问列表中的每个元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;print:&quot;,end = &#39; &#39;)for car in carlist:    print(car,end = &#39; &#39;)</code></pre><h3 id="2-添加列表元素"><a href="#2-添加列表元素" class="headerlink" title="2.添加列表元素"></a>2.添加列表元素</h3><p>列表创建后，可以使用列表函数或切片为列表添加新的元素。</p><ol><li>list.append(newItem): 在列表末尾添加新的元素newItem。</li><li>list.insert(index,newItem):在列表末尾添加新元素newItem。</li><li>list.extend(seq):在列表末尾添加迭代对象seq中的所有元素作为列表新元素。</li><li>list.[len(list):] = newList:使用切片在列表list末尾添加新元素(newList中的元素)</li></ol><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]#carlist.append(&quot;ggg&quot;)#carlist.insert(2,&quot;ggg&quot;)#carlist.extend([&quot;yyy&quot;,&quot;ggg&quot;])carlist[6:] = [&quot;iii&quot;,&quot;ggg&quot;] print(carlist)</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(4)</title>
    <link href="/2020/01/18/python_ex37/"/>
    <url>/2020/01/18/python_ex37/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h2><p>条件运算相当于一个二分支结构语句的功能，包含三个表达式，其一般格式为：</p><pre><code>表达式1 if 表达式 else 表达式2</code></pre><p>条件运算的执行过程是：如果if后面的表达式值为True，则以表达式1的值为条件运算的结构；<br>否则，以表达式2的值为条件运算的结果。<br>可以将整个条件运算作为一个表达式，出现在其他表达式中。</p><pre><code>score = int(input(&quot;Please enter:&quot;))flag = &quot;ok&quot; if score &gt;= 60 else &quot;no&quot;print(&quot;score: &quot;,flag)</code></pre><p><img src="/img/条件运算.png" alt=" "></p><p>但是我们要注意表达式1与if之间不能加换行。</p><h2 id="选择结构嵌套"><a href="#选择结构嵌套" class="headerlink" title="选择结构嵌套"></a>选择结构嵌套</h2><p>当在一个选择结构中需要进一步的条件选择时，可以在if语句中再嵌套使用if语句，形成选择结构嵌套以实现相应功能。</p><pre><code>a = 3; b = 2; c = 4if a &gt; b:    if a &gt; c:        print(&quot;最大的数是：&quot;, a)    else:        print(&quot;最大的数是：&quot;, c)else:    if b &gt; c:        print(&quot;最大的数是: &quot;, b)    else:        print(&quot;最大的数是: &quot;, c)</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构依据某一条件反复执行某段程序，即语句块。该语句块被执行的次数称为循环次数。</p><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句用于循环执行一段程序，即再满足某种条件的情况下循环执行某段程序，以处理需要重复处理的<br>相同任务。while语句的一般格式为：</p><pre><code>while 表达式：   语句块[else：   else 子句语句块]</code></pre><p>while语句执行过程：如果表达式的值为True，则执行while后面的语句块；否则，执行else子语句语句块，结束循环。其中else子句为可选。</p><p>while语句</p><pre><code>n = 100sum = 0i = 1while i &lt;= n:    sum = sum + i    i += 1print(&quot;1到%d之和为: %d.&quot; % (n,sum))</code></pre><p>while-else语句</p><pre><code>mu1 = 1; i = 1; sum = 0while i &lt;= 10:    mu1 = mu1 * i    sum = sum + mu1    i = i + 1else:    print(&quot;循环结束!&quot;)print(&quot;sum =&quot;, sum)</code></pre><h3 id="while语句块中的input-函数"><a href="#while语句块中的input-函数" class="headerlink" title="while语句块中的input()函数"></a>while语句块中的input()函数</h3><p>while语句常常和input()函数结合使用，给变量循环输入数据，进行相应的处理。</p><pre><code>total = 0; ave = 0; count = 0score = int(input(&quot;请输入学生英语成绩: &quot;))print(&quot;输入&#39;-1&#39;结束输入\n&quot;)while score != -1:    total = total + score    count = count + 1    score = int(input(&quot;请输入学生英语成绩: &quot;))ave = total / countprint(&quot;录入学生英语成绩%d份,学生英语总成绩%d，平均成绩%4.2f.&quot; % (count, total, ave))</code></pre><p><img src="/img/while-input.png" alt=" "><br>注意:%4.2f是值精度为2宽度为4。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句更合适循环访问系列或迭代对象(如字符串、列表、元组、字典等))中的元素，其一般格式：</p><pre><code>for 变量 in 序列或迭代对象：    语句块[else:    else 子句语句块]</code></pre><p>for语句执行过程是:当序列或迭代对象中的元素没有遍历完毕时，执行for语句中的语句块：<br>否则，执行else子句中的语句块，结束循环，其中，else子句时可选的。</p><pre><code>for letter in &#39;python&#39;:    print(letter, end=&#39; &#39;)print() #起到换行作用chemists = [&#39;道尔顿&#39;,&#39;门捷列夫&#39;,&#39;拉瓦锡&#39;,&#39;诺贝尔&#39;]print(&quot;化学家:&quot;,end=&#39; &#39;)for hxj in chemists:    print(hxj, end=&#39; &#39;)</code></pre><p><img src="/img/for.png" alt=" "></p><p>一般情况下else子句是可选选项，可以做为在循环遍历结束之后给出提示信息。</p><h3 id="for语句中的range-函数"><a href="#for语句中的range-函数" class="headerlink" title="for语句中的range()函数"></a>for语句中的range()函数</h3><p>range()函数经常用在for循环中，用于控制循环次数。</p><pre><code>universities = [&#39;哈弗大学&#39;,&#39;斯坦福大学&#39;,&#39;剑桥大学&#39;,&#39;麻省理工学院&#39;,&#39;加州大学&#39;,&#39;普林斯顿大学&#39;,&#39;牛津大学&#39;,&#39;哥伦比亚大学&#39;,&#39;加州理工学院&#39;,&#39;芝加哥大学&#39;]print(&quot;2017《Times》世界大学排名前三的大学是：&quot;)for i in range(3):    print(str(i+1) + &quot;.&quot;, universities[i])</code></pre><h3 id="break-continue和pass语句"><a href="#break-continue和pass语句" class="headerlink" title="break,continue和pass语句"></a>break,continue和pass语句</h3><p>break语句用于退出循环，continue语句用于跳过该次循环,pass时空语句(不做任何处理)</p><h2 id="循环结构的嵌套"><a href="#循环结构的嵌套" class="headerlink" title="循环结构的嵌套"></a>循环结构的嵌套</h2><p>在一个循环结构的循环体内出现另一个循环结构，称为循环结构的嵌套。</p><pre><code>for i in range(1,6):    for j in range(i):        print(&quot;*&quot;, end=&#39; &#39;)    print() #该print是属于  第一层循环</code></pre><p><img src="/img/for-for.png" alt=" "></p><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(3)</title>
    <link href="/2020/01/17/python_ex36/"/>
    <url>/2020/01/17/python_ex36/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><p>单分支结构可用if单分支语句实现，其一般格式为：</p><pre><code>if表达式:    语句块</code></pre><p>语句的执行过程是：如果表达式的值为True，则执行语句中的语句块；否则，直接执行if语句的后续语句。</p><p>注意：</p><ol><li>if语句中的语句块可以包含单个语句，也可以包含多个语句。</li><li>如果语句块中只有一跳语句，也可以将整个if语句写在同一行中</li></ol><pre><code>    n = int(input(&quot;请输入一个整数: &quot;))    flag = str(n) + &quot; 是偶数!&quot;    if n % 2 != 0:        flag = str(n) + &quot; 是偶数!&quot;    print(flag)</code></pre><p><img src="/img/if.png" alt=" "></p><ul><li><p>str() 函数将对象转化为适于人阅读的形式，就是把对象转换成字符串</p><pre><code>  class str(object=&#39;&#39;)</code></pre></li><li><p>object — 对象。</p></li></ul><h2 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h2><p>二分支结构可用if二分支语句实现，其一般格式为：</p><pre><code>if 表达式：    语句块1else：    语句块2</code></pre><p>语句执行过程是：如果表达式的值为True时，则执行语句块1；否则，执行语句块2</p><pre><code>a = 5b = 6print(&quot;a = %d, b = %d&quot; % (a,b))if a &gt; b:    max = aelse:     max = bprint(max)</code></pre><p><img src="/img/if-else.png" alt=" "></p><h2 id="多分枝结构"><a href="#多分枝结构" class="headerlink" title="多分枝结构"></a>多分枝结构</h2><p>二分支结构只能根据条件的True和False决定处理两个分支中的一个。当实际处理的问题有多种条件时，就要用到多分支结构。<br>多分支结构可用if多分支语句实现，其一般格式为：</p><pre><code>if 表达式1：    语句块1elif 表达式2：    语句块2    ...[else:    语句块n+1]</code></pre><p>if多分支语句根据不同的表达式值确定执行哪个语句块，测试条件的顺序为表达式1，表达式2，…。一旦<br>遇到表达式的值为True，则执行该条件下的语句块，然后执行if语句的后续语句。</p><pre><code>score = int(input(&quot;请输入成绩:&quot;))if score &gt;= 90:    print(&quot;成绩等级:优秀！&quot;)elif score &gt;= 80:    print(&quot;成绩等级：良好！&quot;)elif score &gt;= 60:    print(&quot;成绩等级：不合格！&quot;)</code></pre><p><img src="/img/elif.png" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(2)</title>
    <link href="/2020/01/16/python_ex35/"/>
    <url>/2020/01/16/python_ex35/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><p>filter()函数用于过滤掉不符合条件的元素，返回一个迭代器对象，一般格式为：</p><pre><code>filter(function,iterable)</code></pre><p>其中，function为半段函数，iterable为可迭代对象。</p><pre><code>def IsEvenFunc(n):    return n % 2 == 0a = list(filter(IsEvenFunc,[1,2,3,4,5]))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/filter.png" alt=" "></p><h2 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a>zip()函数</h2><p>zip()函数接收任意多个可迭代对象作为参数，将对象种对应的元素打包成一个<strong>元组</strong>，然后返回一个可迭代的zip对象<br>如果可迭代对象的长度不相同，取最短的可迭代对象的长度</p><pre><code>zip([iterable,...])</code></pre><p>其中,iterable为一个或多个迭代器。</p><pre><code>a = list(zip([&quot;泰山&quot;,&quot;黄山&quot;,&quot;庐山&quot;,&quot;华山&quot;],[&quot;山东&quot;,&quot;安徽&quot;,&quot;江西&quot;,&quot;陕西&quot;])) #打包print(&quot;a: &quot;,a)z = zip([1,2,3],[4,5,6]) #打包a = list(zip(*z)) #解包print(&quot;a: &quot;,a)</code></pre><p><img src="/img/zip.png" alt=" "></p><p>zip(*z)是解包，但是要注意我们不能先迭代z然后再去解包</p><h2 id="枚举函数enumerate"><a href="#枚举函数enumerate" class="headerlink" title="枚举函数enumerate()"></a>枚举函数enumerate()</h2><p>枚举函数enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标。</p><pre><code>enumerate(sequence,[strat = 0])</code></pre><p>其中，sequence: 一个序列，迭代器或其他支持的迭代对象。<br>start: 下表其实位置，可选。</p><pre><code>weeks = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;,&#39;saturday&#39;]a = list(enumerate(weeks))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/enumerate.png" alt=" "></p><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p>map()函数把函数依此映射到序列或迭代器对象的每个元素上，并返回一个可迭代的map对象作为结果.</p><pre><code>map(function,iterable,....)</code></pre><p>其中，function为被调用的函数,iterable为一个或多个序列</p><pre><code>def cube(x):    return x ** 3a = list(map(cube,[1,2,3,4,5,6])) #计算列表中的各个元素的立方和print(&quot;a: &quot;,a)def add(x, y):    return x + ya = list(map(add,[1,2,3,4,5],[1,2,3,4,5])) #两个列表中相同位置的元素相加print(&quot;a: &quot;,a)a,b = map(int, input(&quot;请输入两个数(用空格隔开):&quot;).split())print(&quot;a = %d, b = %d.&quot;%(a,b))</code></pre><p><img src="/img/map.png" alt=" "></p><ul><li>我们注意到使用了一个函数 input().split()其中split()可以接收键盘输入的两个数字。</li></ul><p>split()函数的原型为：</p><pre><code>    str1.split(str2=&quot; &quot;,num=string.count(str))</code></pre><p>str1 : 表示为字符串<br>str2 : 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。<br>num : 分割次数。默认为 -1, 即分隔所有。</p><h2 id="逻辑运算符和逻辑运算表达式"><a href="#逻辑运算符和逻辑运算表达式" class="headerlink" title="逻辑运算符和逻辑运算表达式"></a>逻辑运算符和逻辑运算表达式</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>名称</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑“与”</td><td>x and y</td><td>x为True或非0，返回y；否则返回x</td></tr><tr><td>or</td><td>逻辑“或”</td><td>x or y</td><td>x为True或非0，返回x；否则返回y</td></tr><tr><td>not</td><td>逻辑“非”</td><td>not x</td><td>x为True或非0，返回False；否则返回True</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>in</td><td>判断对象是否在序列中</td><td>obj sequence</td><td>obj 在 sequence中返回True，否则返回False</td></tr><tr><td>not in</td><td>判断对象是否不在序列中</td><td>obj not int sequence</td><td>obj 不在sequence中返回True，否则返回False</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(1)</title>
    <link href="/2020/01/15/python_ex34/"/>
    <url>/2020/01/15/python_ex34/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>编程语言都先从最基本的基本语法开始</p><h2 id="type-and-isinstance-函数"><a href="#type-and-isinstance-函数" class="headerlink" title="type() and isinstance() 函数"></a>type() and isinstance() 函数</h2><p>type(object): 接收一个对象object来作为参数， 返回这个参数的数据类型<br>isinstance(object, class): 判断接收的对象object是否是给定的类型class的对象：如果是就返回True,如果不是返回False.</p><p>type(object):</p><pre><code>m = 120print(&quot;m Type: &quot;, type(m))m = &quot;大数据&quot;print(&quot;m Type: &quot;, type(m))</code></pre><p><img src="/img/type.png" alt=" "></p><p>isinstance(object, class):</p><pre><code>a = 20print(&quot;a是整型么？&quot;, isinstance(a, int))</code></pre><p><img src="/img/isinstance.png" alt=" "></p><p>在判断一个对象类型时，type() 和 isinstance()有一点区别：</p><ol><li>type()不会认为子类对象时一种父类类型，不考虑继承关系，也就是说type()只检测当前该数据的数据类型</li><li>isinstance()会认为子类队形时一种父类类型，会考虑继承关系，也就是说如果该数据时类的话isinstance()会<br>检测父类的数据类型</li></ol><h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><p>eval()函数用来执行一个字符串表达式，并返回表达式的值，其一般格式为：</p><pre><code>eval(expression[,globals[,locals]])</code></pre><p>其中，expression为表达式。globals为变量作用域，可选，必须是一个字典对象。locals为变量作用域，可选，可以是任何映射(map)对象</p><pre><code>a = eval(&#39;2 + 3&#39;)print(&quot;a: &quot;, a)a, b = eval(input(&quot;请输入两个数(用&#39;,&#39;隔开): &quot;))print(&quot;a: &quot;, a)print(&quot;b: &quot;, b)</code></pre><h2 id="简单了解位运算符"><a href="#简单了解位运算符" class="headerlink" title="简单了解位运算符"></a>简单了解位运算符</h2><p>使用’^’运算对字符加密和解密</p><pre><code>key = input(&quot;请输入加密密匙：&quot;)enc = input(&quot;请输入要加密的字符: &quot;)dec = ord(key) ^ ord(enc)print(&quot;加密结果:&quot;,chr(dec))enc = ord(key) ^ decprint(&quot;解密结果:&quot;,chr(enc))</code></pre><p>1<a href="/img/加密.png"> </a></p><p>在这段程序中我们看到了两个函数ord()和chr():</p><ul><li>ord()函数是对输入的字符转换成ASCII码</li><li>chr()函数是对输入的ASCII码(可以是十进制、十六进制)转换成对应的字符</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker的基本操作</title>
    <link href="/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在Linux运维中我们经常会用到docker，docker通过丰富的镜像软件可以为我们的服务操作带来方便</p><a id="more"></a><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>&emsp;&emsp;首先Docker要求CentOS系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本是否支持安装docker。<br>如果内核版本过低就更新一下系统内核</p><pre><code>yum update</code></pre><p>然后安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>设置yum源：</p><pre><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><img src="/img/docker操作_6.png" alt=" "></p><p>我们可以查看所有仓库中所有docker版本，并选择特定版本安装：</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p><img src="/img/docker操作_5.png" alt=" "></p><p>做好这些前提准备之后我们就可以安装docker了</p><pre><code>sudo yum install docker-ce-17.12.0.ce</code></pre><p>启动、设置开启开机启动</p><pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre><p>完成上面的操作后验证安装是否成功(有client和service两部分表示docker安装启动都成功了):</p><pre><code>docker version</code></pre><p><img src="/img/docker操作_4.png" alt=" "></p><p>查看docker启动状态：</p><pre><code>systemctl status docker</code></pre><p><img src="/img/docker操作_3.png" alt=" "></p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>查询docker安装过的包：<br><img src="/img/docker操作_2.png" alt=""></p><p>删除安装包：</p><pre><code>yum remove docker-ce.x86_64 ddocker-ce-cli.x86_64 -y</code></pre><p>删除镜像/容器等:</p><pre><code>rm -rf /var/lib/docker</code></pre><h2 id="然后我们还可可以删除容器的方法："><a href="#然后我们还可可以删除容器的方法：" class="headerlink" title="然后我们还可可以删除容器的方法："></a>然后我们还可可以删除容器的方法：</h2><ul><li><p>先停止运行的容器：</p><pre><code class="hljs sql">docker container <span class="hljs-keyword">stop</span> [<span class="hljs-keyword">container</span>-<span class="hljs-keyword">id</span>]</code></pre></li><li><p>然后删除容器：</p></li></ul><pre><code class="hljs axapta">docker <span class="hljs-built_in">container</span> rm [<span class="hljs-built_in">container</span>-id]</code></pre><ul><li>最后删除镜像：<pre><code class="hljs arduino">docker <span class="hljs-built_in">image</span> rmi [<span class="hljs-built_in">image</span>-id]</code></pre></li></ul><p>获取对应的 id 可以通过命令：<strong>docker container ls</strong>和 <strong>docker image ls</strong>。<br><img src="/img/docker操作_1.png" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装图床的时可能遇见的问题</title>
    <link href="/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>当你有个人服务器的时候就可以把你的图片存在服务器上，这样就方便以后的存取，这事搭建图床时会遇见的问题。</p><a id="more"></a><h2 id="docker可能遇见的问题"><a href="#docker可能遇见的问题" class="headerlink" title="docker可能遇见的问题"></a>docker可能遇见的问题</h2><p>安装docker时使用在Liunx中使用Docker, 注: Liunx使用的是在虚拟机下的centOS7版本<br>在刚开始安装Docker时没有任何错误, 但是在后续的docker启动过程中, 出现以下问题:</p><pre><code>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>分析一下问题：</p><ol><li>首先查看了一下内核版本</li><li>因为使用命令: yum install docker下载时, 默认下载的是Docker的最新版本, 但是内核版本低的话可能不兼容新版本Docker, 所以有可能出现如上错误</li></ol><p>解决方法：</p><p><strong>步骤一:将以前下载好的Docker卸载干净, 使用如下命令:</strong></p><pre><code>yum remove docker-*</code></pre><p><strong>步骤二:更新该Liunx系统的内核版本,使用如下命令:</strong></p><pre><code>yum update</code></pre><p>建议更新完之后, 重启一下系统</p><p><strong>步骤三:继续下载安装docker(尽量使用高级管理员权限下载)使用如下命令</strong></p><pre><code>yum install docker</code></pre><p><strong>步骤四:使用如下命令启动docker</strong></p><pre><code>sudo systemctl start docker</code></pre><p>问题解决!<br>注：如果这样安装完之后还报错, 按照这个步骤再来一遍即可</p><p><strong>如果使用docker命令时出现如下错误:</strong></p><pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>第一个原因可能是因为docker没有启动<br>第二个原因就是因为docker出现错误<br>归根结底都是docker启动问题, 解决方案还是以上步骤</p><p>22端口是使用的是nginx的服务器<br>80是浏览器的默认端口<br>443端口我设置成图床服务的端口</p><h2 id="Centos-下-nginx-没有-sites-enabled-文件夹问题"><a href="#Centos-下-nginx-没有-sites-enabled-文件夹问题" class="headerlink" title="Centos 下 nginx 没有 sites-enabled 文件夹问题"></a>Centos 下 nginx 没有 sites-enabled 文件夹问题</h2><p>可能是Centos都会遇见的问题解决方法为：<br>编辑 /etc/nginx/nginx.conf 在 http block 中添加：</p><pre><code>include /etc/nginx/sites-enabled/*;</code></pre><p>然后再/etc/nginx 目录下自己创建一个sites-enabled文件夹就好了<br>最后别忘记了重启nginx服务</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo博客搭建到服务器上</title>
    <link href="/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将hexo 博客搭建到github是一件十分简单得事情，但是在GitHub page中使用你得博客时难免会遇见速度慢、域名不宜与他人分享等等问题，所以当你准备把你网站搭建到服务时就可能遇见很多问题，那我就给大家分享我得在搭建时得心得。</p><a id="more"></a><h1 id="服务器准备阶段"><a href="#服务器准备阶段" class="headerlink" title="服务器准备阶段"></a>服务器准备阶段</h1><p>&emsp;&emsp;国内的服务器有很多，阿里云、百度云、腾讯云、牛七云等等。这些服务器都是大厂的旗下的服务器，所以稳定性还是可以保证的，我选择的是阿里云的学生版一年114元。一核2G的内存价格还是很良心的，如果你想要更低的价格，那某宝应该有适合你的选择。一般国内的互联网公司使用的服务器操作系统主要是Centos。选择Centos作为操作系统即可。当你购买服务之后，阿里会给你一个内网和外网的地址。外网地址就是我们使用浏览器可以查询到的地址，也是我们后面会主要使用到的地址。当然IP地址是不容易记住的我们需要购买一下域名，阿里云很方面都是一站式的。然后就是网站的备案，如果你网站使用的是国内的服务器，是需要备案的，如果你不备案，你的网站时无法访问的。备案的时间时比较长的过程和程序也相对比较麻烦。在这里大家注意一点就是，如果你的备案地址写的是你的学校，那么你就要将你的地址精确到你寝室的楼栋和房间号。</p><p><img src="/img/服务器.png" alt=" "></p><h1 id="第一步在服务器上安装nginx"><a href="#第一步在服务器上安装nginx" class="headerlink" title="第一步在服务器上安装nginx"></a>第一步在服务器上安装nginx</h1><h2 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h2><p>&emsp;&emsp;Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。。 本例演示 CentOS 7 下安装和配置 Nginx 的基本步骤。</p><h2 id="步骤1：添加yum源"><a href="#步骤1：添加yum源" class="headerlink" title="步骤1：添加yum源"></a>步骤1：添加yum源</h2><pre><code>$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><p>安装完yum源之后，可以查看一下。</p><pre><code>repo id                                 repo name                                                              statusbase/7/x86_64                           CentOS-7                                                               10,097epel/x86_64                             Extra Packages for Enterprise Linux 7 - x86_64                         13,510extras/7/x86_64                         CentOS-7                                                                  307nginx/x86_64                            nginx repo                                                                170updates/7/x86_64                        CentOS-7                                                                1,010repolist: 25,094</code></pre><p>可以发现<font width="bolder" color="red">nginx repo</font>已经安装到本机了</p><h2 id="步骤2：安装"><a href="#步骤2：安装" class="headerlink" title="步骤2：安装"></a>步骤2：安装</h2><p>yum 安装 Nginx，非常简单，一条命令。</p><pre><code>$ sudo yum install nginx</code></pre><h2 id="步骤-3-配置-Nginx-服务"><a href="#步骤-3-配置-Nginx-服务" class="headerlink" title="步骤 3: 配置 Nginx 服务"></a>步骤 3: 配置 Nginx 服务</h2><p>设置开机启动</p><pre><code>$ sudo systemctl enable nginx</code></pre><p>启动服务</p><pre><code>$ sudo systemctl start nginx</code></pre><p>停止服务</p><pre><code>$ sudo systemctl restart nginx</code></pre><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><pre><code>$ sudo systemctl reload nginx</code></pre><p>到这里我们输入我们服务器外网的网址就可以看到<strong>nginx welcome</strong>的欢迎界面。此时就说明你的nginx已经安装完成了。</p><h1 id="在服务器上安装git"><a href="#在服务器上安装git" class="headerlink" title="在服务器上安装git"></a>在服务器上安装git</h1><p><P><br>&emsp;&emsp;当我们把nginx安装到我们的服务器之后，下一步就是安装git。如果之前你已经搭建过hexo博客并且已经将博客搭建在GitHub上时后面的步骤你将会稍微比较熟悉。<br>&lt;/p&gt;</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><pre><code>git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git</code></pre><h2 id="创建用户并配置其仓库"><a href="#创建用户并配置其仓库" class="headerlink" title="创建用户并配置其仓库"></a>创建用户并配置其仓库</h2><pre><code>useradd gitpasswd git // 设置密码su git // 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p projects/blog // 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git // 创建一个裸露的仓库cd blog.git/hooksvi post-receive // 创建 hook 钩子函数，输入了内容如下</code></pre><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span>git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</code></pre><p>添加完毕后修改权限</p><pre><code>chmod +x post-receiveexit // 退出到 root 登录chown -R git:git /home/git/repos/blog.git // 添加权限</code></pre><h2 id="测试git仓库是否可用，另找空白文件夹"><a href="#测试git仓库是否可用，另找空白文件夹" class="headerlink" title="测试git仓库是否可用，另找空白文件夹"></a>测试git仓库是否可用，另找空白文件夹</h2><pre><code>git clone git@server_ip:/home/git/repos/blog.git</code></pre><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><h2 id="Git配置仓库"><a href="#Git配置仓库" class="headerlink" title="Git配置仓库"></a>Git配置仓库</h2><p>&emsp;&emsp;这一部分主要目的是让我们个人的电脑可以通过ssh方式连接到云服务器，然后我们就可以通过命令行方式将我们的博客Po到服务器上。操作如下： 安装git: yum install git 配置git用户 adduser git 修改用户权限:</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoers</code></pre><pre><code class="hljs ada">找到这个位置添加下面这句话 git <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span></code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d76b9d87178?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=" "></p><p>保存退出后 将sudoers文件权限改回原样</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，然后在~目录下创建.ssh文件夹</p><pre><code>        su git        cd ~        mkdir .ssh        cd .ssh</code></pre><p><strong>生成公钥密钥文件</strong>(重点)</p><font color="red" size="bolder">ssh-keygen</font><p><strong>此时在目录下就会有两个文件，分别是</strong></p><font color="red" size="bolder">id_rsa 和 id_rsa.pub</font><p>其中<strong>id_rsa.pub</strong>就是公钥文件 我们复制一份</p><font color="red" size="bolder">cp id_rsa.pub authorized_keys</font><p><strong>这样目录下就会有一个authorized_keys文件，它和id_rsa.pub一模一样。<br>最后我们修改它的权限</strong></p><pre><code>chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>&emsp;&emsp;但是大家一定要注意在远程连接服务其之前，我们一定要先对我能的服务器进行设置。<br>在root用户下修改 <strong>/etc/ssh/sshd_config</strong> 文件中的<strong>PasswordAuthentication no改为PasswordAuthentication yes</strong> 并保存。<br><img src="https://img.alicdn.com/tfs/TB1B8ELgHsTMeJjSszgXXacpFXa-799-554.png" alt=" "><br>输入如下命令<strong>sudo service sshd restart</strong>重启SSH服务,就可以重新使用账号密码连接服务器了。<br><img src="https://img.alicdn.com/tfs/TB1OjQ_gMMPMeJjy1XbXXcwxVXa-812-264.png" alt=" "></p><p>&emsp;&emsp;然后我们在<strong>自己的电脑上自己的电脑上自己的电脑上</strong>（重要的事说三遍），打开cmd，使用ssh方式连接我们的云服务器。<br>     <img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d7a77735c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=" "></p><p>最后当你远程连接上你的服务器时，就会出现<br><img src="/img/服务器-4.png" alt=" "></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我们需要更改hexo博客的根目录下的_config.yml文件将最后一行的的repo：后面改成 </p><pre><code>git@这里写服务器外网IP:/home/git/repos/blog.git</code></pre><p>之后大家就可以来尝试用hexo clean &amp; hexo g &amp; hexo d 来部署大家的博客了。<br><img src="/img/服务器-2.png" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多文件编译</title>
    <link href="/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<!--banner_img:是当前页面图片--><p>在编译多个文件的时候所出现的报错<br><a id="more"></a></p><h1 id="多文件编译遇见的问题"><a href="#多文件编译遇见的问题" class="headerlink" title="多文件编译遇见的问题"></a>多文件编译遇见的问题</h1><p><img src="/img/报错截图.jpg" alt=" "></p><p>该错误出现在 command line 为</p><pre><code class="hljs apache"><span class="hljs-attribute">gcc</span> coordin.h file<span class="hljs-number">1</span>.cpp file<span class="hljs-number">2</span>.cpp -o file<span class="hljs-number">1</span></code></pre><p><strong>解决方法为：</strong><br><strong>解决方法是用如下命令进行编译(使用 -l 来连接 stdc++):</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">coordin</span><span class="hljs-selector-class">.h</span> <span class="hljs-selector-tag">file1</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">file2</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">HelloWorld</span></code></pre><p><strong>gcc编译cpp文件为什么要加-lstdc++?</strong></p><pre><code>   gcc可以编译c++文件，也可以编译c文件，但默认是编译c文件的，加-lstdc++表示编译c++文件，即链接c++库，加-lc表示链接c库，默认情况下就是链接c库，所以如果编译c文件可以不加-lc。</code></pre><p><strong>另外，你也可以使用 g++, 效果是一样的, stdc++会被自动连接:</strong><br><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ <span class="hljs-selector-tag">coordin</span><span class="hljs-selector-class">.h</span> <span class="hljs-selector-tag">file1</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">file2</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">HelloWorld</span></code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单题（1136）</title>
    <link href="/2019/12/15/AC%EF%BC%881136%EF%BC%89/"/>
    <url>/2019/12/15/AC%EF%BC%881136%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这个一道递归优化问题</p><a id="more"></a><h1 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h1><p><strong>题目表述</strong><br>优化一下代码：<br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> f(n - <span class="hljs-number">1</span>) + f(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;<span class="hljs-built_in">cin</span> &gt;&gt; n;<span class="hljs-built_in">cout</span> &lt;&lt; f(n);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><br><strong>输入</strong><br>    一个小于50的正整数n。<br><strong>输出</strong><br>    f(n)，不要换行。<br><strong>样例输入</strong><br>    3<br><strong>样例输出</strong><br>    3</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;这个题目看起来没有什么意思，但是我们通过分析计算我们会发现。<br>&emsp;&emsp;1. 递归50次后$int$是否够存，<br>&emsp;&emsp;2. 递归50次后会不会爆栈。<br>&emsp;&emsp;3. 我们应该如何优化。<br>&emsp;&emsp;我们将代码复制到编辑器里面后编译会发现在输入49后$int$会溢出说明这49的递归后是一个超过21亿的数，所以我们应该使用$long$ $long$来储存这个庞大的数值。然后就是爆栈的问题，在使用$long$ $long$之后还是能计算出来的说明还没有爆栈，还能计算。然后就是递归的优化问题了。</p><h3 id="什么是递归优化？"><a href="#什么是递归优化？" class="headerlink" title="什么是递归优化？"></a>什么是递归优化？</h3><p>&emsp;&emsp;递归优化是由于递归多次后递归深度过大，导致爆栈。或者是由于递归深度过深之后时间过长，导致之间效率低下。所以我们常见的递归优化有两种。</p><ol><li>尾递归。</li><li>将递归改循环。<br>两种方法，我们在记忆化之后我们发现这些数列之间的插值满足斐波拉切数列。所以我们就可以把这个递归函数改成一个循环函数。就可以实现对递归的优化。</li></ol><p><strong>答案</strong><br><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/*int f(int n)</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">if (n &lt; 0) return 0;</span><span class="hljs-comment">if (n == 0) return 1;</span><span class="hljs-comment">return f(n - 1) + f(n - 2);</span><span class="hljs-comment">&#125;*/</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  <span class="hljs-title">fibo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> nFirst = <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> nSecond = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  nThird = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n; i++)&#123;        nThird = nFirst + nSecond;        nFirst = nSecond;        nSecond = nThird;    &#125;    <span class="hljs-keyword">return</span> nThird;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)    &#123;        count += fibo(i);    &#125;    <span class="hljs-keyword">return</span> count+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;<span class="hljs-built_in">cin</span> &gt;&gt; n;<span class="hljs-built_in">cout</span> &lt;&lt; f(n);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>顺序表简述</p><a id="more"></a><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p><strong>顺序映象</strong>：</p><p>&emsp;&emsp;—— 以x的存储位置和y的春初位置之间某种关系表示逻辑关系<x,y></p><p>最简单的一种顺序映象方式是：</p><p>&emsp;&ensp;令 y 的存储位置和 x 的存储位置相邻。用一组==地址连续==的存储单元==依次存放==线性表中的元素。==线性表的起始地址==，称作线性表的<strong>基地址</strong>。也就是第一个元素。</p><p>以“存储位置相邻”表示有序对$<a_{i-1},a_i>$,即：$LOC(a~i~) = LOC(a~i-1~) + C$;</p><p>&emsp;&ensp;所有数据元素的存储位置。$LOC(a~i~) = LOC(a~1~) + (i - 1) \times C$,其中LOC(a~1~)就是基地址。</p><ul><li>存取结构：与存储结构是两个不同的概念。</li><li>存取结构是在一个数据结构上对查找操作的时间性能的一种描述。</li><li><p>通常由两种存取结构；随机存取结构和顺序存取结构。</p><ul><li>随机存取结构是指在一个数据结构上进行查找的时间性能是$O(1)$,即查找任意一个数据元素的时间时候相等的，均为常数时间，例如顺序表示一种随机存期结构。</li><li>顺序存取结构是指在一个数据结构上进行查找的时间性能是$O(n)$，即查找一个数据元素的时间复杂度是线性的，与该元素在结构中的位置有关，例如单链表是一种顺序存储结构。</li></ul></li></ul><h2 id="顺序映象的C语言描述"><a href="#顺序映象的C语言描述" class="headerlink" title="顺序映象的C语言描述"></a>顺序映象的C语言描述</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTSIZE 100  <span class="hljs-comment">//存储空间最大分配量</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType elem[LISTSZIE];    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">//当前长度</span>&#125;Sqlist; <span class="hljs-comment">//Sqlist，代表线性表;</span></code></pre><ul><li>在线性表的静态分配顺序存储结构中，线性表的最多数据元素个数为LSITSIZE，元素数量不能随意增加，这是以数组方式描述线性表的缺点。</li></ul><p>&emsp;&ensp;为了实现线性表最大存储数据元素数可随意变化，可以使用一个动态的数组来取代上面的固定长度数组，如下描述。</p><p>线性表的动态分配顺序储存结构：<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//初始分配量</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTINCREMENT 10 <span class="hljs-comment">//分配分配增量</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType *elem;  <span class="hljs-comment">//储存空间基址</span>    <span class="hljs-keyword">int</span> length; <span class="hljs-comment">//当前长度</span>    <span class="hljs-keyword">int</span> listsize; <span class="hljs-comment">//当前分配的存储容量</span>&#125;SqList;<span class="hljs-comment">// 俗称 顺序表</span></code></pre></p><h3 id="线性表操作"><a href="#线性表操作" class="headerlink" title="线性表操作"></a>线性表操作</h3><h3 id="1-InitList-amp-L"><a href="#1-InitList-amp-L" class="headerlink" title="1.InitList(&amp;L);"></a>1.InitList(&amp;L);</h3><p>&emsp;&emsp;InitList(&amp;L); 的实现是一个加工型的运算，因此，将L设为引用参数，首先动态分配存储空间，然后，将length设置为0，表示表中没有数据元素。</p><p>代码实现：<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span> <span class="hljs-params">(SqList &amp;L)</span></span>&#123;    L.elem = (ElemType* )<span class="hljs-built_in">malloc</span>(LIST_INIT_SIZE * <span class="hljs-keyword">sizeof</span> (ElemType));    <span class="hljs-keyword">if</span> (!L.elem)&#123;        <span class="hljs-built_in">exit</span> (<span class="hljs-number">1</span>);<span class="hljs-comment">//储存分配失败</span>    &#125;    L.length = <span class="hljs-number">0</span>;    L.listsize = LIST_INIT_SIZE;<span class="hljs-comment">//初始储存容量;</span>    <span class="hljs-keyword">return</span> OK;&#125;</code></pre></p><h3 id="2-LocateElme-L-x-compare"><a href="#2-LocateElme-L-x-compare" class="headerlink" title="2.LocateElme(L,x,compare());"></a>2.LocateElme(L,x,compare());</h3><ul><li>线性表中的<strong>按置操作</strong>是指在线性表中查找与给定值X相等的数据元素。</li><li>顺序表中完成该运算最简单的方法是：从第一个元素a~1~起依次和X比较，直到找到一个与X相等的数据元素，则返回它在顺序表中的存储下标记或序号(二者差1);或者查遍整个表都没有找到与X相等的元素，返回ERROR。</li></ul><p>代码实现：<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">LocateElem_Sq</span> <span class="hljs-params">(SqList L, ElemType x)</span></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= L.length<span class="hljs-number">-1</span> &amp;&amp; L.elem[i] != x)&#123;        i++;    &#125;    <span class="hljs-keyword">if</span>(i &gt; L.length - <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> ERROR;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;&#125;</code></pre></p><blockquote><p>本算法的主要运算是比较，显然比较的次数与x在表中的位置有关，也与表长有关。当a~1~ = x时，比较一次成功，当a~n~ = x时比较n次成功，按值查找的平均比较次数为 $\frac{(N+1)}{2}$,时间性能为$O(n)$。</p></blockquote><h3 id="3-ListInsert-amp-L-i-e"><a href="#3-ListInsert-amp-L-i-e" class="headerlink" title="3. ListInsert(&amp;L, i, e)"></a>3. ListInsert(&amp;L, i, e)</h3><p>代码实现:<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-keyword">int</span> i, ElemType e)</span></span>&#123;    <span class="hljs-comment">//在顺序表L的第i个元素之前插入新的元素e</span>    <span class="hljs-comment">//i的合法范围为 1 &lt;=i&lt;=L.length+1</span>    ElemType *q = &amp;(L.elem[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//q指示插入位置</span>    ElemType *p;    <span class="hljs-keyword">for</span> (p = &amp;(L.elem[L.length<span class="hljs-number">-1</span>]); p &gt;= q; --p)&#123;            *(p + <span class="hljs-number">1</span>) = *p;<span class="hljs-comment">//插入位置及之后的元素右移</span>            *q = e;<span class="hljs-comment">//插入e</span>        ++L.length;<span class="hljs-comment">//表长增1</span>    &#125;&#125;</code></pre><br>算法时间复杂度为：$O(ListLength(L))$</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//插入位置不合法</span>&#125;<span class="hljs-keyword">if</span> (L.length &gt;= L.listsize)&#123;    <span class="hljs-keyword">return</span> OVERFLOW;<span class="hljs-comment">//当前存储空间已满</span>&#125;</code></pre><h4 id="考虑移动元素的平均情况："><a href="#考虑移动元素的平均情况：" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设在第i个元素之前插入的概率为p~i~,则在长度为<em>n</em>的线性表中插入一个元素为所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_is = \sum_{i = 1}^{n + 1} P_i(n - i + 1)</script><p>所有为位置的概率的累加和。</p><p>&emsp;&emsp;若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_is = \frac{i}{n+1}\sum_{i=1}^{n+1}(n-i+1) = \frac{2}{n}</script><h3 id="4-ListDelete-amp-L-i-amp-e-的实现："><a href="#4-ListDelete-amp-L-i-amp-e-的实现：" class="headerlink" title="4. ListDelete(&amp;L, i, &amp;e)的实现："></a>4. ListDelete(&amp;L, i, &amp;e)的实现：</h3><p>代码实现：<br><pre><code class="hljs reasonml">Status LsitDelet_Sq (SqList &amp;L, <span class="hljs-built_in">int</span> i, ElemType &amp;e)&#123;    <span class="hljs-keyword">if</span>((i &lt; <span class="hljs-number">1</span>)<span class="hljs-operator"> || </span>(i &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>length))&#123;        return ERROR;<span class="hljs-comment">//删除位置不合法</span>    &#125;    p = &amp;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>elem<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span>);<span class="hljs-comment">//p为被删除元素的位置</span>    e = *p;<span class="hljs-comment">//被删除元素的值赋给e,可以查看被删元素</span>    q = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>elem + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>length-<span class="hljs-number">1</span>;<span class="hljs-comment">//表尾元素的位置，基址加上一个整数值</span>    <span class="hljs-keyword">for</span> (++p; p &lt;= q; ++p)&#123;        *(p-<span class="hljs-number">1</span>) = *p;<span class="hljs-comment">//被删除元素之后的元素左移</span>        --<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>length;<span class="hljs-comment">//表长减一</span>    &#125;    return OK;&#125;</code></pre><br>算法时间复杂度为：$O(ListLength(L))$</p><h4 id="考虑移动元素的平均情况：-1"><a href="#考虑移动元素的平均情况：-1" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设删除第i个元素的概率为$q_i$,则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_dl = \sum_{i=1}^{n}q_i(n-i)</script><p>&emsp;&emsp;假设定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_dl=\frac{1}{n}\sum_{i=1}^{n}(n-1)=\frac{n-1}{2}</script>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链式存储</title>
    <link href="/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>链式存储的基本实现</p><a id="more"></a><h2 id="1-3线性表的链式存储结构-单链表"><a href="#1-3线性表的链式存储结构-单链表" class="headerlink" title="1.3线性表的链式存储结构(单链表)"></a>1.3线性表的链式存储结构(单链表)</h2><p>&emsp;&emsp;用一组地址任意的存储来存放线性表中的元素。</p><p>&emsp;&emsp;以<strong>元素</strong>（数据元素的映象）+指针（指示后继元素存储位置）=<strong>结点</strong>（表示数据元素或数据元素的映象）</p><p>&emsp;&emsp;以“结点的序列”表示线性表<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————称作链表</p><p>&emsp;&emsp;以线性表中第一个数据元素a~1~的存储地址作为线性表中的地址，称作线性表的头指针。<br>&emsp;&emsp;有时为了操作方便，在第一个结点之前需加一个“头结点”，以指向头结点的指针为链表的头指针。</p><h3 id="单链表的C语言实现："><a href="#单链表的C语言实现：" class="headerlink" title="单链表的C语言实现："></a>单链表的C语言实现：</h3><pre><code>typedef struct LNode&#123;    ElemType data;//数据域    struct LNode *next;//指针域&#125;LNode, *LinkList;LinkList L;//L为单链表的头指针;</code></pre><p>单链表操作实现的基本实现：</p><ul><li>GetElem(L, i, e)&emsp;//取第i个数据元素</li><li>ListInsert(&amp;L, i, e)&emsp;//插入数据元素</li><li>ListDelete(&amp;L, i, e)&emsp;//删除数据元素</li><li>ClearList(&amp;L)&emsp;//重新置为一个空表</li><li>CreateList(&amp;L, n)&emsp;//生成含$n$个数据元素的链表</li></ul><p>找第1个数据元素，必须先找到第$i-1$个数据元素。因此，查找第i个数据元素的基本操作是==移动指针，比较j和i==。令指针p始终指向线性表中第j个数据元素。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dummy Node</title>
    <link href="/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/"/>
    <url>/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="链表Dummy-Node"><a href="#链表Dummy-Node" class="headerlink" title="链表Dummy Node"></a>链表Dummy Node</h1><h2 id="（一）Partition-List"><a href="#（一）Partition-List" class="headerlink" title="（一）Partition List"></a>（一）Partition List</h2><p><a href="https://leetcode.com/problems/partition-list/description/">https://leetcode.com/problems/partition-list/description/</a></p><p><strong>题目：给出一个链表和一个x值，要求返回一个顺序链表使得小于x的数在链表前面，大于等于x的数在链表后面，保证节点顺序不变。</strong></p><pre><code>      例如：$1-&gt;3-&gt;2-&gt;4-&gt;2, 3$ 变成：$1-&gt;2-&gt;2-&gt;3-&gt;4$</code></pre><font color="#435d6c" size="3px">解答：建立两个新的左、右指针及dummy node，使用head指针遍历整个链表，遇到大于等于head的节点则放到右链表，否则放到左链表。最后将左右链表相连。第一次犯错：忘记将又指针的尾部指向null;</font><p>代码：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;         <span class="hljs-keyword">if</span> (head == null) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                ListNode leftDummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode rightDummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode left = leftDummy;        ListNode right = rightDummy;                <span class="hljs-keyword">while</span> (head != null) &#123;            <span class="hljs-keyword">if</span> (head.val &gt;= x) &#123;                right.next = head;                right = right.next;            &#125; <span class="hljs-keyword">else</span> &#123;                left.next = head;                left = left.next;            &#125;            head = head.next;        &#125;        right.next = null;        left.next = rightDummy.next;        <span class="hljs-keyword">return</span> leftDummy.next;    &#125;&#125;</code></pre><h2 id="（二）-Merge-Two-Sorted-Lists"><a href="#（二）-Merge-Two-Sorted-Lists" class="headerlink" title="（二） Merge Two Sorted Lists"></a>（二） Merge Two Sorted Lists</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></p><font color="red">AC！</font><p><b>题目：将两个顺序链表合并成一个顺序链表；</b></p><font color="#435d6c" size="3px">解答：依次比较两个链表里的值大小进行排列；</font><p>改进：当一个链表指针指向null，另一个链表还没时，可以直接将重新排列的链表尾指向当前指针：<br><pre><code class="hljs c++">           <span class="hljs-keyword">if</span> (l1 != null) &#123;           head.next = l1;           &#125; <span class="hljs-keyword">else</span> &#123;           head.next = l2;          &#125;</code></pre></p><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode head = dummy;                <span class="hljs-keyword">while</span> (l2 != null &amp;&amp; l1 != null) &#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;                head.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                head.next = l2;                l2 = l2.next;            &#125;            head = head.next;        &#125;         <span class="hljs-keyword">while</span> (l1 != null) &#123;            head.next = l1;            l1 = l1.next;            head = head.next;        &#125;        <span class="hljs-keyword">while</span> (l2 != null) &#123;            head.next = l2;            l2 = l2.next;            head = head.next;        &#125;        head.next = null;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></p><h2 id="（三）swap-two-nodes-in-linked-list"><a href="#（三）swap-two-nodes-in-linked-list" class="headerlink" title="（三）swap two nodes in linked list"></a>（三）swap two nodes in linked list</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">https://leetcode.com/problems/swap-nodes-in-pairs/description/</a></p><font color="red" >AC！</font><p><b>题目：两两交换链表中节点位置。</b>如：$1-&gt;2-&gt;4-&gt;5-&gt;6$ 转变为: $2-&gt;1-&gt;5-&gt;4-&gt;6$</p><font color="#435d6c" size="3px">解答：使用两个指针遍历链表；</font><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == null) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        dummy.next = head;        ListNode headNext = head.next;        ListNode headPrev = dummy;                <span class="hljs-keyword">while</span> (head != null &amp;&amp; headNext != null) &#123;            headPrev.next = headNext;            head.next = headNext.next;            headNext.next = head;            headPrev = head;            head = head.next;            <span class="hljs-keyword">if</span> (head != null) &#123;                headNext = head.next;            &#125;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></p><h2 id="（四）reorder-list"><a href="#（四）reorder-list" class="headerlink" title="（四）reorder list"></a>（四）reorder list</h2><p><a href="https://leetcode.com/problems/reorder-list/description/">https://leetcode.com/problems/reorder-list/description/</a></p><p><b>题目：给定一个单链表：</b>$L0-&gt;L1-&gt;…-&gt;Ln-1-&gt;Ln,$</p><pre><code>      重新排序后为：$L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2-&gt;...$</code></pre><font color="#435d6c" size="3px">解答：第一次犯错：将链表尾连接到头之后，忘记将尾的前一个指针指向空；第二次犯错：忘记考虑链表头和prevTail重合的情况（偶数链表）。</font><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">while</span> (head != null &amp;&amp; head.next != null) &#123;            ListNode prevTail = head;            <span class="hljs-keyword">while</span> (prevTail.next.next != null) &#123;                prevTail = prevTail.next;            &#125;            ListNode tail = prevTail.next;            <span class="hljs-keyword">if</span> (head.next == tail) &#123;                <span class="hljs-keyword">break</span>;            &#125;             tail.next = head.next;            head.next = tail;            head = head.next.next;            prevTail.next = null;        &#125;    &#125;&#125;</code></pre></p><h2 id="（四）Rotate-List"><a href="#（四）Rotate-List" class="headerlink" title="（四）Rotate List"></a>（四）Rotate List</h2><p><a href="https://leetcode.com/problems/rotate-list/description/">https://leetcode.com/problems/rotate-list/description/</a></p><p><strong>题目：将链表尾部的k个节点移到链表头部；</strong></p><font color="#435d6c" size="3px">解答：每次将链表最后一个节点移动至链表头，移动k次；</font><p>第一次犯错：（超时）先遍历链表，得到链表长度length，循环只需执行 k%length 次；</p><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode tail = head;        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> (tail != null ) &#123;            length++;            tail = tail.next;        &#125;                <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span> || length == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k % length; i++) &#123;            ListNode preTail = head;            <span class="hljs-keyword">while</span> (preTail != null &amp;&amp; preTail.next != null &amp;&amp; preTail.next.next != null) &#123;                preTail = preTail.next;            &#125;            tail = preTail.next;            tail.next = head;            preTail.next = null;            head = tail;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>二叉树有多种遍历的方式我们简单总结一下</p><a id="more"></a><h1 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h1><p><p>&emsp;&emsp;<b>二叉树的遍历(treaversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</b>这是二叉树遍历的定义。二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分四种。</p></p><ol><li>前序遍历(PreOrder)<br></li><li>中序遍历(InOrder)<br></li><li>后续遍历(PastOrder)<br></li><li>层序遍历(LevelOrder)<br></li></ol><p>树的前中后序遍历是个递归的定义，在遍历到根节点的左/右子树时，也要遵循前/中/后序遍历的顺序，例如下面这棵树：</p><p>前序遍历：ABDECFG<br>中序遍历：DBEAFCG<br>后序遍历：DEBFGCA<br>层序遍历：ABCDEFG</p><p>树的结点结构体声明如下：<br>语言：C语言（为了省事用到了C++的栈，因为C语言要用栈的话要自己重新写一个出来，就偷了个懒）<br>编译器：VS</p><pre><code>typedef char DataType;typedef struct TreeNode&#123;    DataType data;    struct TreeNode *left;    struct TreeNode *right;&#125;TreeNode;</code></pre><p>前序遍历（先序遍历）<br>对于一棵树的前序遍历，递归的写法是最简单的（写起来），就是将一个大的问题转化为几个小的子问题，直到子问题可以很容易求解，最后将子问题的解组合起来就是大问题的解。</p><p>前序访问的递归写法<br>先放代码，如果看完觉得不太清楚可以看看下面的详细步骤图解。</p><pre><code>void PreOrder(const TreeNode *root)&#123;    if (root == NULL)                 //若结点为空    &#123;        printf(&quot;# &quot;);        return;    &#125;    printf(&quot;%c &quot;, root-&gt;data);        //输出根节点的值    PreOrder(root-&gt;left);             //前序访问左子树    PreOrder(root-&gt;right);            //前序访问右子树&#125;</code></pre><p>比如说还是上面的这颗树：</p><p>访问根节点</p><p>访问左子树</p><p>走到这里之后发现根节点的左孩子还是一棵子树，那就将访问这棵子树看作是遍历整颗树的一个子问题，遍历这棵子树的方法和遍历整颗树的方法是一样的。<br>然后继续访问它的左子树：</p><p>为了理解起来方便一点，我在这里加上了它的两个为空的左右孩子<br>然后发现这（可能）还是一棵子树，就继续用这种方法来对待这颗子树，就是继续访问它的左子树：</p><p>发现这是一个空节点，那就直接返回，去访问它的右子树：</p><p>发现还是一个空节点，那么继续返回，这时候D和它的左右孩子结点都访问过了，继续返回，应该访问B的右子树了。</p><p>然后就和D结点一样的处理方法，-&gt;左孩子，发现是空，返回-&gt;右孩子，发现还是空，继续返回，发现这时候B的左右孩子都访问过了，继续返回。<br>访问右子树</p><p>然后和处理A的左子树的方法一样，最后访问到G结点的右子树时，发现是空，就返回，这时候树的所有节点都已经访问过了，所以可以一路返回到A结点的右子树完的地方，整个递归就结束了。</p><p>最后输出的前序访问序列便是：ABDECFG<br>前序访问的非递归写法<br>还是先上代码：</p><pre><code>void PreOrderLoop(TreeNode *root)&#123;    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top;    cur = root;    while (cur != NULL || !s.empty())    &#123;        while (cur != NULL)        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            s.push(cur);            cur = cur-&gt;left;        &#125;        top = s.top();        s.pop();        cur = top-&gt;right;    &#125;&#125;</code></pre><p>非递归的写法比递归写法要麻烦一点，要用到栈来存储树的结点，在理解非递归方法的时候要重点理解栈中保存的元素的共同点是什么，在前序访问中，栈中元素都是自己和自己的左孩子都访问过了，而右孩子还没有访问到的节点，如果不太懂可以看下面的详细步骤图解。</p><p>首先我们要用一个指针（cur）来指向当前访问的结点</p><p>发现这个节点不为空，就将它的数据输出，然后将这个节点的地址（图上的栈中写了节点的值是为了便于理解，实际上栈中保存的是节点地址）压栈。</p><p>再去访问它的左子树，发现左孩子结点依旧不为空，继续输出并压栈。</p><p>同理压栈D节点</p><p>然后访问D的左孩子，发现为空，便从栈中拿出栈顶结点top，让cur = top-&gt;right,便访问到了D的右孩子。</p><p>发现D的右孩子还是为空，这个看一下栈，发现栈不为空，说明还存在右孩子没被访问过的节点，就继续从栈中拿出栈顶结点top，让cur = top-&gt;right，便访问到了B的右孩子。</p><p>B的右孩子处理方法和D一样，然后再从栈中拿出A节点，去访问A的右孩子C，在访问到G节点的右孩子之后，发现当前节点cur为空，栈中也没有元素可以取出来了，这时候就代表整棵树都被访问过了，便结束循环。</p><p>最后输出的前序访问序列便是：ABDECFG<br>中序遍历<br>对于一棵树的中序遍历，和前序一样，可以分为递归遍历和非递归遍历，递归遍历是相对简单的，还是子问题思想，将一个大问题分解，直到可以解决，最后解决整个大问题。</p><p>中序遍历的递归写法<br>还是先上代码：</p><pre><code>void InOrder(const TreeNode *root)&#123;    if (root == NULL)              //判断节点是否为空    &#123;        printf(&quot;# &quot;);        return;    &#125;    InOrder(root-&gt;left);           //中序遍历左子树    printf(&quot;%c &quot;, root-&gt;data);     //访问节点值    InOrder(root-&gt;right);          //中序遍历右子树&#125;</code></pre><p>从根节点进入</p><p>发现根节点不为空，访问左子树</p><p>发现不为空，继续访问左子树</p><p>发现不为空，继续访问左子树</p><p>这时root为空了，就返回去访问它的根节点，刚才的访问只是路过，并没有真正地遍历节点的信息，在返回途中才是真正地遍历到了节点的信息。</p><p>访问到了D节点，下来要访问的是D的右孩子，因为D的左孩子已经访问过了。</p><p>发现还是空，就返回，而它的根节点D也访问过了，那么就继续返回，该访问D节点的父节点B了。</p><p>B访问过后下来要访问的是B的右孩子，因为是从B的左子树回来的路，B的左孩子已经访问过了。</p><p>然后和访问D一样，-&gt;左孩子，为空，返回访问根节点E，-&gt;右孩子，为空（这部分就不画了，和D节点的访问是一样的），最后返回，B已经访问过了，就继续返回，至此，整颗树的左子树访问完了。</p><ol><li><p>访问B的根节点A</p></li><li><p>遍历A的右子树<br>遍历右子树的过程和左子树一样，还是左-&gt;根-&gt;右的中序遍历下去，直到遍历到G的右孩子，发现为空，就返回，因为右子树都遍历过了，所以可以一直返回到root为A节点的那一层递归，整个遍历结束。</p></li></ol><p>最后输出的中序访问序列为：DBEAFCG</p><p>非递归写法<br>中序访问的非递归写法和前序一样，都要用到一个栈来辅助存储，不一样的地方在于前序访问时，栈中保存的元素是右子树还没有被访问到的节点的地址，而中序访问时栈中保存的元素是节点自身和它的右子树都没有被访问到的节点地址。</p><p>先上代码：</p><pre><code>void InOrderLoop(TreeNode *root)&#123;    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur;    cur = root;    while (cur != NULL || !s.empty())    &#123;        while (cur != NULL)        &#123;            s.push(cur);            cur = cur-&gt;left;        &#125;        cur = s.top();        s.pop();        printf(&quot;%c &quot;, cur-&gt;data);        cur = cur-&gt;right;    &#125;&#125;</code></pre><p>cur指针一路沿着最左边往下访问，路过的节点全部压栈，直到遇到空节点</p><p>从栈中取出栈顶节点top，输出栈顶结点的值并使cur = top-&gt;right，从第一步开始去遍历top的右子树。</p><p>遍历完之后，cur走到了D节点的右孩子，发现cur 为空，但栈中还有元素，就重复第二步</p><p>这时候，cur走到了E节点的右孩子，发现cur 为空，但栈中还有元素，就继续重复第二步，之后cur = top-&gt;right，cur指针继续去遍历A节点的右子树，从第一步开始</p><p>访问到F的左孩子节点发现是空，这时候栈中还有元素，就重复第二步</p><p>照这个规则依次访问下去，最后会访问到G节点的右孩子，这时候cur为空，栈也空了，就代表所有节点已经遍历完了，就结束循环，遍历完成。</p><p>最后输出的中序访问序列为:DBEAFCG</p><p>后序遍历<br>后序遍历还是分递归版本和非递归版本，后序遍历的递归版本和前序中序很相似，就是输出根节点值的时机不同，而后序遍历的非递归版本则要比前序和中序的要难一些，因为在返回根节点时要分从左子树返回和右子树返回两种情况，从左子树返回时不输出，从右子树返回时才需要输出根节点的值。</p><p>递归写法<br>先上代码：</p><pre><code>void PostOrder(TreeNode *root)&#123;    if (root == NULL)    &#123;        printf(&quot;# &quot;);        return;    &#125;    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    printf(&quot;%c &quot;, root-&gt;data);&#125;</code></pre><p>后序遍历的递归版本和前中序非常相似，就是输出根节点值的时机不同，详细图解这里就不画了，可以联系前中序的递归版本来理解。</p><p>后序遍历的非递归写法<br>后序遍历的非递归同样要借助一个栈来保存元素，栈中保存的元素是它的右子树和自身都没有被遍历到的节点，与中序遍历不同的是先访问右子树，在回来的时候再输出根节点的值。需要多一个last指针指向上一次访问到的节点，用来确认是从根节点的左子树返回的还是从右子树返回的。</p><p>先上代码：</p><pre><code>void PostOrderLoop(TreeNode *root)&#123;    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top, *last = NULL;    cur = root;    while (cur != NULL || !s.empty())    &#123;        while (cur != NULL)        &#123;            s.push(cur);            cur = cur-&gt;left;        &#125;        top = s.top();        if (top-&gt;right == NULL || top-&gt;right == last)&#123;            s.pop();            printf(&quot;%c &quot;, top-&gt;data);            last = top;        &#125;        else &#123;            cur = top-&gt;right;        &#125;    &#125;&#125;</code></pre><p>还是沿着左子树一路往下走，将路过的节点都压栈，直到走到空节点。</p><p>然后从栈中看一下栈顶元素（只看一眼，用top指针记下，先不出栈），如果top节点没有右子树，或者last等于top的右孩子，说明top的右子树不存在或者遍历过了，就输出top节点的值，并将栈顶元素pop掉（出栈），反之则是从左子树回到根节点的，接下来要去右子树。</p><p>如图，top的右孩子为空，说明右子树不存在，就可以输出top的值并pop掉栈顶了，这时候用last指针记下top指向的节点，代表上一次处理的节点。（这一过程cur始终没有动，一直指向空）</p><p>继续从栈顶看一个元素记为top，然后发现top的右孩子不为空，而且last也不等于top-&gt;right，就使cur = top-&gt;right，回到第一步，用同样的方法来处理top的右子树，下一次回来的时候，last指针指向的是E节点。</p><p>这时候发现top的右孩子不为空，但是last等于top-&gt;right，说明top的右子树遍历完成，下一步就要输出top的值并且将这个节点出栈，下一次再从栈中看一个栈顶元素A即为top。</p><p>这时候再比较，发现top的right不为空，而且last也不等于top-&gt;right，说明top有右子树并且还没有遍历过，就让cur = top-&gt;right，回到第一步用同样的方法来遍历A的右子树。<br>到最后，cur访问到了G的左孩子，而top也一路出栈到了A节点，发现cur为空，并且栈中也为空，这时候便代表整个树已经遍历完成，结束循环。</p><p>最后输出的中序访问序列为:DEBFGCA</p><p>层序遍历<br>层序遍历是比较接近人的思维方式的一种遍历方法，将二叉树的每一层分别遍历，直到最后的叶子节点被全部遍历完，这里要用到的辅助数据结构是队列，队列具有先进先出的性质。</p><p>上代码：</p><pre><code>void LevelOrder(TreeNode *root)&#123;    std::queue&lt;TreeNode *&gt; q;    TreeNode *front;    if (root == NULL)return;    q.push(root);    while (!q.empty())    &#123;        front = q.front();        q.pop();        if (front-&gt;left)            q.push(front-&gt;left);        if (front-&gt;right)            q.push(front-&gt;right);        printf(&quot;%c &quot;, front-&gt;data);    &#125;&#125;</code></pre><p>层序遍历的思路是，创建一个队列，先将根节点（A）入队，然后用front指针将根节点记下来，再将根节点出队，接下来看front节点（也就是刚才的根节点）有没有左孩子或右孩子，如果有，先左（B）后右（C）入队，最后输出front节点的值，只要队列还不为空，就说明还没有遍历完，就进行下一次循环，这时的队头元素（front）则为刚才入队的左孩子（B），然后front出队，再把它的左右孩子拉进来（如果有），因为队列的先进先出性质，B的左右孩子DE是排在C后面的，然后输出B，下一次循环将会拉人C的左右孩子FG，最后因为FG没有左右孩子，一直出队，没有入队元素，队列迟早会变为空，当队列为空时，整颗树就层序遍历完成了，结束循环。</p><p>根节点入队，并用front指针标记</p><p>队头出队，并将左右孩子拉进队列</p><p>重复1，2</p><p>直到队列为空</p><p>这时候便代表整个树遍历完成，结束循环。<br>最后输出的层序访问序列为:ABCDEF</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MinGw如何调试？</title>
    <link href="/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>MinGw调试方法</p><a id="more"></a><h1 id="MinGW调试命令"><a href="#MinGW调试命令" class="headerlink" title="MinGW调试命令"></a>MinGW调试命令</h1><p>&emsp;&emsp;MinGW（Minimalist GNU for Windows）提供了一套简单方便的Windows下的基于GCC程序开发环境。MinGW收集了一系列免费的Windows是用的头文件和库文件；同时整合了GNU的工具集，特别是GNU程序开发工具，如经典的gcc，g++，make等。MinGW是完全免费的自由软件，它在Windows平台下模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好的基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。简单的说，它是个精简的C/C++编译器，它实际上是将经典的开源C语言/C++编译器GCC/G++移植到了Windows下，并且包含了Win32API，因此可以将源代码编译生成Windows下的可执行程序。虽然VC6等编译器，只要点击鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑，而MinGW则只会生成一个可执行文件</p><hr><h2 id="gdb调试测试代码-test-c-："><a href="#gdb调试测试代码-test-c-：" class="headerlink" title="gdb调试测试代码(test.c)："></a>gdb调试测试代码(test.c)：</h2><pre><code>#include &lt;stdio.h&gt;void swap(int *a,int *b)&#123;    int temp = *a;    *a = *b;    *b = temp;&#125;int main(void)&#123;    int a=1,b=2;    swap(&amp;a,&amp;b);    printf(&quot;a = %d ,b = %d\n&quot;,a,b);    return 0;&#125;</code></pre><h3 id="要支持调试，在编译时要加入-g选项，编译命令："><a href="#要支持调试，在编译时要加入-g选项，编译命令：" class="headerlink" title="要支持调试，在编译时要加入-g选项，编译命令："></a>要支持调试，在编译时要加入-g选项，编译命令：</h3><pre><code>gcc text.c -g text.exe</code></pre><h3 id="出现调试命令："><a href="#出现调试命令：" class="headerlink" title="出现调试命令："></a>出现调试命令：</h3><pre><code>GNU gdb (GDB) 7.6.1Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;mingw32&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from D:\mypro\C\test.exe...done.(gdb)</code></pre><h3 id="gdb调试命令表："><a href="#gdb调试命令表：" class="headerlink" title="gdb调试命令表："></a>gdb调试命令表：</h3><div class="table-container"><table><thead><tr><th>命令</th><th style="text-align:center">解释</th><th style="text-align:right">简写</th></tr></thead><tbody><tr><td>file</td><td style="text-align:center">加载一个可执行文件，也可以在运行gdb的时候加载，两种方法都不会运行程序</td><td style="text-align:right">无</td></tr><tr><td>list</td><td style="text-align:center">列出可执行源码的一部分，通常在程序开始运行前执行，用来设置断点</td><td style="text-align:right">l</td></tr><tr><td>next</td><td style="text-align:center">单步调试，不进入函数</td><td style="text-align:right">n</td></tr><tr><td>step</td><td style="text-align:center">单步调试，进入函数</td><td style="text-align:right">s</td></tr><tr><td>run</td><td style="text-align:center">运行加载了的程序</td><td style="text-align:right">r</td></tr><tr><td>continue</td><td style="text-align:center">继续执行程序</td><td style="text-align:right">c</td></tr><tr><td>quit</td><td style="text-align:center">退出调试</td><td style="text-align:right">q</td></tr><tr><td>print</td><td style="text-align:center">输出制定的变量的值，变量要在程序运行处可见</td><td style="text-align:right">p</td></tr><tr><td>break</td><td style="text-align:center">设置断点</td><td style="text-align:right">b</td></tr><tr><td>info break</td><td style="text-align:center">查看断点的信息</td><td style="text-align:right">i b</td></tr><tr><td>delete</td><td style="text-align:center">删除断点</td><td style="text-align:right">d</td></tr><tr><td>watch</td><td style="text-align:center">监视一个变量的值，一旦值发生变化，程序将会被暂停执行</td><td style="text-align:right">wa</td></tr><tr><td>help</td><td style="text-align:center">查看gdb的帮助信息</td><td style="text-align:right">h</td></tr></tbody></table></div><h3 id="1-l命令，列出部分代码："><a href="#1-l命令，列出部分代码：" class="headerlink" title="1.l命令，列出部分代码："></a>1.l命令，列出部分代码：</h3><p>在(gdb)后面输入l可以显示一部分代码再输入一次l可以显示全部代码</p><pre><code>(gdb) l2   3   void swap(int *a,int *b)&#123;4       int temp = *a;5       *a = *b;6       *b = temp;7   &#125;8   9   int main(void)10  &#123;11      int a=1,b=2;(gdb)(gdb) l12      swap(&amp;a,&amp;b);13      printf(&quot;a = %d ,b = %d\n&quot;,a,b);14      return 0;15  &#125;(gdb) l(gdb) Line number 16 out of range; test.c has 15 lines</code></pre><h3 id="2-start命令，开始运行，会停到main入口处："><a href="#2-start命令，开始运行，会停到main入口处：" class="headerlink" title="2.start命令，开始运行，会停到main入口处："></a>2.start命令，开始运行，会停到main入口处：</h3><pre><code>(gdb) startTemporary breakpoint 1 at 0x401491: file test.c, line 11.Starting program: D:\mypro\C/test.exe [New Thread 8000.0x18c4][New Thread 8000.0x2418]Temporary breakpoint 1, main () at test.c:1111      int a=1,b=2</code></pre><h3 id="4-n命令：单步调试，不进入函数，跳到第12行"><a href="#4-n命令：单步调试，不进入函数，跳到第12行" class="headerlink" title="4.n命令：单步调试，不进入函数，跳到第12行:"></a>4.n命令：单步调试，不进入函数，跳到第12行:</h3><pre><code>(gdb) n12      swap(&amp;a,&amp;b);</code></pre><h3 id="5-s命令：单步调试，进入函数，跳到第4行"><a href="#5-s命令：单步调试，进入函数，跳到第4行" class="headerlink" title="5.s命令：单步调试，进入函数，跳到第4行:"></a>5.s命令：单步调试，进入函数，跳到第4行:</h3><pre><code>gdb) sswap (a=0x61ff2c, b=0x61ff28) at test.c:44       int temp = *a;</code></pre><h3 id="6-b命令设置断点（b-第n行代码的行数）："><a href="#6-b命令设置断点（b-第n行代码的行数）：" class="headerlink" title="6.b命令设置断点（b + 第n行代码的行数）："></a>6.b命令设置断点（b + 第n行代码的行数）：</h3><pre><code>(gdb) b 6Breakpoint 2 at 0x401478: file test.c, line 6.</code></pre><h3 id="7-r命令-运行程序，直到下一个断点就停："><a href="#7-r命令-运行程序，直到下一个断点就停：" class="headerlink" title="7.r命令,运行程序，直到下一个断点就停："></a>7.r命令,运行程序，直到下一个断点就停：</h3><pre><code>The program being debugged has been started already.Start it from the beginning? (y or n)...Breakpoint 2, swap (a=0x61ff2c, b=0x61ff28) at test.c:66       *b = temp;</code></pre><h3 id="7-p命令-输出制定的变量的值，变量要在程序运行处可见"><a href="#7-p命令-输出制定的变量的值，变量要在程序运行处可见" class="headerlink" title="7.p命令,输出制定的变量的值，变量要在程序运行处可见:"></a>7.p命令,输出制定的变量的值，变量要在程序运行处可见:</h3><pre><code>(gdb) p *a$1 = 2(gdb) p *b$2 = 2(gdb) p a$3 = (int *) 0x61ff2c(gdb) p b$4 = (int *) 0x61ff28</code></pre><p>next一下，再看b的值：</p><pre><code>(gdb) n7   &#125;(gdb) p *b$5 = 1</code></pre><h3 id="8-i-b命令-查看断点信息"><a href="#8-i-b命令-查看断点信息" class="headerlink" title="8.i b命令,查看断点信息:"></a>8.i b命令,查看断点信息:</h3><pre><code>(gdb) i bNum     Type           Disp Enb Address    What2       breakpoint     keep y   0x00401478 in swap at test.c:6    breakpoint already hit 1 time</code></pre><h3 id="9-d命令-删除断点，不加断点位置即删除所有断点"><a href="#9-d命令-删除断点，不加断点位置即删除所有断点" class="headerlink" title="9.d命令,删除断点，不加断点位置即删除所有断点:"></a>9.d命令,删除断点，不加断点位置即删除所有断点:</h3><pre><code>(gdb) d Delete all breakpoints? (y or n) [answered Y; input not from terminal](gdb) i bNo breakpoints or watchpoints.</code></pre><h3 id="10-没有断点后，再试一下r命令，可以看到，执行完了程序："><a href="#10-没有断点后，再试一下r命令，可以看到，执行完了程序：" class="headerlink" title="10.没有断点后，再试一下r命令，可以看到，执行完了程序："></a>10.没有断点后，再试一下r命令，可以看到，执行完了程序：</h3><pre><code>(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) [answered Y; input not from terminal]error return ../../gdb-7.6.1/gdb/windows-nat.c:1275 was 5Starting program: D:\mypro\C/test.exe [New Thread 1976.0x1460][New Thread 1976.0x5e0]a = 2 ,b = 1[Inferior 1 (process 1976) exited normally</code></pre><h3 id="11-q命令，退出gdb："><a href="#11-q命令，退出gdb：" class="headerlink" title="11.q命令，退出gdb："></a>11.q命令，退出gdb：</h3><pre><code>(gdb) q</code></pre>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>remove_list_entry</title>
    <link href="/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/"/>
    <url>/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学习如何写有品味的代码</p><a id="more"></a><h1 id="remove-list-entry（无需-if-逻辑）"><a href="#remove-list-entry（无需-if-逻辑）" class="headerlink" title="remove_list_entry（无需 if 逻辑）"></a>remove_list_entry（无需 if 逻辑）</h1><p>&emsp;&emsp;这是期TED里面的内容，内容是采访linux的之父Linus Torvalds。<br>&emsp;&emsp;Linus Torvalds两次改变了技术，第一次是Linux内核，它帮助互联网的发展，第二次是Git，全球开发者使用的源代码管理系统。在一次TED的采访中，Torvalds以极其开放的态度讨论了他独特的工作方式和性格特点。Torvalds说：“我不是一个空想家，我是一名工程师，我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹，看着满天星辰说，“我想到那儿去。”但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去，这就是我。”***</p><p>&emsp;&emsp;在聊天中CA问道了一个关于代码品味的的问题，这个问题其实很有意思，对于很多写代码的人来说，有好的代码风格和代码品味就好比有了一种审美品味一样。就好比在写代码时你的缩进习惯一样。</p><blockquote><p>第一段代码</p></blockquote><pre><code class="hljs xl">remove_list_entry(entry)&#123;    prev = NULL;    walk = head;​    <span class="hljs-comment">// Walk the list</span>​    <span class="hljs-keyword">while</span> (walk != entry)    &#123;        prev = walk;        <span class="hljs-function"><span class="hljs-title">walk</span> = walk-&gt;</span>next;    &#125;        <span class="hljs-comment">// Remove the entry by updating the </span>    <span class="hljs-comment">// head or the previous entry</span>    <span class="hljs-keyword">if</span>(!prev)    &#123;        <span class="hljs-function"><span class="hljs-title">head</span> = entry-&gt;</span>next;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-function"><span class="hljs-title">prev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = entry-&gt;</span>next;    &#125; &#125;</code></pre><blockquote><p>第二段代码</p></blockquote><pre><code class="hljs swift">remove_list_entry(entry)&#123;    <span class="hljs-comment">// The &quot;indirect&quot; pointer points to the</span>    <span class="hljs-comment">// *address* of the thing we&#x27;ll update</span>    <span class="hljs-keyword">indirect</span> = &amp;head;​    <span class="hljs-comment">// Walk the list, looking for the thing that</span>    <span class="hljs-comment">// points to the entry we want to remove </span>    <span class="hljs-keyword">while</span> ((*<span class="hljs-keyword">indirect</span>) != entry))    &#123;        <span class="hljs-keyword">indirect</span> = &amp;(*<span class="hljs-keyword">indirect</span>)-&gt;next;    &#125;​    <span class="hljs-comment">// .. and just remove it</span>    *<span class="hljs-keyword">indirect</span> = entry-&gt;next;&#125;</code></pre><font color="red" size="2px">这里我注释一下哈，这两段代码都是伪码。所以看起来有点奇怪</font><p>&emsp;&emsp;看起来这两段代码功能上都一样的但是，第一段的最后用了一个if和一个else目的在于处理特殊情况，但是第二段代码很简洁没有if和else来处理特殊情况，这是一种很有意思且巧妙的思想同样<b>Dummy Node链表</b>也是一种处理方式，在这里不讨论，后面我回专门来说这种链表。</p><pre><code class="hljs awk">Node *head, *prev, *walk;void remove_list_entry(Node* entry)&#123;    prev = NULL;    <span class="hljs-regexp">//</span> walk 这一变量名，十分巧妙，    <span class="hljs-regexp">//</span> 变量命名的不二法门就是对应其物理（实际）意义    walk = head;    <span class="hljs-keyword">while</span> (walk != entry)    &#123;        prev = walk;        walk = walk-&gt;<span class="hljs-keyword">next</span>;    &#125;    <span class="hljs-regexp">//</span> 也即没有执行 <span class="hljs-keyword">while</span> 循环，walk == entry，entry == head    <span class="hljs-keyword">if</span> (!prev)        head = entry-&gt;<span class="hljs-keyword">next</span>;    <span class="hljs-keyword">else</span>        prev-&gt;<span class="hljs-keyword">next</span> = entry-&gt;<span class="hljs-keyword">next</span>;&#125;</code></pre><pre><code class="hljs crmsh">void remove_list_entry(<span class="hljs-keyword">Node</span><span class="hljs-title">* entry</span>)&#123;    <span class="hljs-keyword">Node</span> <span class="hljs-title">**indirect</span>;    indirect = &amp;head;    while ((*indirect) != entry)        indirect = &amp;(*indirect)-&gt;next;    *indirect = entry-&gt;next;&#125;</code></pre><font color="#24495e" size="2"><p>&emsp;&emsp;这是两段代码的表准形式</p></font><p>&emsp;&emsp;为什么要区分是头指针呢，因为整个程序的逻辑是找到被删除指针的前一个指针，如果被删除的指针为头指针，显然其没有前一个指针。显然这种的代码不具很好的 taste，话说 Jobs 也很爱讲 taste（Windows 最大的特点就是 has no taste）。<b>这两段代码的显著区别就是第二段代码省略了 if 语句，</b>对头指针和前一个指针做了统一化处理。头指针没有前一个指针，但有自己的地址，自己的地址自然还是指向自己。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/06/hello-world/"/>
    <url>/2019/12/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>first txt<br><a id="more"></a></p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
