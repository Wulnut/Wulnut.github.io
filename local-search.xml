<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快读</title>
    <link href="/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/"/>
    <url>/2020/05/12/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>快读的一些方法</p><a id="more"></a><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在做数据结构、算法题的时候会遇见比较大的数，有的时候数据大小已经超过了int所能储存的范围，这样的大数如果比较多情况下如果使用普通的输入或者输出，超时就可能会发生，如果出现这样的错误，在算法时间复杂度没有问题的前提下出现这样的问题是非常令人头疼的一件事情。</p><p>这里我将从Java和C++两中语言入手，在减少这样的问题出现</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>一、StreamTokenizer实现快速输入</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;</code></pre><p>定义如下：</p><pre><code class="hljs java">StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));</code></pre><p>StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：!@#$%^&amp;*()[]{})无法识别，会显示null</p><p>StreamTokenizer可以<strong>获取输入</strong>流并根据空格和回车分割成Token（标记），用nextToken方法读取下一个标记 </p><p>如果标记是字符串，用st.sval获取标记，如果是数字用st.nval获取标记，st.navl是double类型</p><p>示例</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.io.StreamTokenizer;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        StreamTokenizer st =<span class="hljs-keyword">new</span> StreamTokenizer(<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in)));        st.nextToken();        String s=st.sval;        System.out.println(s);        st.nextToken();        <span class="hljs-keyword">double</span> n=st.nval;        System.out.println(n);        <span class="hljs-comment">/**输入内容         * hollow 1233         * 输出内容         * hollow         * 1233.0         */</span>            &#125; &#125;</code></pre><p>二、BufferedReader实现快速输入读一行</p><p>需要导入的jar</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;</code></pre><p>定义：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</code></pre><p>常用方法：</p><pre><code class="hljs java">inBuff.readLine()<span class="hljs-comment">//读取一行内容，返回字符串</span></code></pre><p>实例：</p><pre><code class="hljs java">BufferedReader inBuff=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        String s=inBuff.readLine();        System.out.println(<span class="hljs-string">"有问题吗"</span>+s+<span class="hljs-string">"没有吧"</span>);        <span class="hljs-comment">/**         * 输出内容         * hollow world!         * 有问题吗hollow world!没有吧         */</span></code></pre><p>三、PrintWriter实现快速输出</p><p>需要的jar包</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;</code></pre><p>定义如下：</p><pre><code class="hljs java">PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));</code></pre><p>常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 输出分为两步：</span><span class="hljs-comment">// 1、先通过print()或println()方法把需要输出的内容放入缓冲区，</span><span class="hljs-comment">// 2、然后通过flush()将缓冲区的内容输出到控制台</span>print(需要输出的内容)<span class="hljs-comment">//不换行输出，只是把需要的内容放入缓冲，</span>println(需要输出的内容)<span class="hljs-comment">//换行输出</span>flush()<span class="hljs-comment">//刷新缓冲区，把缓冲区的内容输出到控制台，</span></code></pre><p>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> CCPC;<span class="hljs-keyword">import</span> java.io.OutputStreamWriter;<span class="hljs-keyword">import</span> java.io.PrintWriter;<span class="hljs-comment">//import java.io.*;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));        String s=<span class="hljs-string">"hollow world"</span>;        <span class="hljs-keyword">int</span> i=<span class="hljs-number">12344</span>;        out.print(s+<span class="hljs-string">" "</span>+i);        out.flush();        <span class="hljs-comment">/**         * 输出内容         * hollow world 12344         */</span>    &#125;&#125;</code></pre><p>一个例子<br><strong>一般建议使用BufferedRead()</strong><br><pre><code class="hljs java"><span class="hljs-comment">// https://www.acwing.com/problem/content/790/</span><span class="hljs-comment">// 使用BufferedReader读入的方法</span><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex4</span> </span>&#123;    <span class="hljs-comment">// 全局变量</span><span class="hljs-comment">//    static int N = 100010;  // 数据规模为 10w</span><span class="hljs-comment">//    static int[] arr = new int[N];</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-comment">// parseInt将字符串转为int</span>        <span class="hljs-comment">// parseDouble将字符转为double</span>        <span class="hljs-keyword">int</span> n = Integer.parseInt(reader.readLine());        String[] arrStr = reader.readLine().split(<span class="hljs-string">" "</span>);        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;            arr[i] = Integer.parseInt(arrStr[i]);        &#125;        reader.close();        <span class="hljs-keyword">long</span> ans = mergesort(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        System.out.println(ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> res = mergesort(arr, l, mid) + mergesort(arr,mid + <span class="hljs-number">1</span>, r);        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r - l + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) temp[k ++] = arr[i ++];            <span class="hljs-keyword">else</span> &#123;                res += mid - i + <span class="hljs-number">1</span>;                temp[k ++] = arr[j ++];            &#125;        &#125;        <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = arr[i ++];        <span class="hljs-keyword">while</span> (j &lt;=   r) temp[k ++] = arr[j ++];        <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) &#123;            arr[i] = temp[j];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="getchar读入"><a href="#getchar读入" class="headerlink" title="getchar读入"></a>getchar读入</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> , ch = getchar();    <span class="hljs-keyword">while</span>( !<span class="hljs-built_in">isdigit</span>( ch ) ) ch = getchar();    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">isdigit</span>( ch ) ) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">'0'</span> , ch = getchar();    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p>用时28.74s</p><h3 id="fread读入优化"><a href="#fread读入优化" class="headerlink" title="fread读入优化"></a>fread读入优化</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io</span>&#123;</span>    <span class="hljs-keyword">char</span> ibuf[<span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span>] , * s;    io()    &#123;        fread( s = ibuf , <span class="hljs-number">1</span> , <span class="hljs-number">900</span> &lt;&lt; <span class="hljs-number">20</span> , <span class="hljs-built_in">stdin</span> );    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>( * s &lt; <span class="hljs-number">48</span> ) s++;        <span class="hljs-keyword">while</span>( * s &gt; <span class="hljs-number">32</span> )            u = u * <span class="hljs-number">10</span> + * s++ - <span class="hljs-number">48</span>;        <span class="hljs-keyword">return</span> u;    &#125;&#125; ip;</code></pre><p>用时1.535s</p><h3 id="当然如果觉得以上的方法比较麻烦可以："><a href="#当然如果觉得以上的方法比较麻烦可以：" class="headerlink" title="当然如果觉得以上的方法比较麻烦可以："></a>当然如果觉得以上的方法比较麻烦可以：</h3><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::ios::sync_with_stdio(<span class="hljs-literal">false</span>);</code></pre><p>通过对cin和cout的解除绑定可以达到和scanf于printf一样的速度有时候会更快</p><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><p><strong>cout</strong></p><p>用时102.2s</p><p><strong>printf</strong></p><p>用时27.36s</p><p><strong>puts（直接当字符串输出）</strong></p><p>用时2.001s</p><h3 id="putchar输出优化"><a href="#putchar输出优化" class="headerlink" title="putchar输出优化"></a>putchar输出优化</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);        x=-x;    &#125;    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">9</span>)        <span class="hljs-built_in">print</span>(x/<span class="hljs-number">10</span>);    <span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>);&#125;</code></pre><p>用时3.339s</p><h3 id="fwrite输出优化"><a href="#fwrite输出优化" class="headerlink" title="fwrite输出优化"></a>fwrite输出优化</h3><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;    <span class="hljs-title">inline</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span>( <span class="hljs-title">register</span> <span class="hljs-title">T</span> <span class="hljs-title">u</span> )    &#123;</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> * q = a;        <span class="hljs-keyword">if</span>( !u ) * t++ = <span class="hljs-number">48</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>( u &lt; <span class="hljs-number">0</span> )                * t++ = <span class="hljs-number">45</span> , u *= <span class="hljs-number">-1</span>;            <span class="hljs-keyword">while</span>( u ) * q++ = u % <span class="hljs-number">10</span> + <span class="hljs-number">48</span> , u /= <span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>( q != a )                * t++ = * --q;        &#125;    &#125;</code></pre><p>用时0.6653s</p><p><strong>由此可以看出，fwrite对比其他读入方式有极大的差距</strong></p><p>不过由于一般输出量都比较小，所以输出优化意义不大</p><h2 id="inline-define-register"><a href="#inline-define-register" class="headerlink" title="inline,define,register"></a>inline,define,register</h2><p>register就是把东西放到寄存器里面</p><p>比如for( int i = 1 ; i &lt;= n ; i++ )</p><p>可以写成for( register int i = 1 ; i &lt;= n ; i++ )</p><p>但是这个不一定有用，因为这个int可能编译器会帮你放寄存器里面</p><p><strong>for register short可能比for register int慢，因为short的寄存器更少..</strong><br><strong>大家for循环里面还是int比较好</strong></p><p>register在大部分情况下（特别是开了O2的时候）并没有明显的优化效果，如果加错了反而可能负优化</p><p>如果一个简单函数调用次数很多，属于瓶颈，调用时的传参可能会大大影响程序效率</p><p>这种情况下可以把这个函数给inline掉</p><p>inline就是把一个函数内联，可以减少跳转和传参的代价</p><p>但是如果这个函数过于复杂，可能并不会inline，可以考虑<strong>attribute</strong> ( ( always_inline ) )或者手动展开，或者define掉（注意define别爆炸）</p><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/qq_40079933/article/details/79419065" target="_blank" rel="noopener">https://blog.csdn.net/qq_40079933/article/details/79419065</a></li><li><a href="https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/user3296/oi-zhong-jian-dan-di-chang-shuo-you-hua</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Text Format</title>
    <link href="/2020/05/05/scenes1/"/>
    <url>/2020/05/05/scenes1/</url>
    
    <content type="html"><![CDATA[<p>manim 入门</p><a id="more"></a><h1 id="Text-format"><a href="#Text-format" class="headerlink" title="Text format"></a>Text format</h1><pre><code class="hljs 注意```:">&#96;&#96;&#96;python3from big_ol_pile_of_manim_imports import *</code></pre><p>在第一行</p><h2 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h2><pre><code class="hljs python3">class WriteText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/WriteText.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class AddText(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;This is a regular text&quot;)        self.add(text)        self.wait(3)</code></pre><p><img src="/img/AddText.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class Formula(Scene):     def construct(self):         formula &#x3D; TexMobject(&quot;This is a formula&quot;)        self.play(Write(formula))        self.wait(3)</code></pre><p><img src="/img/Formula.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $this is a formula$,            $$this is a formula$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TypesOfText2(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/TipesOfText2.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class DisplayFormula(Scene):     def construct(self):         typesOfText &#x3D; TextMobject(&quot;&quot;&quot;            This is a regular text,            $\\displaystyle\\frac&#123;x&#125;&#123;y&#125;$,            $$x^2+y^2&#x3D;a^2$$            &quot;&quot;&quot;)        self.play(Write(typesOfText))        self.wait(3)</code></pre><p><img src="/img/DisplayFormula.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextInCenter(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInCenter.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextOnTopEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnTopEdge.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextOnBottomEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnBottomEdge.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextOnRightEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnRightEdge.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextOnLeftEdge(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(LEFT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextOnLeftEdge.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextInUpperRightCorner(Scene):    def construct(self):        text &#x3D; TextMobject(&quot;Text&quot;)        text.to_edge(UP+RIGHT)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInUpperRightCorner.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextInLowerLeftCorner(Scene):     def construct(self):         text &#x3D; TextMobject(&quot;Text&quot;)         text.to_edge(LEFT+DOWN)        self.play(Write(text))        self.wait(3)</code></pre><p><img src="/img/TextInLowerLeftCorner.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(0.25*UP)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/CustomPosition1.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class CustomPosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Central text&quot;)        textM.move_to(1*UP+1*RIGHT)        self.play(Write(textM),Write(textC))        self.wait(1)        textM.move_to(1*UP+1*RIGHT)         self.play(Write(textM))        self.wait(3)</code></pre><p><img src="/img/CustomPosition2.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition1(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.next_to(textC,LEFT,buff&#x3D;1)         self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition1.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class RelativePosition2(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP*0.1)        self.play(Write(textM),Write(textC))        self.wait(3)</code></pre><p><img src="/img/RelativePosition2.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class RotateObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textC &#x3D; TextMobject(&quot;Reference text&quot;)        textM.shift(UP)        textM.rotate(PI&#x2F;4) # &lt;- Radians        # You can use .rotate(45*DEGREES) too        self.play(Write(textM),Write(textC))        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI&#x2F;4)        self.wait(2)        textM.rotate(PI)        self.wait(2)</code></pre><p><img src="/img/RotateObject.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class FlipObject(Scene):    def construct(self):        textM &#x3D; TextMobject(&quot;Text&quot;)        textM.flip(UP)        self.play(Write(textM))        self.wait(2)</code></pre><p><img src="/img/MirrorObject.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class SizeTextOnLaTeX(Scene):    def construct(self):        textHuge &#x3D; TextMobject(&quot;&#123;\\Huge Huge Text 012.\\#!?&#125; Text&quot;)        texthuge &#x3D; TextMobject(&quot;&#123;\\huge huge Text 012.\\#!?&#125; Text&quot;)        textLARGE &#x3D; TextMobject(&quot;&#123;\\LARGE LARGE Text 012.\\#!?&#125; Text&quot;)        textLarge &#x3D; TextMobject(&quot;&#123;\\Large Large Text 012.\\#!?&#125; Text&quot;)        textlarge &#x3D; TextMobject(&quot;&#123;\\large large Text 012.\\#!?&#125; Text&quot;)        textNormal &#x3D; TextMobject(&quot;&#123;\\normalsize normal Text 012.\\#!?&#125; Text&quot;)        textsmall &#x3D; TextMobject(&quot;&#123;\\small small Text 012.\\#!?&#125; Texto normal&quot;)        textfootnotesize &#x3D; TextMobject(&quot;&#123;\\footnotesize footnotesize Text 012.\\#!?&#125; Text&quot;)        textscriptsize &#x3D; TextMobject(&quot;&#123;\\scriptsize scriptsize Text 012.\\#!?&#125; Text&quot;)        texttiny &#x3D; TextMobject(&quot;&#123;\\tiny tiny Texto 012.\\#!?&#125; Text normal&quot;)        textHuge.to_edge(UP)        texthuge.next_to(textHuge,DOWN,buff&#x3D;0.1)        textLARGE.next_to(texthuge,DOWN,buff&#x3D;0.1)        textLarge.next_to(textLARGE,DOWN,buff&#x3D;0.1)        textlarge.next_to(textLarge,DOWN,buff&#x3D;0.1)        textNormal.next_to(textlarge,DOWN,buff&#x3D;0.1)        textsmall.next_to(textNormal,DOWN,buff&#x3D;0.1)        textfootnotesize.next_to(textsmall,DOWN,buff&#x3D;0.1)        textscriptsize.next_to(textfootnotesize,DOWN,buff&#x3D;0.1)        texttiny.next_to(textscriptsize,DOWN,buff&#x3D;0.1)        self.add(textHuge,texthuge,textLARGE,textLarge,textlarge,textNormal,textsmall,textfootnotesize,textscriptsize,texttiny)        self.wait(3)</code></pre><p><img src="/img/SizeTextOnLaTeX.gif" srcset="/img/loading.gif" alt=" "></p><pre><code class="hljs python3">class TextFonts(Scene):    def construct(self):        textNormal &#x3D; TextMobject(&quot;\\textrm&#123;Roman serif text 012.\\#!?&#125; Text&quot;)        textItalic &#x3D; TextMobject(&quot;\\textit&#123;Italic text 012.\\#!?&#125; Text&quot;)        textTypewriter &#x3D; TextMobject(&quot;\\texttt&#123;Typewritter text 012.\\#!?&#125; Text&quot;)        textBold &#x3D; TextMobject(&quot;\\textbf&#123;Bold text 012.\\#!?&#125; Text&quot;)        textSL &#x3D; TextMobject(&quot;\\textsl&#123;Slanted text 012.\\#!?&#125; Text&quot;)        textSC &#x3D; TextMobject(&quot;\\textsc&#123;Small caps text 012.\\#!?&#125; Text&quot;)        textNormal.to_edge(UP)        textItalic.next_to(textNormal,DOWN,buff&#x3D;.5)        textTypewriter.next_to(textItalic,DOWN,buff&#x3D;.5)        textBold.next_to(textTypewriter,DOWN,buff&#x3D;.5)        textSL.next_to(textBold,DOWN,buff&#x3D;.5)        textSC.next_to(textSL,DOWN,buff&#x3D;.5)        self.add(textNormal,textItalic,textTypewriter,textBold,textSL,textSC)        self.wait(3)</code></pre><p><img src="/img/TextFonts.gif" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一期半月谈</title>
    <link href="/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/"/>
    <url>/2020/05/02/%E5%8D%8A%E6%9C%88%E8%B0%881/</url>
    
    <content type="html"><![CDATA[<p>这是是我对现在的简单思考</p><a id="more"></a><p>&emsp;&emsp;现在是5月1号，距离上次更新博客已经很久了。因为在家上课，所以时间非常自由。因为想参加一下蓝桥杯，来看看自己的专业水平到底怎么样。所以就慢慢开始准备学习算法起来了。</p><h2 id="蓝桥"><a href="#蓝桥" class="headerlink" title="蓝桥"></a>蓝桥</h2><p>&emsp;&emsp;在学习算法的过程种，我慢慢的对我自己的真实能有了比较全面的了解。从简单的基本算法开始到数据结构到图论</p><script type="math/tex; mode=display">基本算法\rightarrow 数据结构 \rightarrow 图论 \rightarrow \dots</script><p>说实话没得一步是简单的，是真的举步维艰。基本算法中的枚举、模拟、递归、分治$\dots$ 我感觉我到现在都没有真正学会其中的思想，每天坚持通过训练的方式来提高自己的对一些算法的理解，但是半天下来可能也就做了一两个题目，有时候思路开阔可能也就三四个，但是大部分时间也就是一两个的样子。可能是在家的原因，调板子没啥效率。但是这种挫败感是太真实了，随着渐渐对这种方向的深入了解。也就慢慢的明白自己知道东西实在是太少了，不断的从一些教学视频里面慢慢的学习前人总结出的经验。</p><p>但是这确实很可笑，你感觉你学会了一种算法，但是题目给你变一变，你就立马懵逼了。如果说做算法题可以类比成你高中的数学题的话，可能就是你题型见的不够多，总结的很少导致的。但这也是困难所在，虽然算法就那么多你这么能正真理解一个题目到底想怎么考你去使用这个算法是十分困难的。就拿前缀和为例</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> arr[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i], arr[i] += arr[i - <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>前缀和就是那样很简单，就是一个arr[i] = arr[i - 1] + arr[i];的一个公式，在仔细看看其实是就是前$N$项求和，但是它有什么用？怎么用？可以干啥一般都是怎么处理的。</p><p>完完全全就需要你自己去总结思考，但是可能这种小技巧也只会出现在你解决某个题目中的一个小步骤中，但是有些人总是能把这种小技巧玩的出神入化，来降低时间复杂度。这就要看各位对这种技巧的理解了，没人能帮助你。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在知乎上经常能看到有人发这样的问题，“大神都是如何刷leetcode的”。我才这样的问这样问题的人都是一些为了找工作而去刷题的人。因为正真的大佬早已经在ACM类比赛中把算法这东西玩的炉火纯青了，你可能还在第一层，人家已经到了第五层了。其中有个人的回答很是亮眼，他说：你把打好的青春都浪费在刷LeetCode上那你为什么不把那些时间去研究一下新技术，学习一下技术的底层实现呢？看到一个题目思考了10分钟还没思路那就去看题解理解这个题目，花费那么长时间浪费在这上面不那么值得。就像郭杰瑞那期视频一样老郭做了江苏高考英语试卷但是到最后结果和大家想的一样，错了很多，是他英语差吗不是，那是人家的母语那是什么是缺乏这方面的训练。也就是说为什么我们刚开始学算法的时候为什么会那么痛苦，没有接收相关的训练很难一开始就上手完成的很好，针对的训练是至关重要的。</p><p>但是我反观一下自己，把大把的时间花在学习这些东西上是否也是一种浪费？当然不是，那是我以后吃饭的东西花费时间在这上面怎么算是浪费呢？但是我觉得我缺走上了歧途，什么歧途？</p><p>C++:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello World"</span>;&#125;</code></pre><p>Java:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">public</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello World"</span>);    &#125;&#125;</code></pre><p>Python:</p><pre><code class="hljs python">print(<span class="hljs-string">"Hello World"</span>)</code></pre><p>JavaScript:</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hello World"</span>);</code></pre><p>我现在会四种语言来写出Hello World这个词，说明我了解了很多不同种类的编程语言但是，我确实不明白为什么我们要一开始去写一个Hello World。是因为他简单？其实并不是，学习编程每个人的目的是不同的，为什么现在社会上有那么多培训班，在短短是几个星期里面就能教出一个人去公司里面上班每个月拿着一两万的工资？因为现在很多东西被模式化了，</p><p>UADC(update, add, delete, create)这样的模式几乎符合任何情况，并不是人们想的通过编程来改变世界。如果说你被这种混口饭吃的想法所束缚，那你的发展也就那样的。那科班生和培训班的人也就没什么两样的了，科班生不只是有很多时间去打磨自己的能力，更多的是有时间去创造。这些语言归根到底是一种我们所特有的一种工具，而这种工具用来帮助我们把现实生活中的一些常见问题给抽象出来我们通过算法来反复重复的解决这种问题来方便我们。这才是我们的学习的正真目的，为什么说各个行业都需要会写程序的人，但是这些领域有时候又和计算机专业完全不沾边。但是就有人能去创造它方便行业快速发展，而这就是创造力。而不是仅仅的为了那一两行算法代码。这也是为什么说我<strong>没趣、死板、不懂审美</strong>$\dots$ 的原因。</p><p>被这种看起来死板的东西所束缚了，不能走出这种圈子，去学习了解更多的东西来正真成就自己。</p><p>$未完\dots$</p>]]></content>
    
    
    <categories>
      
      <category>半月谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆，杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2020/04/01/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p>二叉树有多种遍历的方式我们简单总结一下</p><a id="more"></a><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>问题描述：</p><p>&emsp;&emsp;求$A^B$的最后三位数的整数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果我们直接通过循环的方法来解决我们会发现</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;            result = result * base;      &#125;        <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>如果给出$base = 2$ $power = 100$ 的时候我们就就会发现函数$f(x) = a^{b}$是一个指数函数后期的增长速度是非常快的所以我们需要对此进行优化。</p><h3 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h3><p>取模运算有以下 性质：</p><ol><li><p>$(a + b)\%c = ((a\%C) + (b\%c))\%c$</p></li><li><p>$(a<em>b)\%c = ((a\%c)</em>(b\%c))\%c$</p></li><li><p>$(a - b)\%c = ((a\%c)-(b\%c))\%c$</p><p>总成依据话就是，在取模运算的时候我们在中间过程每次都取模，在得出答案之后我们再取一次模。</p><p>我们通过性质性质2来优化我们的代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt;= power; ++ i) &#123;        result *= base;        result %= <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;&#125;</code></pre><p>通过这样的运算优化，我们发现这种取模运算中如果我们中间进行取模的话是可以防止出现溢出的情况的。</p></li></ol><h2 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h2><p>&emsp;&emsp;快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。从而达到快速计算的目的。</p><p>例如：</p><p>$3^{10} = 3\times3\times3\times3\times3\times3\times3\times3\times3\times3$</p><p>我们可以尽可能的将其指数降下来，来简化运算。</p><p>$3^{10} = (3\times3)\times(3\times3)\times(3\times3)\times(3\times3)\times(3\times3)$</p><p>$3^{10} = (3\times3)^5$</p><p>其实这种方法也在平常也是十分常见的，比如我们向计算$2^4$我们肯定不会一个一个的乘$2$我们一般都会去直接计算$4\times4$从而快速的计算出结果，其实两者的关系是一样的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = base;        whlie (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果指数为偶数</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//把指数缩小为一半</span>            base = base * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//底数变大成原来的平方</span>        &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">//如果指数为奇数</span>            power = power - <span class="hljs-number">1</span>;<span class="hljs-comment">//把指数减去1，使其变成一个偶数</span>            result = result * base % <span class="hljs-number">1000</span>;<span class="hljs-comment">//此时记得要把指数为奇数时分离出来的底数的一次方收集好</span>            power /= <span class="hljs-number">2</span>;<span class="hljs-comment">//此时指数为偶数，可以继续执行操作</span>            base = base * base % <span class="hljs-number">1000</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="最终优化"><a href="#最终优化" class="headerlink" title="最终优化"></a>最终优化</h2><p>&emsp;&emsp;我们知到判断奇偶性除了使用 $\%$看其余数是否为$0$ $or$ $1$来进行判断之外，我们还可以通过位运算来进行计算，例如：power&amp;1。因为如果power为偶数，则其二进制表示的最后一位一定是0；如果power是奇数，则其二进制表示的最后一位一定是1。将他们分别与1的二进制做“与”运算，得到的就是power二进制最后一位的数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1=1；而6是偶数，则6&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p>&emsp;&emsp;同样对于除以$2$的运算我们也可以使用位运算来进行优化power /= 2可以使用右移power = power &gt;&gt; 1实现，右移动1就是除以2，如果右移2就是除以4，同理左移就是乘，左移1就是乘以2左移2就是乘以4；</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> power)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//此处等价于if(power%2==1)</span>            result = result * base % <span class="hljs-number">1000</span>;        &#125;        power &gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">//此处等价于power=power/2</span>        base = (base * base) % <span class="hljs-number">1000</span>;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>求$m^k$ $\% $ $p$ 时间复杂度为$O(logk)$</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % p, t = m;        <span class="hljs-keyword">while</span> (k) &#123;                <span class="hljs-comment">//如果为奇数</span>        <span class="hljs-keyword">if</span> (k &amp;  <span class="hljs-number">1</span>) res = res * t % p;                t = t * t % p;        k &gt;&gt; <span class="hljs-number">1</span>;    &#125;        <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向BFS</title>
    <link href="/2020/03/28/%E5%8F%8C%E5%90%91BFS/"/>
    <url>/2020/03/28/%E5%8F%8C%E5%90%91BFS/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="搜索-双向BFS"><a href="#搜索-双向BFS" class="headerlink" title="搜索-双向BFS"></a>搜索-双向BFS</h1><ul><li>双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率。</li><li>同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案</li><li><font color="red">但是双向BFS在针对于小型数据范围时就会退化成BFS,如果双向BFS的两个端点完全没有连接，时间复杂度也会和BFS相同</font></li></ul><p><img src="/img/BFS.png" srcset="/img/loading.gif" alt=" "></p><p>当两种颜色相遇的时候，说明两个方向的搜索树遇到一起，这个时候就搜到了答案。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>简单理入门：</p><p><strong>问题描述</strong>：<br>一个迷宫由$R$行$C$列格子组成，有的格子里有障碍物，不能走；有的格子是空地，可以走。<br>给定一个迷宫，求从左上角走到右下角最少需要走多少步(数据保证一定能走到)。只能在水平方向或垂直方向走，不能斜着走。</p><p><strong>输入</strong></p><p>第一行是两个整数，$Ｒ$和$Ｃ$，代表迷宫的长和宽。$（1≤R，C≤40)$<br>接下来是$Ｒ$行，每行$Ｃ$个字符，代表整个迷宫。<br>空地格子用‘.’表示，有障碍物的格子用‘#’表示。<br>迷宫左上角和右下角都是‘.’。</p><p><strong>输出</strong></p><p>输出从左上角走到右下角至少要经过多少步（即至少要经过多少个空地格子）。计算步数要包括起点和终点</p><p><strong>输入样例</strong></p><pre><code class="hljs plain">5 5..####....#.#.##.#.##.#..</code></pre><p><strong>输出样例</strong></p><pre><code class="hljs plain">9</code></pre><p><strong>普通BFS：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">100000</span>; <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">101</span>;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; P;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[MAX][MAX];<span class="hljs-keyword">int</span> d[MAX][MAX];<span class="hljs-comment">//表示起点到各个位置的最短距离 </span><span class="hljs-keyword">int</span> sx, sy, gx, gy;<span class="hljs-comment">//表示起点和终点坐标 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,- <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;m &amp;&amp; d[x][y]==INF &amp;&amp; <span class="hljs-built_in">map</span>[x][y]!=<span class="hljs-string">'#'</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">queue</span>&lt;P&gt; que;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)d[i][j] = INF;que.push(P(sx, sy));d[sx][sy] = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(!que.empty()) &#123;P p = que.front(); que.pop();<span class="hljs-keyword">if</span>(p.first == gx &amp;&amp; p.second == gy)<span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = p.first + dx[i];<span class="hljs-keyword">int</span> ny = p.second + dy[i];<span class="hljs-keyword">if</span>(Check(nx, ny)) &#123;que.push(P(nx,ny));d[nx][ny] = d[p.first][p.second] + <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> d[gx][gy]; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];sx = <span class="hljs-number">0</span>, sy = <span class="hljs-number">0</span>;gx = n<span class="hljs-number">-1</span>, gy = m<span class="hljs-number">-1</span>;<span class="hljs-keyword">int</span> res = bfs(); <span class="hljs-built_in">cout</span> &lt;&lt; res+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>双向BFS</strong>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int, int&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//记录下当前状态, 从前往后搜索值为1，从后往前搜索值为2，如果某状态下，当前节点和准备扩展节点的状态相加为3，说明相遇</span><span class="hljs-built_in">queue</span> &lt;P&gt; q1, q2; <span class="hljs-keyword">int</span> r, c, ans, dis[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>], vst[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<span class="hljs-keyword">char</span> m[<span class="hljs-number">45</span>][<span class="hljs-number">45</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dbfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">bool</span> flag;q1.push(P(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), dis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, vst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//从前搜</span>q2.push(P(r, c)), dis[r][c] = <span class="hljs-number">1</span>, vst[r][c] = <span class="hljs-number">2</span>; <span class="hljs-comment">//从后搜</span><span class="hljs-keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty()) &#123;<span class="hljs-keyword">int</span> x0, y0;<span class="hljs-keyword">if</span>(q1.<span class="hljs-built_in">size</span>() &gt; q2.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">//每次扩展搜索树小的队列 flag=1扩展前搜的队列，flag=0扩展后搜的队列</span>x0 = q2.front().first, y0 = q2.front().second;q2.pop();flag = <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">else</span> &#123;x0 = q1.front().first, y0 = q1.front().second;q1.pop();flag = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-keyword">int</span> nx = x0 + dx[i];<span class="hljs-keyword">int</span> ny = y0 + dy[i];<span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= c &amp;&amp; m[nx][ny] == <span class="hljs-string">'.'</span>) &#123;<span class="hljs-keyword">if</span>(!dis[nx][ny]) &#123;dis[nx][ny] = dis[x0][y0] + <span class="hljs-number">1</span>;vst[nx][ny] = vst[x0][y0];<span class="hljs-keyword">if</span>(flag) q1.push(P(nx, ny));<span class="hljs-keyword">else</span> q2.push(P(nx, ny));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span>(vst[x0][y0] + vst[nx][ny]== <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//相遇</span>ans = dis[nx][ny] + dis[x0][y0];<span class="hljs-keyword">return</span>;&#125;&#125;&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">cin</span> &gt;&gt; r &gt;&gt; c;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++)<span class="hljs-built_in">cin</span> &gt;&gt; m[i][j];dbfs(); <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">"\n"</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a herf = "https://leetcode-cn.com/problems/word-ladder/">力扣第127题：单词接龙</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><pre><code class="hljs plain">输入:beginWord &#x3D; &quot;hit&quot;,endWord &#x3D; &quot;cog&quot;,wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,     返回它的长度 5。</code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs plain">输入:beginWord &#x3D; &quot;hit&quot;endWord &#x3D; &quot;cog&quot;wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><p>&emsp;&emsp;如果只是单纯的使用BFS经行操作那么时间复杂度将会为$O(M\times N)$ $M$表示单词的长度, $N$表示单词列表中单词的个数.</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;      <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; s; <span class="hljs-comment">// 可以块数查找</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : wordList) s.insert(i);      <span class="hljs-comment">// first 表示字符</span>      <span class="hljs-comment">// second 表示走过的路长</span>      <span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;      q.push(make_pair(beginWord, <span class="hljs-number">1</span>));      <span class="hljs-built_in">string</span> temp;      <span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>; <span class="hljs-comment">// 表示用暂时存贮走过的步子</span>      <span class="hljs-keyword">while</span> (!q.empty()) &#123;          <span class="hljs-keyword">if</span> (q.front().first == endWord) <span class="hljs-keyword">return</span> q.front().second;          temp = q.front().first;          <span class="hljs-built_in">step</span> = q.front().second;          q.pop();          <span class="hljs-keyword">char</span> ch;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= temp.<span class="hljs-built_in">size</span>(); ++ i) &#123;              ch = temp[i];              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-string">'a'</span>; a &lt; <span class="hljs-string">'z'</span>; ++ a) &#123;                  <span class="hljs-keyword">if</span> (ch == a) <span class="hljs-keyword">continue</span>;                  temp[i] = a;                  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(temp) != s.<span class="hljs-built_in">end</span>()) &#123; <span class="hljs-comment">// 这里表示如果找到了可以转换的两个单词，就把该数存放入队列里</span>                      q.push(make_pair(temp, <span class="hljs-built_in">step</span> + <span class="hljs-number">1</span>));                      s.erase(temp); <span class="hljs-comment">// 删掉结点的意思防止找到重复</span>                  &#125;                  temp[i] = ch;              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>如果使用双向BFS：</p><ul><li>$O(M \times N)$，其中 MM 是单词的长度 $N$是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 $M \times N$ 次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。</li></ul><p>算法：</p><ul><li><p>算法与之前描述的标准广搜方法相类似。</p></li><li><p>唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。</p></li><li><p>我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。</p></li><li><p>如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。</p></li></ul><blockquote><p> 双向搜索的结束条件是找到一个单词被两边搜索都访问过了。</p></blockquote><ul><li>最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dbfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;       <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; dict(wordList.<span class="hljs-built_in">begin</span>(), wordList.<span class="hljs-built_in">end</span>());       <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">find</span>(beginWord) != dict.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">//初始化</span>       <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; beginSet, endSet, tmp, visited;       beginSet.insert(beginWord);       endSet.insert(endWord);       <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;       <span class="hljs-keyword">while</span> (!beginSet.empty() &amp;&amp; !endSet.empty()) &#123;           <span class="hljs-keyword">if</span> (beginSet.<span class="hljs-built_in">size</span>() &gt; endSet.<span class="hljs-built_in">size</span>()) &#123;               tmp = beginSet;               beginSet = endSet;               endSet = tmp;           &#125;           tmp.<span class="hljs-built_in">clear</span>();           <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> <span class="hljs-keyword">word</span> : beginSet) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">word</span>.<span class="hljs-built_in">size</span>(); ++ i) &#123;                   <span class="hljs-keyword">char</span> old = <span class="hljs-keyword">word</span>[i];                   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> a = <span class="hljs-string">'a'</span>; a &lt; <span class="hljs-string">'z'</span>; ++ a) &#123;                       <span class="hljs-keyword">if</span> (old == a) <span class="hljs-keyword">continue</span>;                       <span class="hljs-keyword">word</span>[i] = a;                       <span class="hljs-keyword">if</span> (endSet.<span class="hljs-built_in">find</span>(<span class="hljs-keyword">word</span>) != endSet.<span class="hljs-built_in">end</span>()) &#123;                           <span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;                       &#125;                       <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">find</span>(<span class="hljs-keyword">word</span>) == visited.<span class="hljs-built_in">end</span>() &amp;&amp; dict.<span class="hljs-built_in">find</span>(<span class="hljs-keyword">word</span>) != dict.<span class="hljs-built_in">end</span>()) &#123;                           tmp.insert(<span class="hljs-keyword">word</span>);                           visited.insert(<span class="hljs-keyword">word</span>);                       &#125;                   &#125;                   <span class="hljs-keyword">word</span>[i] = old;               &#125;           &#125;           beginSet = tmp;           ++ len;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="关于set与unordered-set"><a href="#关于set与unordered-set" class="headerlink" title="关于set与unordered_set"></a>关于set与unordered_set</h3><ul><li><strong>set函数(集合)</strong>：这里的set表示集合的意思，和数学中的集合是一个意思，集合中不允许有重复出现的元素，由于set函数底层通常以红黑树实现，红黑树具有自动排序的功能，因此set内部所有的数据，在任何时候，都是有序的。</li><li><strong>unordered_set函数</strong>： 是含有 Key 类型唯一对象集合的关联容器，依赖于哈希表。搜索、插入和移除拥有平均常数时间复杂度。在内部，元素并不以任何特别顺序排序，而是组织进桶中，元素被放进哪个桶完全依赖其值的哈希。允许对单独元素的快速访问，因为一旦哈希，就能够准确指代元素被放入的桶。不可修改容器元素（即使通过非 const 迭代器），因为修改可能更改元素的哈希，并破坏容器。代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</li></ul><h4 id="下面几种情况一般使用set："><a href="#下面几种情况一般使用set：" class="headerlink" title="下面几种情况一般使用set："></a>下面几种情况一般使用set：</h4><ol><li>需要有序的数据(元素不同)。</li><li>需要按顺序打印/访问数据。</li><li>需要元素的前任或后继。</li></ol><h4 id="下面几种情况一般使用unordered-set："><a href="#下面几种情况一般使用unordered-set：" class="headerlink" title="下面几种情况一般使用unordered_set："></a>下面几种情况一般使用unordered_set：</h4><ol><li>需要保留一组不同的元素，不需要排序。</li><li>需要访问单个元素，不要遍历。</li></ol><h3 id="关于map与unordered-map"><a href="#关于map与unordered-map" class="headerlink" title="关于map与unordered_map"></a>关于map与unordered_map</h3><ul><li><strong>map函数（映射）</strong>： map函数在缺省下，按照递增的排序顺序，并且内部采用了自平衡的BST（二叉搜索树）的数据结构，实现了数据排序。所以在搜索的时候时间复杂度为$Olog(n)$</li><li><strong>unordered_map函数</strong>：unordered_map函数不进行排序二内部采用了哈希表的数据结构在搜索的时候时间复杂度为$O(1)$，但是在特殊情况下时间复杂度就会退化为$O(n)$</li></ul><p>因此如果你想要一个具有排序后的数据的话，通常可以选择map这种类型。或者想要打印具有一定顺序的元素。如果你只想记录数据而不是想要将数据进行排序的话，那么就可以选择unordered_map这种数据结构。</p><p><a herf="https://blog.csdn.net/weixin_43501684/article/details/90147421">.</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cellular automata</title>
    <link href="/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/"/>
    <url>/2020/03/27/lower_bound%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>STL函数，内部用二分查找实现</p><a id="more"></a><h1 id="有关lower-bound-函数的使用"><a href="#有关lower-bound-函数的使用" class="headerlink" title="有关lower_bound()函数的使用"></a>有关lower_bound()函数的使用</h1><p>lower_bound()函数需要加载头文件#include<algorithm>,其基本用途是查找有序区间中第一个大于或等于某给定值的元素的位置，其中排序规则可以通过二元关系来表示。</p><pre><code class="hljs C++">函数原型：<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>&gt;   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">First</span>,       <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">Last</span>,      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; _<span class="hljs-title">Val</span>   );</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIterator</span>, <span class="hljs-title">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> <span class="hljs-title">BinaryPredicate</span>&gt;   <span class="hljs-title">ForwardIterator</span> <span class="hljs-title">lower_bound</span>(      <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">First</span>,       <span class="hljs-title">ForwardIterator</span> _<span class="hljs-title">Last</span>,      <span class="hljs-title">const</span> <span class="hljs-title">Type</span>&amp; _<span class="hljs-title">Val</span>,      <span class="hljs-title">BinaryPredicate</span> _<span class="hljs-title">Comp</span>   );</span>传入参数说明：   _First 要查找区间的起始位置_Last 要查找区间的结束位置_Val 给定用来查找的值_Comp 自定义的表示小于关系的函数对象，根据某个元素是否满足小于关系而返回<span class="hljs-literal">true</span>或者<span class="hljs-literal">false</span></code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>例如，有如下序列：<br>$a[i]={12,15,17,19,20,22,23,26,29,35,40,51}$;<br>用值21调用lower_bound(),返回一个指向22的iterator。用值22调用lower_bound(),也返回一个指向22的iterator。第一个版本使用底层 &lt; (小于)操作符，第二个版本根据comp进行排序和比较。</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>调用lower_bound之前必须确定序列为有序序列，否则调用出错。第一个版本排序根据底层的 &lt;(小于)操作符，第二个版本根据comp进行排序。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/sdtc++.h&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);   <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><p>上面的例子是针对容器的，注意返回的是距离元素3最近的指针it，输出的是*it结果为元素4，假如我想得到位置而非具体的元素应该怎么办呢？这里有一个指针偏移的技巧，只需要减去起始位置的指针即可，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;  </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span>&#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++)          v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的  </span>    <span class="hljs-comment">//vector&lt;int&gt;::iterator it = lower_bound(v.begin(), v.end(), 3);  </span>    <span class="hljs-keyword">int</span> pos = lower_bound(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>)-v.<span class="hljs-built_in">begin</span>();      <span class="hljs-built_in">cout</span> &lt;&lt; pos&lt;&lt; <span class="hljs-built_in">endl</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;</code></pre><p>结果和容器的时候是一样的。</p><p>对于4个参数的情形，最后一个参数的自己定义的表示大小关系函数的对象，常用的逆序可以加载头文件#include<functional>,里边有一个greater<int>()函数即可对逆序求最近位置。假如说像上边一样元素为2 4 6 8，逆序则是8 6 4 2，那么求距离3最近表示的是与3最近的小于等于3的元素，输出结果则是元素2了，代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt; </span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &gt;<span class="hljs-number">0</span>; i--)     v.push_back(<span class="hljs-number">2</span> * i);<span class="hljs-comment">//注意此时v中的元素本身就是有序的 </span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());     <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们知道map容器是根据键值进行排序的</p><p>lower_bound(k)返回一个迭代器，指向键不小于k的第一个元素</p><p>upper_bound(k)返回一个迭代器，指向键大于k的第一个元素</p><p>这两个函数常用于multimap容器，用来获取某个键对应的所有元素</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; m;    m.insert(make_pair((<span class="hljs-built_in">string</span>)<span class="hljs-string">"China"</span>,<span class="hljs-number">1</span>));    m.insert(make_pair((<span class="hljs-built_in">string</span>)<span class="hljs-string">"China"</span>,<span class="hljs-number">2</span>));    m.insert(make_pair((<span class="hljs-built_in">string</span>)<span class="hljs-string">"China"</span>,<span class="hljs-number">3</span>));    m.insert(make_pair((<span class="hljs-built_in">string</span>)<span class="hljs-string">"English"</span>,<span class="hljs-number">1</span>));    m.insert(make_pair((<span class="hljs-built_in">string</span>)<span class="hljs-string">"English"</span>,<span class="hljs-number">2</span>));    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = m.<span class="hljs-built_in">begin</span>();    <span class="hljs-keyword">while</span>(it != m.<span class="hljs-built_in">end</span>())    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;        it++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">multimap</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it1 = m.lower_bound(<span class="hljs-string">"China"</span>),it2 = m.upper_bound(<span class="hljs-string">"China"</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;it1-&gt;first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;it1-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;it2-&gt;first&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;it2-&gt;second&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂题选讲</title>
    <link href="/2020/03/26/AC%E9%80%89%E8%AE%B2/"/>
    <url>/2020/03/26/AC%E9%80%89%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>最近AC题目的分析</p><a id="more"></a><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><blockquote><p>示例1：</p></blockquote><pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><blockquote><p>示例2:</p></blockquote><pre><code>输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;<strong>这种在数组空间上进行各种操作的题目，一般可以利用双指针进行解决。</strong><br>&emsp;&emsp;这个题目比较困难的地方再于各种边界的判定于操作，以及如何快速高效的进行合并。<br>&emsp;&emsp;双指针再解决这类问题的时候总有着很清晰的思路，首先我们要减少复杂情况，所以先排序形成一个有序的状态。我们先设双指针<br>第一个$save$用于保留和扩展另一个用$scan$来进行扫描</p><p>&emsp;&emsp;因为我们排序之后这个序列肯定是有序的所以我们就可以不用考虑左边界所有就剩下三种情况了</p><ul><li>eg:  $\overbrace{[1,3],[4,5]}^{save}$这种情况最为简单，两个区间不相交，因此我们就可以把$save$指针所指向的数据压入result数组种，然后再将$save$移动到<br>scan指针所指的地方：$[1,3],\overbrace{[4,5]}^{save}, \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save}, \overbrace{[2,3]}^{scan}$,这种是一种不被包含的情况，因此我们呢不需要操作$save$指针，$scan$ 指针继续往后移动即可：$\overbrace{[1,4]}^{save}, [2,3], \overbrace{[X,X]}^{scan}$</li></ul><ul><li>$eg: \overbrace{[1,4]}^{save},\overbrace{[3,5]}^{scan}$,这种情况是相对比较复杂的情况，即我们需要对于$save$指针指向的数组进行扩展，所以我们需要修改数组为$\overbrace{[1,4]}^{save} \rightarrow \overbrace{[1,5]}^{save}$, 然后将$scan$指向下一个,也就是:  $\overbrace{[1,5]}^{save}, [3,5], \overbrace{[X,X]}^{scan}$</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; merge(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals) &#123;        <span class="hljs-comment">// 对于特殊情况的特判</span>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;        <span class="hljs-comment">// 双指针</span>        <span class="hljs-keyword">int</span> save = <span class="hljs-number">0</span>; <span class="hljs-comment">//用于保存的数组</span>        <span class="hljs-keyword">int</span> scan = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用户扫描的数组</span>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;        sort (intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">while</span> (scan &lt; intervals.<span class="hljs-built_in">size</span>()) &#123;            <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">0</span>] &gt; intervals[save][<span class="hljs-number">1</span>]) &#123;                result.emplace_back(intervals[save]);                save = scan;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intervals[scan][<span class="hljs-number">1</span>] &lt;= intervals[save][<span class="hljs-number">1</span>]) &#123;                ++ scan;            &#125; <span class="hljs-keyword">else</span> &#123;                intervals[save][<span class="hljs-number">1</span>] = intervals[scan][<span class="hljs-number">1</span>]; <span class="hljs-comment">//将数组扩充</span>                ++ scan;            &#125;        &#125;        result.emplace_back(intervals[save]); <span class="hljs-comment">// 当scan扫描到最后一个区间之后会跳出循环也就是说还有一个区间没有压入向量</span>        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;三种情况种第一种情况是一般情况，后面两种是特殊情况，我们只需要对特殊情况经行处理称一般情况，然后让一般情况操就行了。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Largest Rectangle in Histogram</title>
    <link href="/2020/03/21/MaximalRectangle/"/>
    <url>/2020/03/21/MaximalRectangle/</url>
    
    <content type="html"><![CDATA[<p>Largest Rectangle in Histogram解析</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="/img/rectangle2.png" srcset="/img/loading.gif" alt=" "></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p><img src="/img/rectangle1.png" srcset="/img/loading.gif" alt=" "></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>示例:</p><p>输入: [2,1,5,6,2,3]</p><p>输出: 10</p></blockquote><h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p><img src="/img/rectangle.png" srcset="/img/loading.gif" alt=" "></p><p>height的内容是 [5,6,7,8,3]，特点是除了最后一个，前面全部保持递增，且最后一个立柱的高度小于前面所有立柱高度。对于<br>这种特点的柱状图，如果使用上面所说的“挨个使用每一个柱状图的高度作为矩形的高度，求面积”的方法，还需要用嵌套循环吗？</p><p>&emsp;&emsp;我们知道除了最后一个，从第一个到倒数第二个立柱的高度都在升高，那么如果挨个使用每一个柱的高度作为矩形的<br>高度，那么依次能得到的矩形的宽度就可以直接算出来：使用5作为高度可以使用前四个立柱组成 $4\times5$的矩形，高度6可以<br>组成$3\times6$的矩形… 因此只需要遍历一次，选出最大面积即可。对于这种类型的柱状图，最大矩形面积的时间复杂度是O(n)。我们将这种特点的柱状图称为“波峰图”。</p><p>从而算法设计步骤：</p><p>(1) 在height尾部添加一个0，也就是一个高度为0的立柱。作用是在最后也能凑成上面提的那种“波峰图”。</p><p>(2) 定义了一个stack，然后遍历时如果height[i] 大于stack.top()，进栈。反之，出栈直到栈顶元素小于height[i]。</p><p>由于出栈的这些元素高度都是递增的，我们可以求出这些立柱中所围成的最大矩形。更妙的是，由于这些被弹出的立柱处于“波峰”之上(比如弹出i 到 i+k，那么所有这些立柱的高度都高于 i-1和 i+k+1的高度)，因此，如果我们使用之前所提的“左右延伸找立<br>柱”的思路解，以这些立柱的高度作为整个矩形的高度时，左右延伸出的矩形所包含的立柱不会超出这段“波峰”，因为波峰外的立柱<br>高度都比他们低。“波峰图”其实就是求解最大矩形的“孤岛”，它不会干扰到外部。</p><p>(3) 由于比height[i]大的元素都出完了，height[i]又比栈顶元素大了，因此再次进栈。如此往复，直到遍历到最后那个高度为0的柱，触发最后的弹出以及最后一次面积的计算，此后stack为空。</p><p>(4) 返回面积最大值。</p><p>&emsp;&emsp;栈中存的不是高度，而是height的索引，这样做的好处是不会影响宽度的计算，索引值相减 = 宽度。</p><h2 id="但是对于面积的计算，还需要再多少几句"><a href="#但是对于面积的计算，还需要再多少几句" class="headerlink" title="但是对于面积的计算，还需要再多少几句"></a>但是对于面积的计算，还需要再多少几句</h2><p><img src="/img/rectangle3.png" srcset="/img/loading.gif" alt=" "></p><p>矩形的面积=高*宽。<br>我们的发现，在这个分支情况下，我们已经知道高为2了，那么宽度如何求呢？<br>通过观察，我们发现矩形的左边沿是左边第一个高比2小的柱子，右边沿是右边第一个高比2小的柱子（将高为3的柱子的右面看作还<br>有一个高为0的柱子）如此它的宽度是$6 -（1+1）=4$</p><h2 id="如何寻找柱子的左右边"><a href="#如何寻找柱子的左右边" class="headerlink" title="如何寻找柱子的左右边"></a>如何寻找柱子的左右边</h2><p>我们已经说了，左边沿是左边第一小与本柱子高的柱子的右边，右边沿也是同理。<br>这正好可以用单调栈。<br>当第i个柱子进栈时，如果栈顶柱子（此处记作柱子A）的高度低于或等于第i个柱子，则第i个柱子进栈；<br>如果高于第i个柱子，则出栈，并计算以柱子A为高的矩形最大面积。</p><ul><li>高度：就是柱子A的高度</li><li>右边沿：正好是i（由于单调栈的性质，第i个柱子就是右边第一个矮于A的柱子）</li><li>左边沿：单调栈中紧邻A的柱子。（如果A已经出栈，那么左边沿就是A出栈后的栈顶）而且是该柱子的右边，所以要+1.</li></ul><p>因此，完全覆盖第index个柱子的最大矩形的面积如下（stk是单调栈）</p><pre><code>maxArea = heights[index] * (i - (stk.top() +1))</code></pre><p>还有一种情况。当A出栈后，单调栈为空时，那就是说明，A的左边没有比它矮的。左边沿就可以到0.</p><pre><code>maxArea = heights[index] * (stk.empty() ? i : (i - stk.top() -1)))</code></pre><p>可能你还有点不明白就是，那实际代码是怎么计算的？其实自习想一下就明白了，因为是取得top元素进行计算所以计算是从右边逐<br>渐往左边延伸。所以当整个栈排空的时候也就计算了距离右边最远的边界。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>栈实现：</strong></p><pre><code>int largeRectangleArea(vector&lt;int&gt;&amp; h) {    stack&lt;int&gt; s;    h.push_back(0);    int sum = 0;    for (int i = 0; i &lt; h.size(); ++ i) {        if (s.empty() || h[i] &gt; h[s.top()]) s.push(i);        else {            int tmp = s.top();            s.pop();            sum = max(sum, h[tmp] * (s.empty() ? i : i - s.top() - 1));            i --;        }    }    return sum;}</code></pre><p><strong>分治解法：</strong></p><pre><code>    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {        if(heights.empty()) return 0;        return maxArea(heights,0,(int)heights.size()-1);    }    int maxArea(vector&lt;int&gt;&amp; heights,int start, int end){        if(start &gt; end)            return 0;        int minIndex=start;        bool sorted = true;        for(int i=start+1;i&lt;=end;++i){            if(heights[i]&lt;heights[i-1])                sorted=false;            if(heights[i] &lt; heights[minIndex]){                minIndex=i;            }         }        if(sorted){//如果有序则不需要再作进一步的分治            int mx=0;            for(int i=start;i&lt;=end;++i)            mx = max(mx,(end-i+1)*heights[i]);            return mx;        }        return max( (end-start+1)*heights[minIndex],                max( maxArea(heights,start, minIndex-1),maxArea(heights,minIndex+1, end) ) );//分治    }</code></pre><h1 id="算01-矩阵中包含最多1-的矩形"><a href="#算01-矩阵中包含最多1-的矩形" class="headerlink" title="算01 矩阵中包含最多1 的矩形"></a>算01 矩阵中包含最多1 的矩形</h1><p>接下来还有道Maximal Rectangle 的题，这道题的实用价值很大：算01 矩阵中包含最多1 的矩形。</p><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>有了上一题的基础，这道题就可等效为上一题，对于矩阵每一行，我们将其看作直方图，立柱的高度就是行中元素往上数包含的连续1的个数。</p><p>因此每一行都可以利用上一题方法计算最大矩形，最后求出各行结果的最大值就好了。时间复杂度 O(n2)</p><pre><code>    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {                if(matrix.size() == 0 || matrix[0].size() == 0) return 0;        int H = matrix.size(), W = matrix[0].size();        int height[W+1];        int i, j , MAX = 0, leftarea = 0, rightarea = 0;        stack&lt;int&gt; st;        for(i = 0; i &lt;= W; height[i] = 0, ++i);        for(i = 0; i &lt; H; ++i){            while(!st.empty()) st.pop();            for(j = 0; j &lt; W; ++j){                if(matrix[i][j] == &#39;1&#39;) height[j]++;                else height[j] = 0;            }            for(int j = 0; j &lt;= W; ++j){                while(!st.empty() &amp;&amp; height[st.top()] &gt; height[j]){                    int tmp = st.top();                    st.pop();                    leftarea = (st.empty() ? tmp + 1 : tmp - st.top()) * height[tmp];                    rightarea = (j - tmp - 1) * height[tmp];                    if((leftarea + rightarea) &gt; MAX) MAX = (leftarea + rightarea);                }                st.push(j);            }        }        return MAX;    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode小技巧</title>
    <link href="/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/03/19/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>vscode 快捷键</p><a id="more"></a><h1 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h1><h1 id="如果懒"><a href="#如果懒" class="headerlink" title="如果懒"></a>如果懒</h1><p>不想看我bb就直接这样做就直接⬇；</p><p>ctrl k + ctrl s = 打开快捷键一览表。</p><p>在这里面、你可以查看、搜索、修改快捷键。</p><h2 id="列出当前可执行的动作"><a href="#列出当前可执行的动作" class="headerlink" title="列出当前可执行的动作"></a>列出当前可执行的动作</h2><p>显示 Errors或 Warnings，也可以 Ctrl+Shift+M:跳转到行数，也可以 Ctrl+G 直接进入</p><p>跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入</p><p>根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入” : “进入</p><p>根据名字查找 symbol，也可以 Ctrl+T</p><p>代码行向左或向右缩进:   Ctrl+[ 、 Ctrl+]</p><p>复制或剪切当前行/当前选中内容:   Ctrl+C 、 Ctrl+V</p><p>代码格式化:   Shift+Alt+F</p><p>向上或向下移动一行:   Alt+Up 或 Alt+Down</p><p>向上或向下复制一行:   Shift+Alt+Up 或 Shift+Alt+Down</p><p>在当前行下方插入一行:   Ctrl+Enter</p><p>在当前行上方插入一行:   Ctrl+Shift+Enter</p><p>Ctrl+Shift+P,F1 展示全局命令面板</p><p>Ctrl+P 快速打开最近打开的文件</p><p>Ctrl+Shift+N 打开新的编辑器窗口</p><p>Ctrl+Shift+W 关闭编辑器</p><p>Ctrl + X 剪切</p><p>Ctrl + C 复制</p><p>Alt + up/down 移动行上下</p><p>Shift + Alt up/down 在当前行上下复制当前行</p><p>Ctrl + Shift + K 删除行</p><p>Ctrl + Enter 在当前行下插入新的一行</p><p>Ctrl + Shift + Enter 在当前行上插入新的一行</p><p>Ctrl + Shift + | 匹配花括号的闭合处，跳转</p><p>Ctrl + ] 或 [ 行缩进</p><p>Home 光标跳转到行头</p><p>End 光标跳转到行尾</p><p>Ctrl + Home 跳转到页头</p><p>Ctrl + End 跳转到页尾</p><p>Ctrl + up/down 行视图上下偏移</p><p>Alt + PgUp/PgDown 屏视图上下偏移</p><p>Ctrl + Shift + [ 折叠区域代码</p><p>Ctrl + Shift + ] 展开区域代码</p><p>Ctrl + / 添加关闭行注释</p><p>Shift + Alt +A 块区域注释</p><p>Alt + Z 添加关闭词汇包含</p><h2 id="导航快捷键"><a href="#导航快捷键" class="headerlink" title="导航快捷键"></a>导航快捷键</h2><p>Ctrl + T 列出所有符号</p><p>Ctrl + G 跳转行</p><p>Ctrl + P 跳转文件</p><p>Ctrl + Shift + O 跳转到符号处</p><p>Ctrl + Shift + M 或 Ctrl + J 打开问题展示面板</p><p>F8 跳转到下一个错误或者警告</p><p>Shift + F8 跳转到上一个错误或者警告</p><p>Ctrl + Shift + Tab 切换到最近打开的文件</p><p>Alt + left / right 向后、向前</p><p>Ctrl + M 进入用Tab来移动焦点</p><p>Ctrl + F 查询</p><p>Ctrl + H 替换</p><p>F3 / Shift + F3 查询下一个/上一个</p><p>Alt + Enter 选中所有出现在查询中的</p><p>Ctrl + D 匹配当前选中的词汇或者行，再次选中-可操作</p><h2 id="多行光标快捷键"><a href="#多行光标快捷键" class="headerlink" title="多行光标快捷键"></a>多行光标快捷键</h2><p>Alt + Click 插入光标-支持多个</p><p>Ctrl + Alt + up/down 上下插入光标-支持多个</p><p>Ctrl + U 撤销最后一次光标操作</p><p>Shift + Alt + I 插入光标到选中范围内所有行结束符</p><p>Ctrl + I 选中当前行</p><p>Ctrl + Shift + L 选择所有出现在当前选中的行-操作</p><p>Ctrl + F2 选择所有出现在当前选中的词汇-操作</p><p>Shift + Alt + right 从光标处扩展选中全行</p><p>Shift + Alt + left 收缩选择区域</p><p>Shift + Alt + (drag mouse) 鼠标拖动区域，同时在多个行结束符插入光标</p><p>Ctrl + Shift + Alt + (Arrow Key) 也是插入多行光标的<code>[方向键控制]</code></p><p>Ctrl + Shift + Alt + PgUp/PgDown 也是插入多行光标的<code>[整屏生效]</code></p><p>Esc Esc 连续按两次Esc键取消多行光标</p><p>Shift + Alt + F 格式化代码</p><p>F12 跳转到定义处</p><p>Alt + F12 代码片段显示定义</p><p>Ctrl + K F12 在其他窗口打开定义处</p><p>Ctrl + . 快速修复部分可以修复的语法错误</p><p>Shift + F12 显示所有引用</p><p>F2 重命名符号</p><p>Ctrl + Shift + . / , 替换下个值</p><h2 id="编辑器管理快捷键"><a href="#编辑器管理快捷键" class="headerlink" title="编辑器管理快捷键"></a>编辑器管理快捷键</h2><p>Ctrl + F4, Ctrl + W 关闭编辑器</p><p>Ctrl + |切割编辑窗口</p><p>Ctrl + 1/2/3 切换焦点在不同的切割窗口</p><p>Ctrl + Shift + PgUp/PgDown 切换标签页的位置</p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++笔记</title>
    <link href="/2020/03/18/C++note/"/>
    <url>/2020/03/18/C++note/</url>
    
    <content type="html"><![CDATA[<p>记录C++中遇到的问题</p><a id="more"></a><h2 id="关于auto"><a href="#关于auto" class="headerlink" title="关于auto"></a>关于auto</h2><p>(1)auto</p><p>auto即 for(auto x:range)  这样会拷贝一份range元素，而不会改变range中元素；</p><p>但是！（重点)  使用for(auto x:vector<bool>)时得到一个proxy class,操作时会改变vector<bool>本身元素。应用：for(bool x:vector<bool>)</p><p>(2)auto&amp;</p><p>当需要修改range中元素，用for(auto&amp; x:range)</p><p>当vector<bool>返回临时对象，使用auto&amp;会编译错误，临时对象不能绑在non-const l-value reference （左值引用）需使用auto&amp;&amp;,初始化右值时也可捕获</p><p>(3)const auto&amp;   </p><p>当只想读取range中元素时，使用const auto&amp;,如：for(const auto&amp;x:range),它不会进行拷贝，也不会修改range   </p><p>(4)const auto</p><p>当需要拷贝元素，但不可修改拷贝出来的值时，使用 for(const auto x:range)，避免拷贝开销.</p><hr><p>当我们在遍历容器的时候</p><pre><code>for(auto i : vec){std::cout &lt;&lt;i &lt;&lt;std::endl;}</code></pre><p>但我知道这不必要的——不必要,因为我只需要打印 vec ——复制的值</p><p>编辑 : vec的每个元素，所以我可以这样做</p><pre><code>for(auto &amp;i : vec){std::cout &lt;&lt;i &lt;&lt;std::endl;}</code></pre><p>但是我想确保 vec的值从未被修改并遵守 const-correctness，所以我可以：</p><pre><code>for(const auto &amp;i : vec){std::cout &lt;&lt;i &lt;&lt;std::endl;}</code></pre><p>我的问题是:如果我只需要看看一些容器的值,不会最后循环( const auto &amp;i ) 总是首选由于增加effieciency没有额外的副本(编辑 : vec的每个元素？</p><pre><code>T//I&#39;m copying thisT&amp;//I&#39;m modifying thisconst T&amp;//I&#39;m reading this</code></pre><p>这些是你的”默认值”。当 T 是基本类型( 内置) 时，你通常只需要恢复 const T ( 无引用)，因为副本比别名更便宜。</p><h1 id="对vector进行排序"><a href="#对vector进行排序" class="headerlink" title="对vector进行排序"></a>对vector进行排序</h1><p>源码：</p><pre><code>#include &lt;algorithm&gt;#include &lt;vector&gt;vector&lt;int&gt; vec;//比较函数，这里的元素类型要与vector存储的类型一致bool compare(int a,int b){return a&lt;b; //升序排列}std::sort(vec.begin(),vec.end(),compare);</code></pre><blockquote><p>注意：由于sort()函数如果不声明比较函数就是默认升序，从小到大。</p></blockquote><h2 id="利用标准库函数find-对vector进行查找"><a href="#利用标准库函数find-对vector进行查找" class="headerlink" title="利用标准库函数find()对vector进行查找"></a>利用标准库函数find()对vector进行查找</h2><pre><code>vector&lt;int&gt; vec;int a=10;vector&lt;int&gt;::iterator it=find(vec.begin(),vector.end(),a);</code></pre><h2 id="构造类型在vector中的排序与查找"><a href="#构造类型在vector中的排序与查找" class="headerlink" title="构造类型在vector中的排序与查找"></a>构造类型在vector中的排序与查找</h2><p>&emsp;&emsp;将构造类型，比如struct的对象存储在vector中，查找时，需要重载等于运算符（operator==），具体实现参考如下代码。</p><pre><code>struct Element {public:    int a;    int b;    Element(int a,int b){        this-&gt;a = a;        this-&gt;b = b;    };    bool operator == (const Element&amp; ele){        return a == ele.a &amp;&amp; b == ele.b;    };};//自定义比较函数bool compare(const Element&amp; left,const Element&amp; right){    return left.a &lt; right.a; //升序排列}//重载输出操作符&lt;&lt;，格式化输出Elementostream&amp; operator &lt;&lt; (ostream&amp; coutU,const Element&amp; ele){    coutU &lt;&lt; &quot;a:&quot; &lt;&lt; ele.a &lt;&lt; &quot;,b:&quot; &lt;&lt; ele.b;    return coutU;}int main() {    vector&lt;Element&gt; vecEle;    vecEle.push_back(Element(4,4));    vecEle.push_back(Element(1,1));    vecEle.push_back(Element(2,2));    vecEle.push_back(Element(3,3));    //sort    std::sort(vecEle.begin(),vecEle.end(),compare);    for(int i=0; i&lt;vecEle.size(); ++ i) {        cout &lt;&lt; vecEle[i] &lt;&lt; endl;    }    //查找Element(4,4)    vector&lt;Element&gt;::iterator it = find(vecEle.begin(),vecEle.end(),Element(4,4));    cout &lt;&lt; &quot;found &quot; &lt;&lt; *it &lt;&lt; endl;}</code></pre><blockquote><p>程序输出：<br>a:1,b:1<br>a:2,b:2<br>a:3,b:3<br>a:4,b:4<br>found a:4,b:4</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滴滴~</title>
    <link href="/2020/03/15/20%E5%B2%81/"/>
    <url>/2020/03/15/20%E5%B2%81/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p><center></p><p><font size="#e78e97"><br>迈入二十大关</font><br>&lt;/center&gt;<br>你往往只能看到正面，而背面你缺一无所知。<br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /><br><br /></p><!---------------------------能看到这说明你更愿意去了解背后的故事。而这些的开始，往往可能也就是一种冲动-------------------------------------><p>$\ldots$</p>]]></content>
    
    
    <categories>
      
      <category>day</category>
      
    </categories>
    
    
    <tags>
      
      <tag>day</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忆第一次美赛</title>
    <link href="/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
    <url>/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p>这不仅仅只是一次比赛那么简单</p><a id="more"></a><p>&emsp;&emsp;会战的失败原因是拿破仑一世对敌情侦察不够，临战前分散兵力，初战不利便改变决心，指挥不果断。惠灵顿<br>在进行会战决策、选择阵地、组织防御和协调联军作战方面显示了统帅才能。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>&emsp;&emsp;到我开始写这篇回忆的时候已经，已经距离美赛结束9个小时左右了。当我点下发送的那一刻，我们这场耗时80个小时三天零8个小时的比赛就真的全部结束了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/mail.png" srcset="/img/loading.gif">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">提交</div></center><p>&emsp;&emsp;在关掉电脑之后我狠狠的删自己一巴掌之后，倒上床了就睡了过去。</p><h1 id="前夜"><a href="#前夜" class="headerlink" title="前夜"></a>前夜</h1><p>&emsp;&emsp;由于今年疫情的特殊原因，这次本应该在线下的比赛。被迫转移到了线上，腾讯会议是我和两个好伙伴交流与<br>讨论的唯一途径。在阿凡群里面我们对我们的设备做好了最后的调试，也大概确定了我们所希望努力的方向。就只等3月7号上<br>午出题了，大家还开玩笑说自己已经买好咖啡做好通宵的准备。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/coffee.jpg" srcset="/img/loading.gif">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">阿凡的饮料</div></center><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>&emsp;&emsp;当拿到题目的时候已经是翻译好的了，由于我们的队伍均是有CS专业同学组成的队伍，且我和阿凡都是第一次参加建模比赛。我们在比赛之前，也了解到每个题目的总体大概所需要的知识。对于C题来说相对我们来说相对友好一些。我也了解到，C题会用到数据挖掘、数据清洗、python。我觉得我在寒假期间稍微学习了一下python的基础知识，对于读懂python的基本语法应没有什么问题。但是看到题目的时候，复杂程度对于我来说几乎是没辙。怎么剔除文本中的乱码情况，怎么对给的数据进行清洗，什么是.tsv文件$\ldots$, 一系列问题我完全傻了。什么正则表达式，什么情感分析。我完全都不懂。</p><p>&emsp;&emsp;这原本是我觉得可以在前期帮助到我们队伍的东西，完全用了。负责建模的阿凡也就揽了过去，要我和阿豪去看后的题目。谁知道第一题我和阿豪就看的非常懵…问的很笼统。随后还是在知乎上有人解读才慢慢似懂非懂的大概知道第一题要我们干什么，上午我们也很快的解决的了第一题，下午便开始对后面的主要部分开始了思考，在赛前我说我会$\LaTeX$，可以负责写作。也在一个月的时间里系统的学习了，之前简单了解的知识。但是我对写作的理解太片面了。赛前准备的时候，看到网上的教程说，写作的同学不能不懂建模，不然写不出来，虽然不直接参与建模但是要对整个模型要明白。我觉得我明白了后一段话，而前段话我到现在才明白。第一天我们对题目的分析之后也就大概解决了第一题。<br>&emsp;&emsp;在第一天结束的时候,我对我这一天进行了总结，因为我感觉我很懵，感觉自己一直在神游，除了可以提一提建议，可以说没有做别的任何事。决定他们在建模的时候了解大概的思路，我就去找找文献，看一下所用到的方法。可以为后面的写作做好准备。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>&emsp;&emsp;因为第二题中a问用到了NLP文本情感分析，在了解学习之后需要需要用到python来进行机器学习。我想我学习过python看看能不能在网上找一下代码看看，能不能跑。但是我又再次错了，我装上了库。库不能运行，我也一直找不出问题。寻求开发者文档也没有结果。到最后我也跑成功，除了知道了大家用了什么方法，想干什么之外。我还是什么也不知道干什么。直到晚上我才明白，我应该开始写作。把要用到的图表先画上去，把$\LaTeX$用的图片环境都给配置好。为后面写作做节省时间。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>&emsp;&emsp;到第三天，也就到最后的冲刺阶段了，但是我们在之前的b题出现了一些新的问题，感觉在后面的拟合效果不好是不是我们的方法出现了问题，这也导致我们本就不自信的c题和d题，需要有所改动。当时我时我知道如果我们不加快进度可能时间会不太够。因为我们在第二天晚上就开始写了问题分析，稍微解决了一些写作上的问题，但是后面主题部分，模型的建立，模型的步骤、推广、在问题中的实际应用，也都没写，也就是我的失职。本应该同时经行的地方我确把这写东西寄托在别人身上。</p><h1 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h1><p>&emsp;&emsp;到了晚上8点，也就是说我们距离美赛结束还剩最后的16个小时。我们的主题部分，还又最为重要的摘要还没写。我从8点开始写摘要一直到10点才写完。我本人为自己写的很好。但是实际确实，完全没不了。完全不可能用在我们的论文中。这也就浪费了很多时间。在模型的建立部分我只是从阿凡那里获得，几乎是他所完成的。当时我们也比较急，当时他说你到低干了啥的时候确实十分内疚，我真的干了啥，我真的有在做什么…<br>&emsp;&emsp;之后我最不愿意看到的地方出现了，<code>我的</code> $\LaTeX$ <code>编译不了了</code>，这也是我从来没有遇到过的问题。我写了100次的$\LaTeX$也遇见过一些问题，但是今天在翻译复制上的之后出现的问题我也是第一次遇到，一直编译不过我是真的急了，当时看到时间已经凌晨了，如果再不解决我们就很有可能面临着无法提交的问题。我试用了各种方法，来解决。但是就是无法解决…然后我下载了TeXstduio,看看能不能有所改进，然后我才发现是“_”的问题，我也没有转义就一直无法编译…<br>&emsp;&emsp;但是这还没完，我在机翻复制之后表格环境还是出现了问题。因为实在不知道怎么解决，只能手画了…，然后还是阿凡，不断给我法写好的表格代码，才稍微加快的进度。眼看时间已经2点了，距离比赛还剩6个小时了。我还在翻译a题，我真的很慌，再加上不时出现的图片浮动位置变化的问题，对于复杂公式我也开始不能快速的书写出来，可以说完全写不了。还是只能在帮助下才能完成….</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我终于在7点左右把所有的问题都给完成了，我的两个好朋友也陪着我一起整整一夜没有睡觉。我也很感谢他们在最后也没有没指责我，因为我的原因，导致了整个队伍在最后如此狼狈的完成了这次的比赛。到了最后大家还在讨论是否能在最后把我们的论文做一下改进，做一下优化。直到最后在发送比赛邮件的时候，这似乎真的都成了历史，真的是一次非常难忘且独特的经历，看到大家那么努力的建模，却在最后应该我负起责任的时候出现了这么严重了的问题。这本来就是一个团队每个人每个环节都应该认真完成的比赛，要是有一环出现问题，那么到最后也是功亏一篑。而我就是那最后一环，原本想用$\LaTeX$来进行一次完美的排版，到了最后确实这样的结果。</p><h1 id="明白"><a href="#明白" class="headerlink" title="明白"></a>明白</h1><p>&emsp;&emsp; 原本我是不打算写这边回忆的，但是不记录一下却又十分而可惜，由于我的参与感太低，几乎在整个团队中没有做到一点贡献，到了我在应该。<br>做出贡献的时候我确掉了链子，掉链子似乎真的成为了我的专有名词，大家都说我靠不住。一开始我还不理解，直到现在我才<br>明在为什么，从赛前准备开始我的准备就不足，虽然知道自己的在哪方面存在问题存在不足。但是我还是存在不足的问题，感<br>觉自己已经准备好了，但是自己完全认识到事情真正是什么情况。总是逃避问题，不愿意去认识到错误。总觉得自己懂，觉得自己可以，但往往还是不明白。“哦，你又懂了”我一直告诉自己要谦逊，要虚心接受。但是我直到，现在我还没有想到问题的<br>本质是什么。但是通过这件事情，我才明白我为什么无法明白，是因为一直都逃避，不愿意接受别人本来就比自己强，自己本来就不明白，却非要不懂装懂。这才是我无法虚心接受的原因，如果对一些知识没了解过，就完全没有资格去说自己明白了，说别人说不对。<br>&emsp;&emsp;学长说我太浮躁，也是我一直的诟病。我也一直把阿凡作为我的现在榜样，希望能赶超他。如果我现在还是这种，对自己一直自我感觉良好的的状态，别说是望其项背了，可能就是只剩下望尘莫及了。直面逃避的问题，才是我应该做的。而不是说我要好好努力就行了。通过这次比赛我明白了很多，真正认识到了自己应该去努力的方向。寒假认识了GZTime,<br>我也应该明白了我后面发展方向。感觉就之前的经历都没有美赛这么锻炼人，虽然很难但是我认为我有必要再参加一次。好好的向我的两位好朋友好好道歉。在后面的时日里好好努力，去消除那本来就很大的差距，去弥补那缺失的学习能力.去成为一<br>为一个稳健且说到做到的人。</p><h2 id="后面是因为我而没用上的插图"><a href="#后面是因为我而没用上的插图" class="headerlink" title="后面是因为我而没用上的插图"></a>后面是因为我而没用上的插图</h2><p><img src="/img/WordArt.jpeg" srcset="/img/loading.gif" alt=" "><br><img src="/img/WordArt1.jpeg" srcset="/img/loading.gif" alt=" "><br><img src="/img/WordArt2.jpeg" srcset="/img/loading.gif" alt=" "><br><img src="/img/WordArt3.jpeg" srcset="/img/loading.gif" alt=" "><br><img src="/img/WordArt4.jpeg" srcset="/img/loading.gif" alt=" "></p><font color="#7ea497">致谢：阿凡、阿豪</font><font color="#f4f4f4">(虽然我不喜欢这种阿什么什么的称呼）</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mcm写作基本流程</title>
    <link href="/2020/03/05/mcm%E5%86%99%E4%BD%9C/"/>
    <url>/2020/03/05/mcm%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>美赛的基本写作流程</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过对优秀文章的阅读，美赛的文章有相对固定的写作套路。大部分都分为：</p><ul><li>摘要</li><li>问题重述<ul><li>问题背景</li><li>问题重述</li></ul></li><li>问题分析<ul><li>对问题一分析</li><li>对问题二分析</li><li>对问题三分析</li></ul></li><li>模型假设</li><li>符号说明</li><li>模型的建立与求解<ul><li>问题一</li><li>问题二</li><li>问题三</li></ul></li><li>模型的分析建议</li><li>模型的评估与优化</li><li>参考文献</li><li>附录</li></ul><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>摘要一般第一段写对问题总体环境的概述，第二段开始一般是回答第一个问题，第二段对第二个问题进行分析，第三段对三个问题分析。一般摘要的三段或四段都是与题目相对应。题目一般都是循序渐进，逐步解决问题。最后就是$\textbf{keywords}$ 这个就主要写所使用的模型。</p><h1 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h1><p>这个没什么好说得，就直接把问题重新再抄写一下就可以了，分为问题背景和问题重述</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>问题分析这部分就是对每个小问题，分别建模讨论使用得模型对所寻找的数据或题目所给的数据进行分析。然后再对得到的数据进行预测建立模型，</p><p>….</p><p>后面的就是独家内容了，嘿嘿嘿。晚点再更新….</p>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用LaTex编写流程图</title>
    <link href="/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/"/>
    <url>/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>简单介绍如何使用$\LaTeX$进行流程图的绘制</p><a id="more"></a><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/img/流程图.png" srcset="/img/loading.gif" alt=" "></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="hljs plain">\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;tikz&#125; %%主要宏包\usetikzlibrary&#123;shapes,arrows&#125;\begin&#123;document&#125;\pagestyle&#123;empty&#125; % 无页眉页脚\tikzstyle&#123;startstop&#125; &#x3D; [rectangle,rounded corners, minimum width&#x3D;3cm,minimum height&#x3D;1cm,text centered, draw&#x3D;black,fill&#x3D;red!30]\tikzstyle&#123;io&#125; &#x3D; [trapezium, trapezium left angle &#x3D; 70,trapezium right angle&#x3D;110,minimum width&#x3D;3cm,minimum height&#x3D;1cm,text centered,draw&#x3D;black,fill&#x3D;blue!30]\tikzstyle&#123;process&#125; &#x3D; [rectangle,minimum width&#x3D;3cm,minimum height&#x3D;1cm,text centered,text width &#x3D;3cm,draw&#x3D;black,fill&#x3D;orange!30]\tikzstyle&#123;decision&#125; &#x3D; [diamond,minimum width&#x3D;3cm,minimum height&#x3D;1cm,text centered,draw&#x3D;black,fill&#x3D;green!30]\tikzstyle&#123;arrow&#125; &#x3D; [thick,-&gt;,&gt;&#x3D;stealth]\begin&#123;tikzpicture&#125;[node distance&#x3D;2cm]\node (start) [startstop] &#123;Start&#125;;\node (input1) [io,below of&#x3D;start] &#123;Input&#125;;\node (process1) [process,below of&#x3D;input1] &#123;Process 1&#125;;\node (decision1) [decision,below of&#x3D;process1,yshift&#x3D;-0.5cm] &#123;Decession 1&#125;;\node (process2a) [process,below of&#x3D;decision1,yshift&#x3D;-0.5cm] &#123;Process 2aaaaaa aaaaaaa aaaa&#125;;\node (process2b) [process,right of &#x3D;decision1,xshift&#x3D;2cm] &#123;Process 2b&#125;;\node (out1) [io,below of&#x3D;process2a] &#123;Output&#125;;\node (stop) [startstop,below of&#x3D;out1] &#123;Stop&#125;;\draw [arrow] (start) -- (input1);\draw [arrow] (input1) -- (process1);\draw [arrow] (process1) -- (decision1);\draw [arrow] (decision1) -- node[anchor&#x3D;east] &#123;yes&#125; (process2a);\draw [arrow] (decision1) -- node[anchor&#x3D;south] &#123;no&#125; (process2b);\draw [arrow] (process2b) |- (process1);\draw [arrow] (process2a) -- (out1);\draw [arrow] (out1) -- (stop);\end&#123;tikzpicture&#125;\end&#123;document&#125;</code></pre><h2 id="using-package"><a href="#using-package" class="headerlink" title="using package"></a>using package</h2><p>$\LaTeX$中绘图均要引入<code>tikz</code>宏包</p><pre><code class="hljs plain">\usepackage&#123;tikz&#125;\usetikzlibrary&#123;shapes.geometric, arrows&#125;</code></pre><h2 id="对节点node进行定义"><a href="#对节点node进行定义" class="headerlink" title="对节点node进行定义"></a>对节点node进行定义</h2><pre><code class="hljs plain">\tikzstyle&#123;process&#125; &#x3D; [rectangle,minimum width&#x3D;3cm,minimum height&#x3D;1cm,text centered,text width &#x3D;3cm,draw&#x3D;black,fill&#x3D;orange!30]</code></pre><h3 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h3><pre><code class="hljs plain">rectangle:矩形，可加圆角(rounded corners)trapezium:平行四边形diamond:菱形</code></pre><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><pre><code class="hljs plain">minimum widthminimum height</code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code class="hljs plain">text centered:文本居中</code></pre><h3 id="文本宽度"><a href="#文本宽度" class="headerlink" title="文本宽度"></a>文本宽度</h3><pre><code class="hljs plain">text width&#x3D;3cm:文本超过3cm时会自动换行</code></pre><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><pre><code class="hljs plain">draw</code></pre><h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><pre><code class="hljs plain">fill</code></pre><h2 id="对箭头进行定义"><a href="#对箭头进行定义" class="headerlink" title="对箭头进行定义"></a>对箭头进行定义</h2><pre><code>tikzstyle{arrow} = [thick,-&gt;,&gt;=stealth]</code></pre><h3 id="线粗"><a href="#线粗" class="headerlink" title="线粗"></a>线粗</h3><pre><code>thick:粗thin:细</code></pre><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><pre><code>-&gt;:反向箭头&lt;-:正向箭头&lt;-&gt;:双向箭头</code></pre><h3 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h3><pre><code>dashed</code></pre><h3 id="箭头形状"><a href="#箭头形状" class="headerlink" title="箭头形状"></a>箭头形状</h3><pre><code>&gt;=stealth</code></pre><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><pre><code>\node (decision1) [decision,below of=process1,yshift=-0.5cm] {Decession 1};</code></pre><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><pre><code>(decision1):这个节点的name，后面需要用这个name调用这个节点。</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>decision：需要调用的节点的属性</code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><pre><code>below of=process1：定义节点的位置left of:right of:</code></pre><h3 id="偏移-对位置进行微调"><a href="#偏移-对位置进行微调" class="headerlink" title="偏移,对位置进行微调"></a>偏移,对位置进行微调</h3><pre><code>yshift:xshift:</code></pre><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><pre><code>{Decession 1}:结果显示的标题</code></pre><h2 id="画箭头"><a href="#画箭头" class="headerlink" title="画箭头"></a>画箭头</h2><pre><code>\draw [arrow] (decision1) -- node[anchor=east] {yes} (process2a);</code></pre><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><pre><code class="hljs [arrow]:需要调用的箭头的属性```">&#96;&#96;&#96;(decision1)：箭头的其实位置</code></pre><pre><code class="hljs (process2a)：箭头的末端位置```">### 线型</code></pre><p>—：直线<br>|-：先竖线后横线<br>-|：向横线后竖线<br><pre><code class="hljs plain">### 文字：如果需要在箭头上添加文字&#96;&#96;&#96;&#123;yes&#125;:需要添加的文字</code></pre></p><h3 id="文字的位置-上南下北左东右西-与地图方位不一致"><a href="#文字的位置-上南下北左东右西-与地图方位不一致" class="headerlink" title="文字的位置,上南下北左东右西(与地图方位不一致)"></a>文字的位置,上南下北左东右西(与地图方位不一致)</h3><pre><code>[anchor=east]：[anchor=south]：[anchor=west]：[anchor=north]：[anchor=center]：</code></pre>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cellular automata</title>
    <link href="/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>元胞自动机(cellular automata，CA) 是一种时间、空间、状态都离散，空间相互作用和时间因果关系为局部的网格动力学<br>模型，具有模拟复杂系统时空演化过程的能</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>元胞自动机是一个空间和状态都是离散的模型。该模型可以用一个四元组表示：</p><script type="math/tex; mode=display">C=(L_a, S, N_n, f)</script><p>其中：</p><ul><li>$S$表示细胞状态，是一个有限的、离散的状态集合；</li><li>$L_a$表示元胞空间，$a$是一个整数，表示细胞空间的维数；</li><li>$N$表示领域内元素的组合，$n$表示邻居的个数</li><li>$f$表示状态转移函数，即状态转移规则</li></ul><h2 id="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。"><a href="#对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。" class="headerlink" title="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元(有时也称作邻居)。"></a>对于一个元胞，在空间位置上与它相邻的元胞称为它的<strong>邻元</strong>(有时也称作邻居)。</h2><p>邻域和邻元的定义可以是多样的</p><p>下图为一维CA网格邻域定义<br><img src="/img/一维CA网格.png" srcset="/img/loading.gif" alt=" "></p><p>下图为二维CA网格邻域定义<br><img src="/img/二维CA网格.png" srcset="/img/loading.gif" alt=" "></p><p>每个元胞有若干个状态，如：</p><ul><li>物理系统：（分子）固态，液态</li><li>生物系统：（细胞）死or活</li><li>社会系统： （个人）相信与不相信谎言</li><li>政治系统： （国家）战争与妥协…</li></ul><hr><p>&emsp;&emsp;在各种CA模型中，每个等份（单元格）代表一个元胞，CA的网格可以有不同的形式(维数，大小)。</p><ul><li>一维的CA模型是将直线分成若干相同的等份；</li><li>二维的CA模型是将一个平面分成许多正方形、六边形或三角行的网格（最常见的是将其划分成正方形）；</li><li>三位的CA模型将空间划分成许多立体网格。</li></ul><p><img src="/img/一维CA模型.png" srcset="/img/loading.gif" alt=" "> &emsp;&emsp; <img src="/img/二维CA模型.png" srcset="/img/loading.gif" alt=" "></p><hr><p>根据每个元胞及邻元的不同状态，由于状态更新规则决定这个元胞下一个时刻的状态。</p><p>序号$i$个体在$t=1,\dots,n$时刻的状态:</p><script type="math/tex; mode=display">S_t^{t+1}=f(S_i^t,N^t)=f(S_i^t,S_1^t,S_2^t,\dots,S_n^t)</script><p>其中$S_i^t,S_1^t,S_2^t,\dots,S_n^t$为个体$i$的邻元在$t$时刻的状态。</p><hr><p>规则可以是确定型的，也可以是随机型的。对于一个一维的CA，一个细胞具有两种可能的状态如生or死，相信或者不相信等等，表示为0or1.<br>如果规则一：我使用下图的左边的邻元定义<br>定义其状态更新规则：当一个个体的两个邻元都活或都死，该个体在下一时刻为死；反之，他的状态在下一时刻变为活。<br><img src="/img/规则表.png" srcset="/img/loading.gif" alt=" "></p><p>再如规则二：我仍然使用当前左边邻元定义，但重新定义其状态<br>更新规则为：当个体的两个邻元都活或都死，该个体再下一时刻<strong>改变状态</strong>;反之，<strong>该个体的状态在下一时刻保持不变</strong>。<br><img src="/img/规则表（2）.png" srcset="/img/loading.gif" alt=" "></p><hr><p>模型的构建</p><p>考虑以下问题：</p><ul><li>确定系统中有那些个体，如何分类？</li><li>个体有几种状态，分别是什么；</li><li>个体所处空间形式，是一位，二维还是多为；</li><li>个体的邻元形式及个数，这与网格形式及交互群体规模有关</li><li>根据个体状态、网格形式及邻元，确定个体状态的演变规则。<br>此外，还需确定：</li><li>系统中的个体与单元格是否一致。<br>简单的、经典的CA模型中，单元格与个体不加区分，每个单位格就是一个个体，个体始终在单元格中，个体的状态即为单元格的状态。但在一些复杂系统中，尤其在个体可以移动的系统中，将个体与单元格区分更为方便。</li><li>系统中是否离散事件。<br>采用CA模型描述的系统，每个时刻都需根据规则确定伟哥元胞的状态。除此之外，有的系统中某些个体会在特定时刻（有条件或无条件）发生状态变化，此时可以采用离散时间仿真方法，将该时刻列入事件表，根据事件表处理该类事件。</li></ul><font color="#f4f4f4"><a href="https://wenku.baidu.com/view/86050cb9aeaad1f347933f28.html" target="_blank" rel="noopener">推荐</a></font><font color="#f4f4f4">python 库中pandas 如果使用 pip install pandas 可以能会无法下载。如果无法下载则使用</font><pre><code class="hljs plain">pip --default-time&#x3D;100 install pandas</code></pre><font color="#f4f4f4">这行命令，可以进行下载。</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力-2</title>
    <link href="/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148814143&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;First a city with a population of 11 million was shut down and than a country of 1.4 billion people came to a halt. Most people have shown concern and understanding. Whenever there is a public health concern, people tend to react strongly, however some have allowed the fear to turn into bias. But sometimes the reaction is over the top. people have effectively closed borders, shouted hateful words and drive others away indiscriminately. Some have called the novel coronavirus the China Virus. We wrongly called the 1918 pandemic the Spanish Flu, and with better knowledge and conscience we never call AIDS or Ebola an African virus, because we don’t want people to associate a pathogen with a place or people, and we shouldn’t.<br>&emsp;&emsp;Coronacirus is feeding bias and discrimination against people, people from Wuhan and China, people across the aisle and in the neighborhood. It is understandable that people are panicking in the face of a big unknown. But we have a rough idea about this virus; it is highly infectious, and not as deadly as SARS. We wash hands, wear masks, keep our hygiene and keep ourselves happy to let the immune system do its work. Draconian isolation policy during the 14-day incubation will help us identify more cases. And hopefully the virus will burn out eventually or its impact will be mitigated when our immune systems with the help of supportive care will win out at last.<br>&emsp;&emsp;But discrimination will take its toll. The disregard of AIDS patients during the 1970s drove them underground and undetected, resulting in a large outbreak. And similar messaging on Ebola<br>made matters worse in 2014 in West Africa. In history we have treated leprosy, AIDS and even flu patients like outcast, partly because we were unable to deal with the disease, but largely because we could not understand the threat. But now we do.<br>&emsp;&emsp;Virus know no boundaries, be it AIDS, the flu SARS or 2019-nCoV. An epidemic of global scale demands the sharing of information, resources and moral support. Quarantines might work for a while, but it won’t last and it won’t solve all problems. We are now in a gigantic prisoner’s dilemma, the incentive to turn against each other is so strong even though banding together works better. Bias hurts your interests, you just don’t know yet.<br>&emsp;&emsp;In our modern, borderless world. We aren’t living in villages anymore. Even though we may pay a price dealing with strangers, we still do and we are better off because of it. </p><p><i>This is the time for facts, not fear. This is the time for science, not rumors. This is the time for solidarity, not stigma.</i><br>$\textbf{Dr.Tedros Adhanom Gheberyesus}—Director-General World Health Organization$</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wget、yum、rpm、apt-get都是啥？</title>
    <link href="/2020/02/27/yum/"/>
    <url>/2020/02/27/yum/</url>
    
    <content type="html"><![CDATA[<p>简略介绍wget、yum、rpm、apt-get。<br>详细了解yum</p><a id="more"></a><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p><strong>wget</strong>:类似于迅雷，是一种<code>下载工具</code>，通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理 名字是World Wide Web”与“get”的结合。</p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><strong>yum</strong>: 是redhat, centos 系统下的<code>软件安装方式</code>，基于Linux,全称为 Yellow dog Updater, Modified,是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器,基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><h3 id="yum常用选项和参数"><a href="#yum常用选项和参数" class="headerlink" title="yum常用选项和参数"></a>yum常用选项和参数</h3><h4 id="列举包文件"><a href="#列举包文件" class="headerlink" title="列举包文件"></a>列举包文件</h4><hr><pre><code class="hljs plain">yum list #列出资源库中所有可以安装或更新的rpm包yum list updates　#列出资源库中所有可以更新的rpm包yum list installed　　#列出已经安装的所有的rpm包yum list extras　　#列出已经安装的但是不包含在官方资源库中的rpm包，例如安装了epel源的rpm包会列出来</code></pre><h4 id="列举资源信息"><a href="#列举资源信息" class="headerlink" title="列举资源信息"></a>列举资源信息</h4><hr><pre><code class="hljs plain">yum info　　#列出资源库中所有可以安装或更新的rpm包的信息yum info perl　　#列出perl包信息yum info perl*　　#列出perl开头的所有包的信息yum info updates　　#列出资源库中所有可以更新的rpm包的信息yum info installed　　#列出已经安装的所有的rpm包的信息yum info extras　　#列出已经安装的但是不包含在资源库中的rpm包的信息</code></pre><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><hr><pre><code class="hljs plain">yum search perl　#搜索匹配特定字符的rpm包，在包名称、包描述等中搜索yum provides libstdc++.so.6　　#反查包含特定文件名的rpm包，查询命令用yum provides *&#x2F;ifconfig，查询文件无需*&#x2F; 也可用yum whatprovides</code></pre><h4 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h4><hr><ul><li>安装rpm包<pre><code class="hljs plain">yum install perl　　#安装perl包yum install perl*　　#安装perl开头的包yum remove perl* 　　#会删除perl* 所有包，以及相关依赖的包</code></pre></li><li>软件组件管理<pre><code class="hljs plain">yum groupinstall &quot;Chinese Support&quot;　　#安装指定的组yum groupupdate &quot;Chinese Support&quot;　　#安装了的组成员软件包更新yum grouplist　　#安装了的组和可以安装的组一览显示yum groupremove &quot;Chinese Support&quot;　　#删除指定的组yum groupinfo &quot;Chinese Support&quot;　　#指定组所包含的软件包显示</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4></li></ul><hr><pre><code class="hljs plain">yum check-update　　#检查可更新的rpm包yum update　　#更新所有的rpm包yum update kernel kernel-source　　#更新指定的rpm包,如更新kernel和kernel sourceyum upgrade　　#大规模的版本升级,与yum update不同的是,连旧的淘汰的包也升级</code></pre><h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><hr><pre><code class="hljs plain">yum clean packages　　#清除暂存中rpm包文件yum clean headers　　#清除暂存中rpm头文件yum clean oldheaders　　#清除暂存中旧的rpm头文件yum clean all　　#清除暂存中旧的rpm头文件和包文件</code></pre><h4 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h4><pre><code class="hljs plain">-q #静默执行-t #忽略错误-R[分钟] #设置等待时间-y #自动应答yes--skip-broken #忽略依赖问题--nogpgcheck #忽略GPG验证</code></pre><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p><code>rpm</code>:软件管理;</p><p>redhat的软件格式 <code>rpm</code>  <code>r=redhat</code>  <code>p=package</code>   <code>m=management</code> 用于安装 卸载 <code>.rpm</code>软件</p><p>串联下：<br>&emsp;&emsp;使用<code>wget</code>下载一个 <code>rpm</code>包, 然后用<code>rpm -ivh xxx.rpm</code> 安装这个软件，嫌麻烦的话，就可以直接用 <code>yum  install  sqoop</code> 来自动下载和安装依赖的 <code>rpm</code>软件。</p><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p><code>apt-get</code>:是ubuntu下的一个软件安装方式，它是基于debain.</p><h2 id="通过yum安装工具"><a href="#通过yum安装工具" class="headerlink" title="通过yum安装工具"></a>通过yum安装工具</h2><h3 id="在Centos上安装gcc"><a href="#在Centos上安装gcc" class="headerlink" title="在Centos上安装gcc"></a>在Centos上安装gcc</h3><p>安装gcc</p><blockquote><p>yum -y install gcc</p></blockquote><p>安装g++</p><blockquote><p>yum -y install gcc-c++  </p></blockquote><h3 id="在Centos上安装目录生成树工具tree"><a href="#在Centos上安装目录生成树工具tree" class="headerlink" title="在Centos上安装目录生成树工具tree"></a>在Centos上安装目录生成树工具tree</h3><p>安装tree</p><blockquote><p>yum -y install tree</p></blockquote><p>同通过tree工具可以很快的查看目录树</p><h4 id="关于tree命令选项"><a href="#关于tree命令选项" class="headerlink" title="关于tree命令选项"></a>关于tree命令选项</h4><ul><li><code>-a</code> 显示所有文件和目录。</li><li><code>-A</code> 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li><li><code>-C</code> 在文件和目录清单加上色彩，便于区分各种类型。</li><li><code>-d</code> 显示目录名称而非内容。</li><li><code>-D</code> 列出文件或目录的更改时间。W</li><li><code>-f</code> 在每个文件或目录之前，显示完整的相对路径名称。</li><li><code>-F</code> 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/”,”=”,”@”,”|”号。</li><li><code>-g</code> 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li><li><code>-i</code> 不以阶梯状列出文件或目录名称。</li><li><code>-I</code>&lt;范本样式&gt; 不显示符合范本样式的文件或目录名称。</li><li><code>-l</code> 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li><li><code>-n</code> 不在文件和目录清单加上色彩。</li><li><code>-N</code> 直接列出文件和目录名称，包括控制字符。</li><li><code>-p</code> 列出权限标示。</li><li><code>-P</code>&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</li><li><code>-q</code> 用”?”号取代控制字符，列出文件和目录名称。</li><li><code>-s</code> 列出文件或目录大小。</li><li><code>-t</code> 用文件和目录的更改时间排序。</li><li><code>-u</code> 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li><li><code>-x</code> 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li></ul><h4 id="在Centos下安装git"><a href="#在Centos下安装git" class="headerlink" title="在Centos下安装git"></a>在Centos下安装git</h4><p>首先检查机器上是否有git</p><blockquote><p>git —version</p></blockquote><p>如果出现了版本号则说明有<code>git</code>，如果是<code>bash：git：no found command</code>则说明没有<code>git</code>。</p><p>如果没有git工具：</p><blockquote><p>yum info git #查看<code>yum</code>源中的<code>git</code>版本<br>yum -y install git #安装git</p></blockquote><p>当出现<code>complete！</code>就表明安装完成</p><h4 id="在Centos下升级vim"><a href="#在Centos下升级vim" class="headerlink" title="在Centos下升级vim"></a>在Centos下升级vim</h4><h5 id="检查机器上是否有vim"><a href="#检查机器上是否有vim" class="headerlink" title="检查机器上是否有vim"></a>检查机器上是否有vim</h5><blockquote><p>rpm -qa|grep vim</p><p>如果以安装则会显示<br>vim-minimal-7.4.629-6.el7.x86_64<br>vim-filesystem-7.4.629-6.el7.x86_64<br>vim-enhanced-7.4.629-6.el7.x86_64<br>vim-common-7.4.629-6.el7.x86_64<br>vim-X11-7.4.629-6.el7.x86_64</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，则执行：<br>yum -y install vim-enhanced</p></blockquote><p>它会自动下载安装。如果上面三个包一个都没有显示，则直接输入命令：   </p><blockquote><p>yum -y install vim*</p></blockquote><h5 id="检查vim版本"><a href="#检查vim版本" class="headerlink" title="检查vim版本"></a>检查vim版本</h5><blockquote><p>vim —version</p></blockquote><p>如果想升级更高版本的vim</p><pre><code>sudo yum remove vim -y # 移除旧版本sudo yum install ncurses-devel python-devel -y # 安装必要组件git clone https://github.com/vim/vim.git  #下载源码编译安装cd vim/src./configure --with-features=huge --enable-pythoninterp=yes --enable-cscope --enable-fontset --with-python-config-dir=/usr/lib64/python2.7/config --enable-python3interp=yes --with-python-config-dir=/usr/lib/python3.6/config --enable-multibyte --prefix=/usr/local/vim/ # 根据自己实际情况设置编译参数make -j2 &amp;&amp; make install</code></pre><h1 id="conda环境"><a href="#conda环境" class="headerlink" title="conda环境"></a>conda环境</h1><h2 id="进入虚拟环境，使用"><a href="#进入虚拟环境，使用" class="headerlink" title="进入虚拟环境，使用"></a>进入虚拟环境，使用</h2><pre><code> $ conda activate spider-venv</code></pre><h2 id="退出虚拟环境，使用"><a href="#退出虚拟环境，使用" class="headerlink" title="退出虚拟环境，使用"></a>退出虚拟环境，使用</h2><pre><code> $ conda deactivate</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Centos</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力</title>
    <link href="/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/"/>
    <url>/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148815381&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" ></iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;It has been a month since Wuhan was <code>locked down</code> because of the <code>coronavirus</code>. Like a big <code>push on</code> a swing, the <code>epidemic</code> <code>tips</code> the balance in the world, and China is making effort to keep standing. The challenge <code>lies in</code> the country’s size, China is a big country with a large span, and the virus hit the center, <code>literally</code>. The <code>epicenter</code> is a <code>metropolis</code> of 16 million people in the middle of the country. To make matters worse, it is surrounded by many cities, also with millions of inhabitants.<br>&emsp;&emsp;Wuhan is a transport hub, and the virus is threatening to infect the whole surrounding area. The size of the country is a significant obstacle. But that’s only half the story. Because of its continental size, all the parts feed off each other. When Wuhan fell, the other provinces came to its aid.<br>&emsp;&emsp;As we speak, one-tenth of the intensive care doctors of the entire country is in Wuhan. A total of 40,000 medical staff moved to the center in a wartime fashion. China plans to take the virus full on.<br>&emsp;&emsp;Structure matters, another weight on scale is messaging. China has two-way traffic of communication, top-down and bottom-up. China is to do better bottom-up. When doctors in Wuhan sounded alarms of the new virus, the message got lost. An investigation is still ongoing on why. But one reason is obvious: there are too many layers, too much red tape, and too little incentives to send the messages up.<br>&emsp;&emsp;But China is strong when it comes to top-down messages. When the leadership is on the top of the problem, it has the willpower and wherewithal to make the call. And the grassroots answer. China launched a people’s war. That was exactly what was needed to deal with a traveling threat like an epidemic. China built two hospitals in 10 days, thousands of wards in a week, and shook the population into action. Top-down is fast and sharp. Nobody should argue against efficiency, especially when what’s at shake is a plague spreading. But keeping the balance is hard.<br>&emsp;&emsp; Every decision is a trade-off when it affects the lives of thousands and the livelihood of millions. We need to slow the spread. Draconian quarantines are being enforced in many parts of the country. Maintain a large network of isolation and a low rate of rogue behavior is the answer; the question is we still don’t know the exact extent of the infection. Isolating the infected while not infringing on people’s rights and decency is not an easy task.<br>&emsp;&emsp;Our economy relies on human transaction, but epidemic control depends on social distancing. We need to keep a distance, and yet we need to work together. So how do we balance saving lives and the saving economy? This is an issue that requires hard decision making. But the hardest is when to draw the line. With so little information on an adversary like the virus and so few weapons at out disposal, without treatment or vaccines, we are not able to answer the public’s question: when does it end?<br>&emsp;&emsp;Before the end of the Second World War, Winston Churchill described the war like this: <code>Victory at all costs, victory in spite of all terror, victory however long and hard the road may be, for without victory, there is no survival. Now, we are at war with a virus. And victory is still ahead of us</code>. Luckily, we still have a big country to fall back on, a world that lifts us, and s system that delivers results. There will be more hard decisions to be made. In the end, we hope those will be the best choices, and we must be proud of them. </p><hr><h3 id="词句"><a href="#词句" class="headerlink" title="词句"></a>词句</h3><ul><li><strong>locked down</strong>:锁定，封锁.</li><li><strong>coronavirus</strong>:n. 冠状病毒.</li><li><strong>push on</strong>: 推， 推进.</li><li><strong>epidemic</strong>: [ˌepɪˈdemɪk] n.流行病;(迅速的)泛滥，蔓延; adj.流行性的;极为盛行的.</li><li><strong>tip</strong>: n.尖端;尖儿;端;(装在顶端的)小部件;指点;实用的提示;</li><li><strong>lie in</strong>: 在于; lie(平躺， 撒谎).</li><li><strong>literally</strong>: adv.按字面;字面上;(强调事实可能令人惊讶)真正地，确实地;(加强即使字面意义并不真实的词语)简直;</li></ul><font size="3" color="#c2cb81"> 若有错误请在评论区指正！蟹蟹大家</font>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器</title>
    <link href="/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/"/>
    <url>/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/</url>
    
    <content type="html"><![CDATA[<p>容器简介</p><a id="more"></a><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="概述"><a href="#概述" class="headerlink" title="- 概述"></a>- 概述</h3><ul><li>Vector是一个能够存放任意类型的动态数组</li><li>Vector的数据结构和操作与数组(array)类似，在内存中的表现形式是一段地址连续的空间</li><li>Vector与数组的区别在于，数组大小往往是定义是固定的(比如：char buffer[256]);Vec支持动态空间大小调整，随着空间的变化Vector内部会自动扩充内存空间</li><li>为了试用Vector，必须试用include指令包含该头文件,并通过std空间去访问：<pre><code class="hljs plain">include &lt;vector&gt;int main() &#123;    std :: vector v;&#125;</code></pre></li></ul><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空vector</td><td>std :: vector<T> v;</td></tr><tr><td>创建一个容器是n的T类型的vector</td><td>std :: vector<T> v(n);</td></tr><tr><td>创建一个容量是n的T类型的vector，并且都初始化为i</td><td>std :: vector<T> n(n, i);</td></tr><tr><td>创建一个已有v的拷贝</td><td>std :: vector<T> copyOfV(v);</td></tr><tr><td>荣国一个数组创建一个vector</td><td>int array[] = {1,2,3}; std :: vector<int> v(array, array + 10);</td></tr></tbody></table></div><h3 id="向vector添加元素"><a href="#向vector添加元素" class="headerlink" title="向vector添加元素"></a>向vector添加元素</h3><p>向vector添加元素的方法为调用其push_back()函数，表示将元素添加至其尾部：<br><pre><code class="hljs plain">std :: vector &lt;std :: wstring&gt; v3;for (std :: size_t i &#x3D; 0; i &lt; 10; ++ i) &#123;    std :: wstringstream wss;    wss &lt;&lt; TEXT(&quot;String[&quot;) &lt;&lt; i &lt;&lt; TEXT(&quot;]&quot;);    v3.push_back(wss.str());&#125;</code></pre></p><h3 id="判断vector是否为空、获取vector大小"><a href="#判断vector是否为空、获取vector大小" class="headerlink" title="判断vector是否为空、获取vector大小"></a>判断vector是否为空、获取vector大小</h3><ul><li>如果要判断vector是否为空则调用empty()函数</li><li>如果要获取vector大小则调用size()函数<pre><code class="hljs plain">std :: vector &lt;std :: wstring&gt; v3;bool isEmpty &#x3D; v3.empty();int array[] &#x3D; &#123;1,2,3,4,5,6,7,8,9,10&#125;;std :: vector&lt;int&gt; v(array, array + 10)std :: size vSize &#x3D; v.size();</code></pre></li></ul><h3 id="访问vector中元素"><a href="#访问vector中元素" class="headerlink" title="访问vector中元素"></a>访问vector中元素</h3><ul><li>要访问vector中的元素, 有两种方法：<ul><li>调用vector :: at()</li><li>调用vector :: operator[]</li></ul></li><li>两者的区别在于：<ul><li>operator[]提供了类似数组的存取方式，但不做边界的检查，有可能越界，但访问效率更高</li><li>at()进行边界检查，如果访问越界则抛出exception，但是访问效率不如operator[]</li></ul></li></ul><pre><code class="hljs plain">std :: vector&lt;std::wstring&gt; v;v.reserve(10);for (std::size_t i &#x3D; 0; i &lt; 3; ++ i) &#123;    std :: wstringstream wss;    wss &lt;&lt; TEXT(&quot;String[&quot;) &lt;&lt; i &lt;&lt; TEXT(&quot;]&quot;);    v.push_back(wss.str());&#125;try &#123;    std :: wstring wsz1 &#x3D; v[5]; &#x2F;&#x2F; not bounds checked -will not throw    std :: wstring wsz2 &#x3D; v.at(5); &#x2F;&#x2F; bounds checked -will throw if out of range&#125;catch (const std :: exception&amp; ex) &#123;    Console :: WriteLine(ex.what());&#125;</code></pre><h3 id="删除vector中的元素"><a href="#删除vector中的元素" class="headerlink" title="删除vector中的元素"></a>删除vector中的元素</h3><ul><li>clear：清除一整个vector</li><li>pop_back：弹出vector为元素</li><li>erase:删除vector中某一位置的元素<ul><li>用法一：指定iterator删除某一元素<pre><code class="hljs plain">std :: vector&lt;int&gt; :: const_iterator it &#x3D; v.begin();v.erase(it + 1); &#x2F;&#x2F; erase the second element in the Vector</code></pre></li><li>用法二：通过某一条件函数找到vector中需要删除的元素。所谓条件函数是一个按照用户定义的条件返回true/false的函数对象。我们以remove_if为例说明。</li><li>remove_if函数定义在algorithm中，故需要include<algorithm></li><li>定义筛选器：一个一元函数对象(unary_function),关键在于重载operator()<pre><code class="hljs plain">struct ContainsString : public std :: unary_function &lt;std :: wstring, bool&gt; &#123;    ContainsString (const std::wstring&amp; wszMatch) : m_wszMatch(wszMatch) &#123;&#125;    bool operator()(const std :: wstring&amp; wszStringToMatch) const &#123;        &#x2F;&#x2F;注意因为它重载了()所以可以当一个函数来用        return (wszStringToMatch.find(m_wszMatch) !&#x3D; 1);    &#125;    std :: wstring m_wszMatch;&#125;</code></pre></li><li>在erase函数中调用remove_if执行删除:<pre><code class="hljs plain">v.erase (std :: remove_if (    v.begin(),    v.end(),    ContainsString (L&quot;C++&quot;)),  v.end());</code></pre></li><li>remove_if是不是真正remove了vector中的元素呢？<br>remove_if其实真正的做的事针对ContainsString条件对给出了erase函数需要操作的iterator位置。</li></ul></li></ul><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><ul><li>概述<ul><li>Deque事一个能够存放任意类型的双向队列</li><li>Deque提供的函数与vector类似，新增了两个函数：<ul><li>push_front:在头部插入一个元素</li><li>pop_front： 在头部弹出一个元素</li></ul></li><li>Deque采用了与vector不同的内存管理方式：大块分配内存</li><li>为了试用deque，必须用include质量包含如下文件，并通过std命名空间访问：<pre><code class="hljs plain">#include &lt;deque&gt;int main() &#123;    std :: deque dq;&#125;</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li></ul></li><li>概述<ul><li>List是一个能够存放任意类型的双向链表(double linked list)</li><li>可以向List中接入一个子链表(sub-list)</li><li>为了使用List，必须使用include指令包含如下文件，并通过std命名空间去访问：<pre><code class="hljs plain">#include &lt;list&gt;int main() &#123;    std :: list l;&#125;</code></pre></li></ul></li></ul><p>创建List</p><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空list</td><td>std :: list<T> l;</td></tr><tr><td>创建一个容量是n的T类型的list</td><td>std :: list<T> l(n);</td></tr><tr><td>创建一个容量是n的T类型的list，并且初始化都为x</td><td>std :: list<T> l(n, x);</td></tr><tr><td>创建一个已有list的拷贝</td><td>std :: list<T> copyOfList(l);</td></tr><tr><td>通过一个数组创建一个list</td><td>std :: wstring array[] = {1,2,3}; std :: list<std::wstring> l(array, array + 3)</td></tr></tbody></table></div><ul><li>向list添加元素<ul><li>向list添加元素的方式为调用其push_back, push_front函数将元素添加至其尾部或头部</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型编程</title>
    <link href="/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/"/>
    <url>/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/</url>
    
    <content type="html"><![CDATA[<p>泛型编程</p><a id="more"></a><h1 id="泛型编程-概观"><a href="#泛型编程-概观" class="headerlink" title="泛型编程-概观"></a>泛型编程-概观</h1><ul><li>泛型编程(Generic programming) 是一种编程方法，这种方法将类型(type)以一种to-be-specified-later的方式给出，等到需要调用的时候，再以参数方式，通过具体的、特定的类别实例化(instantiate)一个具体的方法或对象</li><li>泛型编程作为一种编程的想法或思想，不依赖具体的语言</li><li>大多数面向对象的语言(O O languages)都支持泛型编程，(只不过在C++种以模板的这种形式表现出来)比如：C++、C#、Java、Ada….</li><li>C++里面的泛型是通过<strong>模板</strong>以及相关性质表现出来</li></ul><h1 id="特性-Traits"><a href="#特性-Traits" class="headerlink" title="特性(Traits)"></a>特性(Traits)</h1><h2 id="什么是traits以及为什么使用traits？"><a href="#什么是traits以及为什么使用traits？" class="headerlink" title="- 什么是traits以及为什么使用traits？"></a>- 什么是traits以及为什么使用traits？</h2><p>  假设给定一个数组，计算数组种所有元素的和：<br>  A[0] | A[1] |…| A[n] &emsp;&emsp;$\sum_{k=0}^n A[k]$</p><ul><li><p>我们可以很直接地写出如下的计算函数:</p><pre><code class="hljs plain">template &lt;typename T&gt; inline T Sigma(const T const* start, const T const* end) &#123;    T total &#x3D; T(); &#x2F;&#x2F; suppose T() actually creates a zero value    &#x2F;&#x2F;T()是一个构造函数目的将total初始化为0；        while (start !&#x3D; end) &#123;        total +&#x3D; *start ++ ;    &#125;    return total;&#125;</code></pre></li><li><p>当我们使用char类型调用模板函数是，问题就来了：</p><pre><code class="hljs plain">char szNames[] &#x3D; &quot;abc&quot;;std :: size_t nLength &#x3D; strlen(szNames);char* p &#x3D; szNames;char* q &#x3D; szNames + nLength;printf(&quot;sigma(ezNames) &#x3D; %d\n&quot;, Sigma(p,q));</code></pre><script type="math/tex; mode=display">294 = 0x0126</script><script type="math/tex; mode=display">0000 | 0001 | 0010 | 0110</script><p>Char类型能hold住的最大值为0xFF = 255 也就是两个字节所以0010和0110可容纳的但是abc加起来<strong>大于255</strong>就溢出到溢出到1这个bit</p></li><li><p>调用Sigma(szNames)的结果是38( = 0x26)!而并不是所期望的值(97 + 98 + 99 = 294)</p></li><li>原因显而易见的：char无法存下这个294这个值</li><li>如果要得到正确的结果，我们就不得不强制使用int类型：<pre><code class="hljs plain">int s &#x3D; Sigma&lt;int&gt;(p,q);</code></pre></li><li>但是这种不必要的转换是完全可以避免的!</li><li>解决方法是：为每个Sigma函数的参数类型T创建一种关联(association)，关联的类别就是用来储存Sigma结果的类型</li><li>这种关联可以看作是类型T的一种特性(characteristic fo the type T),因为sigma函数返回值的类型叫做T的trait</li><li>T与其trait的关系推演如下：<br>T -&gt; association -&gt; characteristic of T -&gt; another type -&gt; trait</li><li>Traits可以实现为模板类，而关联(association)则是针对每个具体类型T的特化。在这个例子里我们将trait命名为SigmaTraits, 叫做traits模板(traits template)</li></ul><p>Traits实现：<br><pre><code class="hljs plain">template &lt;typename T&gt;class SigmaTraits &#123; &#125;;&#x2F;&#x2F;可以人为的将返回的数值边得相对的大template &lt;&gt;class SigmaTraits&lt;char&gt; &#123;public:    typedef int ReturnType;&#125;;template &lt;&gt;class SigmaTraits&lt;short&gt; &#123;public:    typedef int ReturnType;&#125;;template &lt;&gt;class SigmaTraits&lt;int&gt; &#123;public:    typedef long ReturnType;&#125;;template &lt;&gt;class SigmaTraits&lt;unsigned int&gt; &#123;public:    typedef  unsigned long ReturnType;&#125;;template &lt;&gt;class SigmaTraits&lt;float&gt; &#123;public:    typedef double ReturnType;&#125;;</code></pre></p><ul><li>模板类SigmaTraits叫做traits template， 它含有其参数类型T的一个特性(trait), 即ReturnType</li><li><p>现在Sigma函数可以改写成:</p><pre><code class="hljs plain">template &lt;typename T&gt;inline typename SigmaTraits&lt;T&gt; :: ReturnType Sigma (const T const* start, const T const* end) &#123;    typedef typename SigmaTraits&lt;T&gt; :: ReturnType ReturnType;    ReturnType s &#x3D; ReturnType();    while (start !&#x3D; end) &#123;        s +&#x3D; *start ++;    &#125;    return s;&#125;</code></pre></li></ul><h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h1><h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><p>迭代器是指针的泛化(generalization of pointers)</p><ul><li>迭代器本身就是一个对象，指向另外一个(可以被迭代的)对象</li><li>用来迭代一组对象，即如果迭代器指向一组对象种的某个元素，则通过increment以后它就可以指向下组对象中的下一个元素</li></ul><h2 id="在STL中迭代器是容器与算法之前的接口"><a href="#在STL中迭代器是容器与算法之前的接口" class="headerlink" title="在STL中迭代器是容器与算法之前的接口"></a>在STL中迭代器是容器与算法之前的接口</h2><ul><li>算法通常以迭代器作为输入参数</li><li>容器只要提供一种方式，可以让迭代器访问容器中的元素即可</li></ul><h2 id="迭代器的基本思想"><a href="#迭代器的基本思想" class="headerlink" title="迭代器的基本思想"></a>迭代器的基本思想</h2><ul><li>在STL中，迭代器最终要的思想就是分离算法和容器，使之不需要相互依赖</li><li><p>迭代器将算法和容器粘合(stick)在一起从而使得一种算法的实现可以运用到多种不同的容器上，如下面的例子,find算法接受一对迭代器，分别指向容器的开始位置和最终位置</p><pre><code class="hljs plain">template &lt;typename _InIt, typename _Ty&gt;inline _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val) &#123;    &#x2F;&#x2F;find first matching _Val    for (; _First !&#x3D; _Last; ++_First) &#123;        if (*_First &#x3D;&#x3D; _Val)          break;    &#125;    return (_First);&#125;</code></pre><p>find算法对于不同的容器，比如vector, list, deque均适用：</p><pre><code class="hljs plain">std :: vector&lt;int&gt; v(...);std :: list&lt;int&gt; l(...);std :: deque&lt;int&gt; d(...);std :: vector&lt;int&gt; :: iterator itv &#x3D; std :: find(v.begin(), v.end(), elementToFind)std :: list&lt;int&gt; :: iterator itl &#x3D; std :: find(l.begin(), l.end(), elementToFind)std :: deque&lt;int&gt; :: iterator it3 &#x3D; std :: find(d.begin(), d.end(), elementToFind)</code></pre><p>每种容器都有其对应的迭代器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类模板与操作符重载</title>
    <link href="/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-类模板"><a href="#C-类模板" class="headerlink" title="C++类模板"></a>C++类模板</h1><ul><li>与函数模板类似， 类页可以通过参数泛化，从而可以构建出一族不同类型的类实例</li><li>类模板参数可以是某一类型或常量（仅限int或者enum）</li></ul><p>一个类模板的例子：Stack<T><br><pre><code class="hljs plain">const std::size_t DefaultStackSize &#x3D; 1024;template &lt;typename T, std::size_t n &#x3D; DefaultStackSize&gt;class Stack &#123;public:    void Push(const T const&amp; element);    int Pop(T&amp; element);    int Top(T&amp; element) const;private:    std::vector&lt;T&gt; m_Members;    std::size_t m_nMaxSize &#x3D; n;&#125;;</code></pre></p><ul><li>T可以是任意类别</li><li>模板实参也可以是一个int或enum的常量(此处是size_t, 本质是int类型)</li><li>n是编译时定义的常量</li><li>n可以有默认值</li><li>size_t类别的成员变量可以用n初始化</li></ul><h2 id="类模板的声明"><a href="#类模板的声明" class="headerlink" title="- 类模板的声明"></a>- 类模板的声明</h2><ul><li>声明类模板与申明函数模板类似</li><li><p>关键字class和typename都可以用，但是还是更倾向于去使用typename</p><pre><code class="hljs plain">template &lt;typename T, std::size_t n&gt; class Stack&#123;...&#125;template &lt;class T, std::size_t n&gt; class Stack&#123;...&#125;</code></pre></li><li><p>在类模板内部，T可以像其他函数类别一样(比如int , char等)定义成员变量和成员函数</p><pre><code class="hljs plain">void Push(const T const&amp; element)int Pop(T&amp; element);int Top(T&amp; element) const;std::vector&lt;T&gt; m_Members;</code></pre></li><li>除了Copy constructor 之外，如果在类模板中需要使用到这个类本身，比如定义operator，那么就应该医用其完整的定义(Stack<T,n>)而不是省略类别T。<pre><code class="hljs plain">template &lt;typename T, std::size_t n&gt;class Stack&#123;  public:      ...      Stack (Stack&lt;T,n&gt; const&amp;); &#x2F;&#x2F;copy constructor      Stack&lt;T&gt;&amp; operator &#x3D; (Stack&lt;T,n&gt; const&amp;); &#x2F;&#x2F; assignment operator      ...&#125;</code></pre></li></ul><h2 id="类模板的实现"><a href="#类模板的实现" class="headerlink" title="- 类模板的实现"></a>- 类模板的实现</h2><ul><li><p>要定义一个类模板的成员函数，则要指明其是一个模板函数</p><p>Push函数：</p><pre><code class="hljs plain">template &lt;typename T, std::size_t nMaxSize&gt;void Stack&lt;T, nMaxSize&gt; :: Push(const T const&amp; element) &#123;    if (m_Members.size() &gt;&#x3D; m_nMaxSize) &#123;        &#x2F;&#x2F; error handing...        return ;    &#125;    m_Members.push_back(element);&#125;</code></pre><p>Pop函数：</p><pre><code class="hljs plain">template &lt;typename T, std :: size_t nMaxSize&gt;int Stack&lt;T, nMaxSize&gt; :: Pop(T&amp; element) &#123;    if (m_Members.empty()) &#123;        return 0;    &#125;    element &#x3D; m_Members.back(); &#x2F;&#x2F; we have to first store the back element    m_Members.pop_back(); &#x2F;&#x2F; because pop_back of a vector removes    return 1; &#x2F;&#x2F; the last element but doesn&#39;t return it&#125;</code></pre><p>Top函数：</p><pre><code class="hljs plain">template &lt;typename T, std :: size_t nMaxSize&gt;int Stack&lt;T, nMaxSize&gt; :: Top(T&amp; element) const &#123;    if (m_Members.empty()) &#123;        return 0;    &#125;    element &#x3D; m_Members.back();    return 1;&#125;</code></pre></li></ul><h2 id="使用类模板"><a href="#使用类模板" class="headerlink" title="- 使用类模板"></a>- 使用类模板</h2><ul><li>Stack<int> stack：定义了一类型为int的Stack， 大小为默认值</li><li>Stack<int, 100> stack：定义了一个类型为int, 大小为100的Stack</li><li>将100个元素Push到Stack中<pre><code class="hljs plain">for (int i &#x3D; 0; i &lt; 100; ++ i) &#123;    stack.Push(i);&#125;</code></pre></li><li>Pop出Stack顶部元素:<pre><code class="hljs plain">int elementstack.Pop(element);</code></pre></li><li>获取Stack顶部元素:<pre><code class="hljs plain">stack.Top(element);</code></pre></li><li>Stack的stack定义:<pre><code class="hljs plain">Stack&lt;Stack&lt;int&gt; &gt;intStackStack; &#x2F;&#x2F; 最右边要加一个空格Stack&lt;Stack&lt;int&gt;&gt; intStackStack; &#x2F;&#x2F; ERROR: &gt;&gt; is not allowed</code></pre></li></ul><h2 id="类模板特化-specializations"><a href="#类模板特化-specializations" class="headerlink" title="- 类模板特化(specializations)"></a>- 类模板特化(specializations)</h2><ul><li>允许对一个类模板的某些模板参数类型做特化</li><li>特化的作用或好处在于：<ul><li>对于某种特殊的类别，可能可以做些特别的优化或提供不同的实现</li><li>避免在实例化类的时候引起一些可能产生的诡异行为</li></ul></li><li>特化一个类模板的时候也意味着需要特化其所有参数的成员的类型</li><li>如果要特化一个类，那么做法为：<ul><li>声明一个带template&lt;&gt;的类， 即空参数列表</li><li>在类名后紧跟的尖括号中显式指明类别，例如： <pre><code class="hljs plain">template&lt;&gt;class Stack&lt;std::wstring&gt; &#123;&#125;</code></pre></li></ul></li><li>特化后的具体体现可以和柱模板的实现不一样，比如以下的特化增加了一个成员函数，并采用list作元素存取的实现<pre><code class="hljs plain">template &lt;&gt;class Stack &lt;std :: wstring&gt; &#123;  public:      void SetStackStack(const std :: size_t n) &#123;m_nMaxSize &#x3D; n;&#125;      &#x2F;&#x2F; 添加一个新的成员函数      std :: size_t CurrentSize() const &#123;return m_Members.size();&#125;      void Push(const std :: wstring const&amp; element);      int Pop(std :: wstring const&amp; element);      int Top(std :: wstring const&amp; element) const;  private:      std :: size_t m_nMaxSize;      std :: list &lt;std :: wstring&gt; m_Members;      &#x2F;&#x2F;采用list作为Stack的内部实现，取代了主模板中用vector实现的方式&#125;;</code></pre></li></ul><h2 id="偏特化-Partial-specialization"><a href="#偏特化-Partial-specialization" class="headerlink" title="- 偏特化(Partial specialization)"></a>- 偏特化(Partial specialization)</h2><p>….不做了解，中间会产生二义性…晚点再说。</p><h2 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="- 默认模板实参"></a>- 默认模板实参</h2><ul><li>类似函数的默认参数，对于类模板而言也可以定义其模板参数的默认值，这些值就叫做<strong>默认模板参数</strong><pre><code class="hljs plain">template &lt;typename T, typename TContainer &#x3D; std :: vector&lt;T&gt;&gt;class Stack &#123;    private : TContainer m_Container;&#125;</code></pre></li><li>Stack<int> intStack: 使用默认的vector作为实参</li><li>Stack<std :: wstring, std :: list <std :: wstring> &gt; wstrStack: 指定使用list作为容器而非默认的vector</li></ul><h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><ul><li>关键字operator定义了一种特殊的函数，该函数的行为是将操作符应用用于某一特定的类型，使之能能够通过该操作符进行操作。如果定义了string类型的operator + ，那么连接两个字符串a和b的行为就可以用a+b进行操作</li><li>操作符重载给出了操作符的不同含义</li><li>编译器通过具体类别来识别某个操作符在该类型上的意义</li><li>本质上operator重载就是函数，即如果定义了string类型的Append函数，那么string类型的a+b和a.Append(b)是等价的</li></ul><h2 id="操作符重载的一般规则"><a href="#操作符重载的一般规则" class="headerlink" title="- 操作符重载的一般规则"></a>- 操作符重载的一般规则</h2><ul><li>不可以用operator定义一种新的操作符，比如<em>* ,因为没有两个</em>的操作符</li><li>对于内置类别(built-in type)， 不能再用operator重载</li><li>操作符重载的两种情况：<ul><li>静态成员函数</li><li>静态全局函数(如果该全集函数需要访问类的private或protected成员，则必须声明为friend成员)<pre><code class="hljs plain">class ComplexType &#123;    public:       &#x2F;&#x2F;non-static member      ComplexType operator &lt; (ComplexType&amp; );      &#x2F;&#x2F;global functions      friend ComplexType operator + (int, ComplexType&amp; );&#125;</code></pre></li><li>一元操作符(Unary operators)如果声明为成员函数，则没有参数。如果声明为全局函数则有一个参数</li><li>二元操作符(Binary operator)如果声明为成员函数，则有一个参数。如果声明为全局函数，则有两个参数</li><li>如果一个操作符技能够用作一元操作，又能用作二元操作(&amp;, *, +, -)，则可以分别被重载</li><li>操作符不能带有默认参数</li><li>除了operator = ，所又其他操作符重载均可以被子类继承</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板观念与函数模板</title>
    <link href="/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-模板简介"><a href="#C-模板简介" class="headerlink" title="C++模板简介"></a>C++模板简介</h1><ul><li>模板(Templates)是C++的一种特性，允许函数或类通过泛型(generic types)的形式表现或运行</li><li>模板可以使得函数或类在因对不同类别(types)的时候可以正常工作，而无需为每个类型都写一份代码</li></ul><ul><li>一个简单的例子：<ul><li>如果要写一个取两个数中较大的函数Max，在不适用模板的情况下，我们不得不针对不同的类别(eg: int long char…)提供一种类别的重载</li></ul></li></ul><p>int 型<br><pre><code class="hljs plain">int Max(int a, int b) &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></p><p>long型<br><pre><code class="hljs plain">long Max(long a, long b) &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></p><p>char型<br><pre><code class="hljs plain">char Max(char a, char b) &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></p><ul><li><p>一个简单的例子</p><ul><li><p>如果使用模板，则可以省去一堆代码，从而将代码原型缩减到非常简介的表达：</p><pre><code class="hljs plain">template &lt;typename T&gt; T Max(T a, T b) &#123;    return (a &gt; b) ? a : b;&#125;</code></pre></li></ul></li><li><p>C++ 主要有两种类型的模板：</p><ul><li>类模板(Class template):使用泛型参数的类(classes with generic parameters)</li><li>函数模板(Function template):使用泛型参数的函数(Functions with generic parameters)</li></ul></li><li><p>模板实例化</p><ul><li>模板的声明(declaration)其实并未给出一个函数或类的完全定义(definition)，只是提供了一个函数或类的语法框架(syntactical skeleton)</li><li><p>实例化时指从模板够检出一个真正的函数或类的过程，比如：</p>   <pre><code class="hljs plain">        template &lt;typename T&gt;        struct Object&#123;....&#125;        &#96;&#96;&#96;              - 可以用来构建诸如Object&lt;int&gt;, Object&lt;char&gt;, Object&lt;int*&gt;, Object&lt;MyClass*&gt;等等不同类别的具体实例- 实例化有两种类型：  - **显式**实例化-在代码中明确指定要正对哪位类别进行实例化  - **隐式**实例化-在首次使用时根据具体情况一种合适的型别惊醒实例化  ## C++函数模板- 什么时函数模板？  - **函数模板**是参数化的一族函数(a family of functions)  - 通过函数模板，可以定义一系列函数，这些函数都是基于同一代码，但是可以用作在不同类别的参数上</code></pre><p>template <typename T><br>inline T Max(const T&amp; a, const T&amp; b) {<br>return (a &gt; b) ? a : b;<br>}</p><pre><code class="hljs plain">- 定义函数模板  - 定义一个函数模板，反水数中较大一个，该函数有两个参数：(a,b)  - 参数类别未定，以模板参数T表示  - 模板参数由关键字typename引入  - 也可以使用class代替typename来定义类型参数  - 从语法上讲使用class和使用typename没有区别  - 单从语义上，class可能会导致误区，即只有类才能作为类别参数；而事实上T所以表达的意思不仅仅只针对类，任何类别都可以  - 参数推导  - 模板参数是有传递给模板函数的实参所决定的  - 不允许自动类型转换：每个T必须严格匹配</code></pre><p>Max(1, 2) //两次实参的类型都是int<br>Max(1, 2.0) //ERROR：第一参数的类别是int第二参数类别是double</p><pre><code class="hljs plain">- 一般有两种处理这种错误的方法：   1. 用static_cast&lt;double&gt;或者强制转换参数类型以使两者匹配</code></pre><p>Max(static_cast<double>(1),2.0)</p><pre><code class="hljs plain">1. 显示指定T的类别</code></pre><p>Max<double>(1, 2.0)</p><pre><code class="hljs plain">- 函数模板重载  - 函数模板也可以像普通函数一样被重载  - 非模板函数可以和**同名**的模板函数共存  - 编译器同通过函数模板参数推导来决定使用调用哪个函数</code></pre><p>inline int const&amp; Max(const int const&amp; a, const int const&amp; b)</p></li></ul><p>template <typename T><br>inline T const&amp; Max(const T const&amp; a, T const&amp; b)</p><p>template <typename T><br>inline T const&amp; Max(const T const&amp; a, T const&amp; b, const T const&amp; c)<br>```</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>堆的种类有很多这里我们讨论的时最大堆和最小堆</p><a id="more"></a><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>严格来说，堆也有不同种类。这是一种叫做二叉堆的数据结构，堆就是下图这样的二叉树。<br><img src="/img/堆的例子.png" srcset="/img/loading.gif" alt=""></p><p>最小堆的性质是儿子的值一定不小于父亲的值。而最大堆的性质则于其相反儿子的值一定更不大于父亲的值。<br>除此之外，树的节点时按从上到下、从左到右的顺序紧凑排列的。</p><p><img src="/img/插入数值.png" srcset="/img/loading.gif" alt=""><br>如上图所示，在向堆中插入数值时，首先在堆的末尾插入该数值，然后不断向上提升直到没有大小颠倒为止。</p><p><img src="/img/取出最小值.png" srcset="/img/loading.gif" alt=""><br>如上图所示，从队中删除最小值时，首先把堆的最后一个节点的数值复制到根节点上，并且删除最后一个结点。然后不断向下<br>交换直到没有大小颠倒为止。在向下交换的过程中，如果有两个儿子，那么选择数值较小的儿子（如果儿子比自己小的话）进行交换。</p><h2 id="堆的操作的复杂度"><a href="#堆的操作的复杂度" class="headerlink" title="堆的操作的复杂度"></a>堆的操作的复杂度</h2><p>堆的两种操作所花的时间都和数的深度成正比。因此，如果一共有$n$个元素，那么每个操作就可以在$O(log_n)$的时间内完成。</p><h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><p>注意:</p><ul><li>左儿子的编号是自己的编号 $×2+1$</li><li>右儿子的编号是自己的编号 $×2+2$</li></ul><pre><code class="hljs plain">const int N &#x3D; 10000;int heap[N], sz;void push(int x) &#123;    &#x2F;&#x2F;自己节点的编号    int i &#x3D; sz ++;        while(i &gt; 0) &#123;        &#x2F;&#x2F; 父亲结点的编号        int p &#x3D; (i &#x3D; 1) &gt;&gt; 2;        &#x2F;&#x2F;如果已经没有大小颠倒则退出        if (heap[p] &lt;&#x3D; x) break;        &#x2F;&#x2F;父亲节点的数值放下来，而把自己提上去        heap[i] &#x3D; heap[p];        i &#x3D; p;    &#125;    heap[i] &#x3D; x;&#125;int pop() &#123;    &#x2F;&#x2F;最小值    int ret &#x3D; heap[0];    &#x2F;&#x2F;要提到根的数值    int x &#x3D; heap[--sz];    &#x2F;&#x2F;从根开始向下交换    int i &#x3D; 0;    while ((i &lt;&lt; 2) + 1 &lt; sz) &#123;        &#x2F;&#x2F;比较儿子的值        int a &#x3D; i * 2 + 1, b &#x3D; i * 2 + 2;        if (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a &#x3D; b;        &#x2F;&#x2F;如果已经没有大小颠倒则退出        if (heap[a] &gt;&#x3D; x) break;        &#x2F;&#x2F;把儿子的数值提上来        heap[i] &#x3D; heap[a];        i &#x3D; a;    &#125;    heap[i] &#x3D; x;    return ret;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 mcm/icm LaTeX写作</title>
    <link href="/2020/02/15/mcm-icm/"/>
    <url>/2020/02/15/mcm-icm/</url>
    
    <content type="html"><![CDATA[<p>mcm/icm 2020新版美赛$\LaTeX$模板 </p><a id="more"></a><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>&emsp;&emsp;2020年因为武汉疫情的原因，原定于2月14日的mcm/icm比赛采用了两个时间两次给的方式，今天上午我也看了一下题，D题的数据相对比较好搜集，作为一名游戏玩家，我觉得可以从EA的FIFA球员数据库种收取数据。虽然说我的建模能力很垃圾啊。但是搜集数据和LaTeX的写作是我能给我们这个团队做出贡献的方式。所以我就做一些利索能及的事就对了。</p><h2 id="说说LaTeX"><a href="#说说LaTeX" class="headerlink" title="说说LaTeX"></a>说说LaTeX</h2><p>&emsp;&emsp;LaTeX是我开始学习写markdown的时候就了解的一种排版方式，寒假这段时间我也好好学习了一下。<br>一开始觉得美赛要不要用word写但是想到要插入公式，解决排版问题使用LaTeX还是方便的多。因为在比赛之前我也尝试自己<br>按照之前获奖文章自己做一个美赛模板。</p><p><img src="/img/mcm_model_1.png" srcset="/img/loading.gif" alt=""></p><p>但是在比赛之前听过2020年的比赛写作排版有变动，一开始还有点慌。然后今天上官网看了一下。发现官方给了一个模板<br><img src="/img/mcm_code.png" srcset="/img/loading.gif" alt=""><br>我一开始还以为是一个.tex文件谁知道，是这个…</p><p>我运行了一下就是这个效果（我注明一下，我把红色字体改成了黑色）</p><p><img src="/img/mcm_model.png" srcset="/img/loading.gif" alt=""></p><p>效果还不错，嘿嘿。感觉这个还专门给了一个模板，可能是为了要人们知道今年的变化吧。但是我觉得应该是因为大多数中国学生，撰写论文的格式都不标准，所以今年专门给了一个word和LaTeX模板来共大家用。统一一下格式，让看论文的老师也能好看一点。</p><p>自习看了一下模板里面内容，注释也很清楚。生怕学生不会用。一开始我还在想怎么加一个content，谁知人家这个模板很贴心，已经将目录给你写好了。（只不过是注释掉了）</p><p><img src="/img/content.png" srcset="/img/loading.gif" alt=""></p><p>2020和2019版的模板我也分享给大家，有需自戳。</p><ul style:"color=#336699"><li><a href="/temp/mcm-icm2020模板.zip" download="2020mcm-icm模板">2020</a></li><li><a href="/temp/mcm-icm2019模板.zip" download="2019mcm-icm模板">2019</a></li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(完全背包)</title>
    <link href="/2020/02/14/%E8%83%8C%E5%8C%85_1/"/>
    <url>/2020/02/14/%E8%83%8C%E5%8C%85_1/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题:完全背包问题</p><a id="more"></a><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href = "http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(01背包)</title>
    <link href="/2020/02/10/%E8%83%8C%E5%8C%85/"/>
    <url>/2020/02/10/%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题：01背包问题</p><a id="more"></a><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0 &lt; N$, $V \leq 1000$</p><p>$0 &lt; v_i$, $w_i \leq 1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例</strong></p><pre><code>8</code></pre><p>S</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>&emsp;&emsp;这是最基础的背包问题，特点是：<font color = #f278>每种物品仅有一件，可以选择放或不放。</font></p><h5 id="用子问题定义状态："><a href="#用子问题定义状态：" class="headerlink" title="用子问题定义状态："></a>用子问题定义状态：</h5><p>即$f[i][v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p><script type="math/tex; mode=display">f[i][v] = max \begin{cases}    f[i-1][j] \\    f[i-1][j-c[i]] + w[i]\end{cases}</script><p>&emsp;&emsp;这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f=[i-1][v-c[i]]$再加上通过放入第$i$件物品获得的价值$w[i]$。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href="http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/" target="_blank" rel="noopener">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL队列</title>
    <link href="/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>STL队列简述</p><a id="more"></a><h1 id="STL中队列-queue-的使用方法"><a href="#STL中队列-queue-的使用方法" class="headerlink" title="STL中队列(queue)的使用方法"></a><font color="#f278">STL中队列(queue)的使用方法</font></h1><h3 id="STL中队列的使用方法-queue"><a href="#STL中队列的使用方法-queue" class="headerlink" title="STL中队列的使用方法(queue)"></a><font style="text-align: 'center'">STL中队列的使用方法(queue)</font></h3><p>基本操作：</p><ul><li>push(x) 将x压入队列的末端</li><li>pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值</li><li>front() 返回第一个元素(队顶元素)</li><li>back() 返回最后被压入的元素(队尾元素)</li><li>empty() 当队列为空时，返回true</li><li>size() 返回队列的长度</li></ul><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p> 声明方法：<br>1、普通声明</p><pre><code>queue&lt;int&gt;q;</code></pre><p>2、结构体</p><pre><code>struct node{    int x, y;};queue&lt;node&gt;q;</code></pre><h3 id="STL-中优先队列的使用方法-priority-queue"><a href="#STL-中优先队列的使用方法-priority-queue" class="headerlink" title="STL 中优先队列的使用方法(priority_queue)"></a>STL 中<font color="#f278">优先队列</font>的使用方法(priority_queue)</h3><p>&emsp;&emsp;优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大互小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p><p>基本操作：</p><ul><li><p>empty() 如果队列为空返回真</p></li><li><p>pop() 删除对顶元素</p></li><li><p>push() 加入一个元素</p></li><li><p>size() 返回优先队列中拥有的元素个数</p></li><li><p>top() 返回优先队列对顶元素</p></li></ul><p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p>声明方式：</p><p>1、普通方法：<br>    priority_queue<int>q;   //通过操作，按照元素从大到小的顺序出队<br>    priority_queue<int,vector<int>, greater<int> &gt;q;  //通过操作，按照元素从小到大的顺序出队</p><p>2、自定义优先级：</p><pre><code>struct cmp {     　　operator bool ()(int x, int y)     　　{        　　　　 return　x &gt; y; // x小的优先级高               //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高　　}};priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;    //定义方法//其中，第二个参数为容器类型。第三个参数为比较函数。</code></pre><p>3、结构体声明方式：</p><pre><code>struct node {     　　int x, y;     　　friend bool operator &lt; (node a, node b)     　　{         　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高     　　}};priority_queue&lt;node&gt;q;   //定义方法//在该结构中，y为值, x为优先级。//通过自定义operator&lt;操作符来比较元素中的优先级。//在重载“&lt;”时，最好不要重载“&gt;”，可能会发生编译错误</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拯救公主</title>
    <link href="/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/"/>
    <url>/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<p>BFS训练题</p><a id="more"></a><h2 id="拯救公主"><a href="#拯救公主" class="headerlink" title="拯救公主"></a>拯救公主</h2><p>公主被恶人抓走，被关押在牢房的某个地方。牢房用 $ N \times M (N, M \le 200)N×M(N,M\le200) $ 的矩阵来表示。矩阵中的每项可以代表道路（@）、墙壁（#）、和守卫（x）。</p><p>英勇的骑士（r）决定孤身一人去拯救公主（a）。我们假设拯救成功的表示是 “骑士到达了公主所在的位置”。由于在通往公主所在位置的道路中可能遇到守卫，骑士一旦遇到守卫，必须杀死守卫才能继续前进。</p><p>现假设骑士可以向上、下、左、右四个方向移动，每移动一个位置需要 11 个单位时间，杀死一个守卫需要花费额外的 11 个单位时间。同时假设骑士足够强壮，有能力杀死所有的守卫。</p><p>给定牢房矩阵，公主、骑士和守卫在矩阵中的位置，请你计算拯救行动成功需要花费最短时间。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>1、两个整数代表 $N$ 和 $M, (N, M \le 200)M,(N,M\le200)$.<br>2、随后 $N$ 行，每行有 $M$ 个字符。”@” 代表道路，”a” 代表公主，”r” 代表骑士，”x” 代表守卫, “#” 代表墙壁。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果拯救行动成功，输出一个整数，表示行动的最短时间。<br>如果不可能成功，输出 “Impossible”。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h3><pre><code>7 8#@#####@#@a#@@r@#@@#x@@@@@#@@#@##@@@##@@@#@@@@@@@@@@@@@@</code></pre><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h3><pre><code>13</code></pre><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h3><pre><code>13 40@x@@##x@#x@x#xxxx##@#x@x@@#x#@#x#@@x@#@xxx###x@x#@@##xx@@@#@x@@#x@xxx@@#x@#x@@x@#@x#@x#x#@@##@@x#@xx#xxx@@x##@@@#@x@@x@x@##x@@@x#xx#@@#xxxx#@@x@x@#@x@@@x@#@#x@#@#xxxxx##@@x##x@xxx@@#x@x####@@@x#x##@#@#xxx#@#x##xxxx@@#xx@@@x@xxx#@#xxx@x######x@xxxx#@x@@@@##@x#xx#xxx@#xx#@#####x#@xxx##@#@x##x##x#@x#@a#xx@##@#@##xx@#@@x@xx#x#@x@#x#@##@xrx@x#xxxx@##x##xx#@#x@xx@#x@@#@###x##x@x#@@#@@x@x@@xx@@@@##@@x@@xx#xx@x###@xxx#@#x#@@###@#@##@x#@x@#@@#@@#@#x@x#x#x###@x@@xxx####x@x##@x####xx#@x#x#@x#x######@@#x@#xxxx#xx@@@#xx#x#####@</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>7</code></pre><h3 id="ans"><a href="#ans" class="headerlink" title="ans"></a>ans</h3><pre><code>//ac#include &lt;bits/stdc++.h&gt;using namespace std;char maze[205][205];bool vis[205][205];int dir[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};int n, m;struct node {    int x;    int y;    int d;    node(int xx, int yy, int dd) : x(xx), y(yy), d(dd) {}    friend bool operator &lt; (node a, node b) {        return a.d &gt; b.d;    }};int bfs(int x, int y) {    priority_queue&lt;node&gt; q;    vis[x][y] = true;    q.push(node(x, y, 0));    while(!q.empty()) {        node now = q.top();        q.pop();        for (int i = 0; i &lt; 4; ++i) {            int tx = now.x + dir[i][0];            int ty = now.y + dir[i][1];            if (0 &gt; tx || tx &gt;= n || 0 &gt; ty || ty &gt;= m || maze[tx][ty] == &#39;#&#39; || vis[tx][ty])            continue;            if (maze[tx][ty] == &#39;a&#39;) {                return now.d + 1;            }            else if (maze[tx][ty] == &#39;x&#39;) {                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 2));            }            else{                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 1));            }        }    }    return -1;}int main(){    freopen(&quot;note.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;ans.txt&quot;, &quot;w&quot;, stdout);    int i, j;    int ans = -1;    cin &gt;&gt; n &gt;&gt; m;    for (i = 0; i &lt; n; ++i) {        cin &gt;&gt; maze[i];    }    for (i = 0; i &lt; n; ++i) {        for (j = 0; j &lt; m; ++j) {            if (maze[i][j] == &#39;r&#39;){                break;            }        }        if (maze[i][j] == &#39;r&#39;) break;    }    ans = bfs(i, j);    if (ans == -1) {        cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl;    }    else{        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>&emsp;&emsp;这个题目的棋盘范围超过了100也就是说使用dfs算法是非常危险的方法，因为dfs的时间复杂度为 $O(2^n)$ 而bfs的时间复杂度为$O(M*N)$所以使用dfs是会为超时的。</p><p>&emsp;&emsp;所以弃用dfs是必须的，一般再求最少问题时一般都是采用dfs算法使用。但是我们注意这个棋盘的范围超过了100。对于bfs来说<br>空间复杂度问题就显现的比较明显。如果采用一般的队列方式来存储帮助bfs的实现，时肯定不行的。此时就要记住。一般这种情况下求极值问题要求优化，我们就采用用<strong>优先队列</strong>的方法。来进行优化。其实质上对空间复杂度的优化就是对时间复杂度的优化。要不断使用最优秀的数据结构来解决时间于内存上的算法优化问题。</p><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踏青</title>
    <link href="/2020/01/26/%E8%B8%8F%E9%9D%92/"/>
    <url>/2020/01/26/%E8%B8%8F%E9%9D%92/</url>
    
    <content type="html"><![CDATA[<p>DFS训练题</p><a id="more"></a><hr><p>垃圾桶和他的朋友周末相约去召唤师峡谷踏青。他们发现召唤师峡谷的地图是由一块块格子组成的，有的格子上是草丛，有的是空地。草丛通过上下左右四个方向扩展到其他草丛形成一片草地，任何一片草地中的格子都是草丛，并且所有格子之间都能通过上下左右连通。如果用’#’代表草丛，’.’表示空地，下图的峡谷有<strong>2</strong>片草地</p><pre><code>##....##</code></pre><p>处在同一个草地的<strong>2</strong>个人可以相互看到，空地看不到草地里面的人。他们发现有一个朋友不见了，现在需要分头去找，每个人负责一片草地，垃圾桶想知道他们至少需要多少人。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入 $n,m$ $(1 \le n, m \le 100)$ 表示峡谷大小。</p><p>接下来输入 $m$ 行字符串表示峡谷的地形。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输出至少需要多少个人。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5 6.#......#.....#..#...##..#....</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>5</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>DFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(7)</title>
    <link href="/2020/01/21/python_ex40/"/>
    <url>/2020/01/21/python_ex40/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是组织好的、可重复使用得、用来实现单一或相关联功能的代码。在程序中，函数的使用能提高应用的模块性、代码的重用旅和可读性。</p><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(6)</title>
    <link href="/2020/01/20/python_ex39/"/>
    <url>/2020/01/20/python_ex39/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h3 id="3-修改列表元素"><a href="#3-修改列表元素" class="headerlink" title="3.修改列表元素"></a>3.修改列表元素</h3><p>列表创建之后，可以对列表中单个元素或指定范围元素(切片)进行修改，方法是：</p><ol><li>list[index] = newValue: 对指定索引index的列表元素进行修改</li><li><p>list[::] = newList: 对指定方位的列表元素进行修改</p><pre><code> list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;] list[0] = &quot;eee&quot; print(&quot;list:&quot;,list) list[1:3] = [&quot;ggg&quot;,&quot;kkk&quot;] print(&quot;list:&quot;,list)</code></pre></li></ol><p>4.删除列表元素<br>列表创建后，可以根据需要使用列表函数，del语句或切片和删除指定袁术或所有元素。</p><ol><li>del list[index]: 删除索引为index元素</li><li>list.pop(): 删除列表末尾的元素。</li><li>list.pop(index): 删除索引的元素。</li><li>list.remove(item): 删除列表元素item。</li><li>list.clear(): 删除列表中所有元素。</li><li>list[::] = []: 对指定范围的列表元素进行</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    #del list[3]    #list.pop()    #list.pop(0)    #list.remove(&quot;aaa&quot;)    #list.clear()    #list[2:3] = []    print(&quot;list:&quot;,list)</code></pre><p>list.remove(item)<br><img src="/img/list.remove.png" srcset="/img/loading.gif" alt=" "></p><p>list.clear()<br><img src="/img/list.clear.png" srcset="/img/loading.gif" alt=" "></p><p>list[::] = []<br><img src="/img/list[].png" srcset="/img/loading.gif" alt=" "></p><h2 id="列表复制和删除"><a href="#列表复制和删除" class="headerlink" title="列表复制和删除"></a>列表复制和删除</h2><h3 id="1-列表复制"><a href="#1-列表复制" class="headerlink" title="1.列表复制"></a>1.列表复制</h3><p>列表复制有两种方法。</p><ol><li>list_copy = list.copy(): 列表浅复制。当列表list改变时，list_copy中的元素不会随之变化。</li><li>list_copy = list: 列表复制。当列表list改变时，list_copy中的元素也会随之改变。</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    list_copy = list.copy()    print(&quot;list:&quot;,list)    print(&quot;list_copy:&quot;,list_copy)</code></pre><p><img src="/img/list.copy.png" srcset="/img/loading.gif" alt=" "></p><h3 id="2-列表删除"><a href="#2-列表删除" class="headerlink" title="2.列表删除"></a>2.列表删除</h3><p>当列表不再使用后，可以使用del语句删除列表，其一般格式：</p><pre><code>del 列表名</code></pre><p>del 可以索引删除也可以全部删除</p><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    del list    print(&quot;list:&quot;,list)</code></pre><p><img src="/img/del.png" srcset="/img/loading.gif" alt=" "></p><h2 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h2><ol><li>+: 将多个列表组合成一个新的列表，新列表中的元素是多个元素的有序组合。</li><li>*: 将整数n和列表相乘可以得到一个将原列表重复n次的新列表。</li><li>in: 用于判断给定对象是否再列表中，如果再则返回True：否则返回False</li><li>not in: 用于判断给定对象是否不在列表中，如果不在则返回True；否则返回False</li><li>关系运算符：两个列表可以使用&lt;,&gt;等关系运算进行比较操作，其规则是从两个列表的第1个元素开始比较，如果比较有结果就结束；否则继续继续比较两个列表后面对应位置的元素。</li></ol><h2 id="列表统计"><a href="#列表统计" class="headerlink" title="列表统计"></a>列表统计</h2><p>列表统计函数：</p><ol><li>len(list): 返回列表list中的元素个数</li><li>max(list): 返回列表list中元素的最大值</li><li>min(list): 返回列表list中元素的最小值</li><li>sum(list): 返回列表list中所有元素的和</li><li>list.count(key): 返回关键字key在列表中出现的次数</li></ol><h2 id="列表元素查找和排序"><a href="#列表元素查找和排序" class="headerlink" title="列表元素查找和排序"></a>列表元素查找和排序</h2><h3 id="1-列表元素查找"><a href="#1-列表元素查找" class="headerlink" title="1.列表元素查找"></a>1.列表元素查找</h3><p>list.index()函数用于查找并返回关键字在列表中第1次出现的位置，其一般格式为：</p><pre><code>list.index(key)</code></pre><p>其中，key为要在列表中查找的元素。</p><h3 id="2-列表元素的排序"><a href="#2-列表元素的排序" class="headerlink" title="2.列表元素的排序"></a>2.列表元素的排序</h3><p>列表创建后，可以使用一下函数更具关键字对列表中的元素进行排序、倒序或临时排序。</p><ol><li>list.sort(): 对列表中的元素按照一定的规则进行排序</li><li>list.reverse(): 对列表list中的元素按照一定的规则反向排序</li><li>sorted(list): 对列表list中的元素进行临时排序，返回副本。但是原列表中的元素次序不变</li></ol><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(5)</title>
    <link href="/2020/01/19/python_ex38/"/>
    <url>/2020/01/19/python_ex38/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表(list)是写在方括号[]之间、用于逗号隔开的元素集合。<br>列表中的元素可以是零个或多个。只有零个元素的列表称为空列表[]。<br>列表中的元素可以相同。例如：</p><pre><code>[&quot;c/c++&quot;,&quot;Python&quot;,&quot;Java&quot;]</code></pre><p>该列表中的个元素均不同。</p><pre><code>[1,1,2,3,4]</code></pre><p>该列表中有重复元素。</p><p>列表中的元素可以类型相同，如[2,4,6,8];也可以是类型不同，如列表[“Rose”,”Female”,18];还可以是复杂的数据类型，如列表[(1,0),(0,1)]</p><p>同字符串类似，列表支持元素的双向索引，正向第1个元素的索引是0，第2个元素的索引是1，以此类推。反向最后1个元素的索引是-1，倒数第2个元素的索引是-2，以此类推。</p><h2 id="列表创建"><a href="#列表创建" class="headerlink" title="列表创建"></a>列表创建</h2><p>通常使用[]运算符或list()函数创建列表。</p><h3 id="1-使用-运算符"><a href="#1-使用-运算符" class="headerlink" title="1.使用[]运算符"></a>1.使用[]运算符</h3><p>使用[]运算符创建列表的一般格式为：</p><pre><code>列表名 = [元素1, 元素2, 元素3, ....]</code></pre><p>其中列表中的元素可以是相同类型或不同类型，简单数据或组合数据。</p><pre><code>list1 = []list2 = [1, 2, 3.2]list3 = [&quot;石油&quot;,&quot;汽车&quot;,&quot;建筑&quot;,&quot;IT&quot;]list4 = [&#39;Alice&#39;,18,&#39;Beth&#39;,19]</code></pre><h3 id="2-使用list-函数创建列表"><a href="#2-使用list-函数创建列表" class="headerlink" title="2.使用list()函数创建列表"></a>2.使用list()函数创建列表</h3><p>使用内置函数list()创建列表的一般格式为:</p><pre><code>列表名 = list(sequence)</code></pre><p>其中，sequence可以是字符串、元组、结合或range()函数返回结果等迭代对象</p><h2 id="列表访问"><a href="#列表访问" class="headerlink" title="列表访问"></a>列表访问</h2><h3 id="1-访问列表"><a href="#1-访问列表" class="headerlink" title="1.访问列表"></a>1.访问列表</h3><p>(1)访问列表及元素<br>可以使用列表名访问整个列表，也可以通过list[index]访问索引为index的元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]print(&quot;carlist[2]:&quot;,carlist[2])print(&quot;carlist[-1]:&quot;,carlist[-1])</code></pre><p>(2)列表切片<br>Python支持使用切片访问列表指定范围的元素,语法格式为:</p><pre><code>arr[index_start:index_end:step]</code></pre><p>注意结束是指在结束的数字前的一个数字结束。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;carlist[2:5]:&quot;,carlist[2:5])print(&quot;carlist[2:5:2]:&quot;,carlist[2:5:2])</code></pre><p>(3)遍历列表<br>可以使用for语句遍历列表，即逐个访问列表中的每个元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;print:&quot;,end = &#39; &#39;)for car in carlist:    print(car,end = &#39; &#39;)</code></pre><h3 id="2-添加列表元素"><a href="#2-添加列表元素" class="headerlink" title="2.添加列表元素"></a>2.添加列表元素</h3><p>列表创建后，可以使用列表函数或切片为列表添加新的元素。</p><ol><li>list.append(newItem): 在列表末尾添加新的元素newItem。</li><li>list.insert(index,newItem):在列表末尾添加新元素newItem。</li><li>list.extend(seq):在列表末尾添加迭代对象seq中的所有元素作为列表新元素。</li><li>list.[len(list):] = newList:使用切片在列表list末尾添加新元素(newList中的元素)</li></ol><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]#carlist.append(&quot;ggg&quot;)#carlist.insert(2,&quot;ggg&quot;)#carlist.extend([&quot;yyy&quot;,&quot;ggg&quot;])carlist[6:] = [&quot;iii&quot;,&quot;ggg&quot;] print(carlist)</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly" target="_blank" rel="noopener">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(4)</title>
    <link href="/2020/01/18/python_ex37/"/>
    <url>/2020/01/18/python_ex37/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h2><p>条件运算相当于一个二分支结构语句的功能，包含三个表达式，其一般格式为：</p><pre><code>表达式1 if 表达式 else 表达式2</code></pre><p>条件运算的执行过程是：如果if后面的表达式值为True，则以表达式1的值为条件运算的结构；<br>否则，以表达式2的值为条件运算的结果。<br>可以将整个条件运算作为一个表达式，出现在其他表达式中。</p><pre><code>score = int(input(&quot;Please enter:&quot;))flag = &quot;ok&quot; if score &gt;= 60 else &quot;no&quot;print(&quot;score: &quot;,flag)</code></pre><p><img src="/img/条件运算.png" srcset="/img/loading.gif" alt=" "></p><p>但是我们要注意表达式1与if之间不能加换行。</p><h2 id="选择结构嵌套"><a href="#选择结构嵌套" class="headerlink" title="选择结构嵌套"></a>选择结构嵌套</h2><p>当在一个选择结构中需要进一步的条件选择时，可以在if语句中再嵌套使用if语句，形成选择结构嵌套以实现相应功能。</p><pre><code>a = 3; b = 2; c = 4if a &gt; b:    if a &gt; c:        print(&quot;最大的数是：&quot;, a)    else:        print(&quot;最大的数是：&quot;, c)else:    if b &gt; c:        print(&quot;最大的数是: &quot;, b)    else:        print(&quot;最大的数是: &quot;, c)</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构依据某一条件反复执行某段程序，即语句块。该语句块被执行的次数称为循环次数。</p><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句用于循环执行一段程序，即再满足某种条件的情况下循环执行某段程序，以处理需要重复处理的<br>相同任务。while语句的一般格式为：</p><pre><code>while 表达式：   语句块[else：   else 子句语句块]</code></pre><p>while语句执行过程：如果表达式的值为True，则执行while后面的语句块；否则，执行else子语句语句块，结束循环。其中else子句为可选。</p><p>while语句</p><pre><code>n = 100sum = 0i = 1while i &lt;= n:    sum = sum + i    i += 1print(&quot;1到%d之和为: %d.&quot; % (n,sum))</code></pre><p>while-else语句</p><pre><code>mu1 = 1; i = 1; sum = 0while i &lt;= 10:    mu1 = mu1 * i    sum = sum + mu1    i = i + 1else:    print(&quot;循环结束!&quot;)print(&quot;sum =&quot;, sum)</code></pre><h3 id="while语句块中的input-函数"><a href="#while语句块中的input-函数" class="headerlink" title="while语句块中的input()函数"></a>while语句块中的input()函数</h3><p>while语句常常和input()函数结合使用，给变量循环输入数据，进行相应的处理。</p><pre><code>total = 0; ave = 0; count = 0score = int(input(&quot;请输入学生英语成绩: &quot;))print(&quot;输入&#39;-1&#39;结束输入\n&quot;)while score != -1:    total = total + score    count = count + 1    score = int(input(&quot;请输入学生英语成绩: &quot;))ave = total / countprint(&quot;录入学生英语成绩%d份,学生英语总成绩%d，平均成绩%4.2f.&quot; % (count, total, ave))</code></pre><p><img src="/img/while-input.png" srcset="/img/loading.gif" alt=" "><br>注意:%4.2f是值精度为2宽度为4。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句更合适循环访问系列或迭代对象(如字符串、列表、元组、字典等))中的元素，其一般格式：</p><pre><code>for 变量 in 序列或迭代对象：    语句块[else:    else 子句语句块]</code></pre><p>for语句执行过程是:当序列或迭代对象中的元素没有遍历完毕时，执行for语句中的语句块：<br>否则，执行else子句中的语句块，结束循环，其中，else子句时可选的。</p><pre><code>for letter in &#39;python&#39;:    print(letter, end=&#39; &#39;)print() #起到换行作用chemists = [&#39;道尔顿&#39;,&#39;门捷列夫&#39;,&#39;拉瓦锡&#39;,&#39;诺贝尔&#39;]print(&quot;化学家:&quot;,end=&#39; &#39;)for hxj in chemists:    print(hxj, end=&#39; &#39;)</code></pre><p><img src="/img/for.png" srcset="/img/loading.gif" alt=" "></p><p>一般情况下else子句是可选选项，可以做为在循环遍历结束之后给出提示信息。</p><h3 id="for语句中的range-函数"><a href="#for语句中的range-函数" class="headerlink" title="for语句中的range()函数"></a>for语句中的range()函数</h3><p>range()函数经常用在for循环中，用于控制循环次数。</p><pre><code>universities = [&#39;哈弗大学&#39;,&#39;斯坦福大学&#39;,&#39;剑桥大学&#39;,&#39;麻省理工学院&#39;,&#39;加州大学&#39;,&#39;普林斯顿大学&#39;,&#39;牛津大学&#39;,&#39;哥伦比亚大学&#39;,&#39;加州理工学院&#39;,&#39;芝加哥大学&#39;]print(&quot;2017《Times》世界大学排名前三的大学是：&quot;)for i in range(3):    print(str(i+1) + &quot;.&quot;, universities[i])</code></pre><h3 id="break-continue和pass语句"><a href="#break-continue和pass语句" class="headerlink" title="break,continue和pass语句"></a>break,continue和pass语句</h3><p>break语句用于退出循环，continue语句用于跳过该次循环,pass时空语句(不做任何处理)</p><h2 id="循环结构的嵌套"><a href="#循环结构的嵌套" class="headerlink" title="循环结构的嵌套"></a>循环结构的嵌套</h2><p>在一个循环结构的循环体内出现另一个循环结构，称为循环结构的嵌套。</p><pre><code>for i in range(1,6):    for j in range(i):        print(&quot;*&quot;, end=&#39; &#39;)    print() #该print是属于  第一层循环</code></pre><p><img src="/img/for-for.png" srcset="/img/loading.gif" alt=" "></p><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly" target="_blank" rel="noopener">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(3)</title>
    <link href="/2020/01/17/python_ex36/"/>
    <url>/2020/01/17/python_ex36/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><p>单分支结构可用if单分支语句实现，其一般格式为：</p><pre><code>if表达式:    语句块</code></pre><p>语句的执行过程是：如果表达式的值为True，则执行语句中的语句块；否则，直接执行if语句的后续语句。</p><p>注意：</p><ol><li>if语句中的语句块可以包含单个语句，也可以包含多个语句。</li><li>如果语句块中只有一跳语句，也可以将整个if语句写在同一行中</li></ol><pre><code>    n = int(input(&quot;请输入一个整数: &quot;))    flag = str(n) + &quot; 是偶数!&quot;    if n % 2 != 0:        flag = str(n) + &quot; 是偶数!&quot;    print(flag)</code></pre><p><img src="/img/if.png" srcset="/img/loading.gif" alt=" "></p><ul><li><p>str() 函数将对象转化为适于人阅读的形式，就是把对象转换成字符串</p><pre><code>  class str(object=&#39;&#39;)</code></pre></li><li><p>object — 对象。</p></li></ul><h2 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h2><p>二分支结构可用if二分支语句实现，其一般格式为：</p><pre><code>if 表达式：    语句块1else：    语句块2</code></pre><p>语句执行过程是：如果表达式的值为True时，则执行语句块1；否则，执行语句块2</p><pre><code>a = 5b = 6print(&quot;a = %d, b = %d&quot; % (a,b))if a &gt; b:    max = aelse:     max = bprint(max)</code></pre><p><img src="/img/if-else.png" srcset="/img/loading.gif" alt=" "></p><h2 id="多分枝结构"><a href="#多分枝结构" class="headerlink" title="多分枝结构"></a>多分枝结构</h2><p>二分支结构只能根据条件的True和False决定处理两个分支中的一个。当实际处理的问题有多种条件时，就要用到多分支结构。<br>多分支结构可用if多分支语句实现，其一般格式为：</p><pre><code>if 表达式1：    语句块1elif 表达式2：    语句块2    ...[else:    语句块n+1]</code></pre><p>if多分支语句根据不同的表达式值确定执行哪个语句块，测试条件的顺序为表达式1，表达式2，…。一旦<br>遇到表达式的值为True，则执行该条件下的语句块，然后执行if语句的后续语句。</p><pre><code>score = int(input(&quot;请输入成绩:&quot;))if score &gt;= 90:    print(&quot;成绩等级:优秀！&quot;)elif score &gt;= 80:    print(&quot;成绩等级：良好！&quot;)elif score &gt;= 60:    print(&quot;成绩等级：不合格！&quot;)</code></pre><p><img src="/img/elif.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(2)</title>
    <link href="/2020/01/16/python_ex35/"/>
    <url>/2020/01/16/python_ex35/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><p>filter()函数用于过滤掉不符合条件的元素，返回一个迭代器对象，一般格式为：</p><pre><code>filter(function,iterable)</code></pre><p>其中，function为半段函数，iterable为可迭代对象。</p><pre><code>def IsEvenFunc(n):    return n % 2 == 0a = list(filter(IsEvenFunc,[1,2,3,4,5]))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/filter.png" srcset="/img/loading.gif" alt=" "></p><h2 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a>zip()函数</h2><p>zip()函数接收任意多个可迭代对象作为参数，将对象种对应的元素打包成一个<strong>元组</strong>，然后返回一个可迭代的zip对象<br>如果可迭代对象的长度不相同，取最短的可迭代对象的长度</p><pre><code>zip([iterable,...])</code></pre><p>其中,iterable为一个或多个迭代器。</p><pre><code>a = list(zip([&quot;泰山&quot;,&quot;黄山&quot;,&quot;庐山&quot;,&quot;华山&quot;],[&quot;山东&quot;,&quot;安徽&quot;,&quot;江西&quot;,&quot;陕西&quot;])) #打包print(&quot;a: &quot;,a)z = zip([1,2,3],[4,5,6]) #打包a = list(zip(*z)) #解包print(&quot;a: &quot;,a)</code></pre><p><img src="/img/zip.png" srcset="/img/loading.gif" alt=" "></p><p>zip(*z)是解包，但是要注意我们不能先迭代z然后再去解包</p><h2 id="枚举函数enumerate"><a href="#枚举函数enumerate" class="headerlink" title="枚举函数enumerate()"></a>枚举函数enumerate()</h2><p>枚举函数enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标。</p><pre><code>enumerate(sequence,[strat = 0])</code></pre><p>其中，sequence: 一个序列，迭代器或其他支持的迭代对象。<br>start: 下表其实位置，可选。</p><pre><code>weeks = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;,&#39;saturday&#39;]a = list(enumerate(weeks))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/enumerate.png" srcset="/img/loading.gif" alt=" "></p><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p>map()函数把函数依此映射到序列或迭代器对象的每个元素上，并返回一个可迭代的map对象作为结果.</p><pre><code>map(function,iterable,....)</code></pre><p>其中，function为被调用的函数,iterable为一个或多个序列</p><pre><code>def cube(x):    return x ** 3a = list(map(cube,[1,2,3,4,5,6])) #计算列表中的各个元素的立方和print(&quot;a: &quot;,a)def add(x, y):    return x + ya = list(map(add,[1,2,3,4,5],[1,2,3,4,5])) #两个列表中相同位置的元素相加print(&quot;a: &quot;,a)a,b = map(int, input(&quot;请输入两个数(用空格隔开):&quot;).split())print(&quot;a = %d, b = %d.&quot;%(a,b))</code></pre><p><img src="/img/map.png" srcset="/img/loading.gif" alt=" "></p><ul><li>我们注意到使用了一个函数 input().split()其中split()可以接收键盘输入的两个数字。</li></ul><p>split()函数的原型为：</p><pre><code>    str1.split(str2=&quot; &quot;,num=string.count(str))</code></pre><p>str1 : 表示为字符串<br>str2 : 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。<br>num : 分割次数。默认为 -1, 即分隔所有。</p><h2 id="逻辑运算符和逻辑运算表达式"><a href="#逻辑运算符和逻辑运算表达式" class="headerlink" title="逻辑运算符和逻辑运算表达式"></a>逻辑运算符和逻辑运算表达式</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>名称</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑“与”</td><td>x and y</td><td>x为True或非0，返回y；否则返回x</td></tr><tr><td>or</td><td>逻辑“或”</td><td>x or y</td><td>x为True或非0，返回x；否则返回y</td></tr><tr><td>not</td><td>逻辑“非”</td><td>not x</td><td>x为True或非0，返回False；否则返回True</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>in</td><td>判断对象是否在序列中</td><td>obj sequence</td><td>obj 在 sequence中返回True，否则返回False</td></tr><tr><td>not in</td><td>判断对象是否不在序列中</td><td>obj not int sequence</td><td>obj 不在sequence中返回True，否则返回False</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(1)</title>
    <link href="/2020/01/15/python_ex34/"/>
    <url>/2020/01/15/python_ex34/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>编程语言都先从最基本的基本语法开始</p><h2 id="type-and-isinstance-函数"><a href="#type-and-isinstance-函数" class="headerlink" title="type() and isinstance() 函数"></a>type() and isinstance() 函数</h2><p>type(object): 接收一个对象object来作为参数， 返回这个参数的数据类型<br>isinstance(object, class): 判断接收的对象object是否是给定的类型class的对象：如果是就返回True,如果不是返回False.</p><p>type(object):</p><pre><code>m = 120print(&quot;m Type: &quot;, type(m))m = &quot;大数据&quot;print(&quot;m Type: &quot;, type(m))</code></pre><p><img src="/img/type.png" srcset="/img/loading.gif" alt=" "></p><p>isinstance(object, class):</p><pre><code>a = 20print(&quot;a是整型么？&quot;, isinstance(a, int))</code></pre><p><img src="/img/isinstance.png" srcset="/img/loading.gif" alt=" "></p><p>在判断一个对象类型时，type() 和 isinstance()有一点区别：</p><ol><li>type()不会认为子类对象时一种父类类型，不考虑继承关系，也就是说type()只检测当前该数据的数据类型</li><li>isinstance()会认为子类队形时一种父类类型，会考虑继承关系，也就是说如果该数据时类的话isinstance()会<br>检测父类的数据类型</li></ol><h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><p>eval()函数用来执行一个字符串表达式，并返回表达式的值，其一般格式为：</p><pre><code>eval(expression[,globals[,locals]])</code></pre><p>其中，expression为表达式。globals为变量作用域，可选，必须是一个字典对象。locals为变量作用域，可选，可以是任何映射(map)对象</p><pre><code>a = eval(&#39;2 + 3&#39;)print(&quot;a: &quot;, a)a, b = eval(input(&quot;请输入两个数(用&#39;,&#39;隔开): &quot;))print(&quot;a: &quot;, a)print(&quot;b: &quot;, b)</code></pre><h2 id="简单了解位运算符"><a href="#简单了解位运算符" class="headerlink" title="简单了解位运算符"></a>简单了解位运算符</h2><p>使用’^’运算对字符加密和解密</p><pre><code>key = input(&quot;请输入加密密匙：&quot;)enc = input(&quot;请输入要加密的字符: &quot;)dec = ord(key) ^ ord(enc)print(&quot;加密结果:&quot;,chr(dec))enc = ord(key) ^ decprint(&quot;解密结果:&quot;,chr(enc))</code></pre><p>1<a href="/img/加密.png"> </a></p><p>在这段程序中我们看到了两个函数ord()和chr():</p><ul><li>ord()函数是对输入的字符转换成ASCII码</li><li>chr()函数是对输入的ASCII码(可以是十进制、十六进制)转换成对应的字符</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker的基本操作</title>
    <link href="/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在Linux运维中我们经常会用到docker，docker通过丰富的镜像软件可以为我们的服务操作带来方便</p><a id="more"></a><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>&emsp;&emsp;首先Docker要求CentOS系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本是否支持安装docker。<br>如果内核版本过低就更新一下系统内核</p><pre><code>yum update</code></pre><p>然后安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>设置yum源：</p><pre><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><img src="/img/docker操作_6.png" srcset="/img/loading.gif" alt=" "></p><p>我们可以查看所有仓库中所有docker版本，并选择特定版本安装：</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p><img src="/img/docker操作_5.png" srcset="/img/loading.gif" alt=" "></p><p>做好这些前提准备之后我们就可以安装docker了</p><pre><code>sudo yum install docker-ce-17.12.0.ce</code></pre><p>启动、设置开启开机启动</p><pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre><p>完成上面的操作后验证安装是否成功(有client和service两部分表示docker安装启动都成功了):</p><pre><code>docker version</code></pre><p><img src="/img/docker操作_4.png" srcset="/img/loading.gif" alt=" "></p><p>查看docker启动状态：</p><pre><code>systemctl status docker</code></pre><p><img src="/img/docker操作_3.png" srcset="/img/loading.gif" alt=" "></p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>查询docker安装过的包：<br><img src="/img/docker操作_2.png" srcset="/img/loading.gif" alt=""></p><p>删除安装包：</p><pre><code>yum remove docker-ce.x86_64 ddocker-ce-cli.x86_64 -y</code></pre><p>删除镜像/容器等:</p><pre><code>rm -rf /var/lib/docker</code></pre><h2 id="然后我们还可可以删除容器的方法："><a href="#然后我们还可可以删除容器的方法：" class="headerlink" title="然后我们还可可以删除容器的方法："></a>然后我们还可可以删除容器的方法：</h2><ul><li><p>先停止运行的容器：</p><pre><code class="hljs plain">docker container stop [container-id]</code></pre></li><li><p>然后删除容器：</p></li></ul><pre><code class="hljs plain">docker container rm [container-id]</code></pre><ul><li>最后删除镜像：<pre><code class="hljs plain">docker image rmi [image-id]</code></pre></li></ul><p>获取对应的 id 可以通过命令：<strong>docker container ls</strong>和 <strong>docker image ls</strong>。<br><img src="/img/docker操作_1.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装图床的时可能遇见的问题</title>
    <link href="/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>当你有个人服务器的时候就可以把你的图片存在服务器上，这样就方便以后的存取，这事搭建图床时会遇见的问题。</p><a id="more"></a><h2 id="docker可能遇见的问题"><a href="#docker可能遇见的问题" class="headerlink" title="docker可能遇见的问题"></a>docker可能遇见的问题</h2><p>安装docker时使用在Liunx中使用Docker, 注: Liunx使用的是在虚拟机下的centOS7版本<br>在刚开始安装Docker时没有任何错误, 但是在后续的docker启动过程中, 出现以下问题:</p><pre><code>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>分析一下问题：</p><ol><li>首先查看了一下内核版本</li><li>因为使用命令: yum install docker下载时, 默认下载的是Docker的最新版本, 但是内核版本低的话可能不兼容新版本Docker, 所以有可能出现如上错误</li></ol><p>解决方法：</p><p><strong>步骤一:将以前下载好的Docker卸载干净, 使用如下命令:</strong></p><pre><code>yum remove docker-*</code></pre><p><strong>步骤二:更新该Liunx系统的内核版本,使用如下命令:</strong></p><pre><code>yum update</code></pre><p>建议更新完之后, 重启一下系统</p><p><strong>步骤三:继续下载安装docker(尽量使用高级管理员权限下载)使用如下命令</strong></p><pre><code>yum install docker</code></pre><p><strong>步骤四:使用如下命令启动docker</strong></p><pre><code>sudo systemctl start docker</code></pre><p>问题解决!<br>注：如果这样安装完之后还报错, 按照这个步骤再来一遍即可</p><p><strong>如果使用docker命令时出现如下错误:</strong></p><pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>第一个原因可能是因为docker没有启动<br>第二个原因就是因为docker出现错误<br>归根结底都是docker启动问题, 解决方案还是以上步骤</p><p>22端口是使用的是nginx的服务器<br>80是浏览器的默认端口<br>443端口我设置成图床服务的端口</p><h2 id="Centos-下-nginx-没有-sites-enabled-文件夹问题"><a href="#Centos-下-nginx-没有-sites-enabled-文件夹问题" class="headerlink" title="Centos 下 nginx 没有 sites-enabled 文件夹问题"></a>Centos 下 nginx 没有 sites-enabled 文件夹问题</h2><p>可能是Centos都会遇见的问题解决方法为：<br>编辑 /etc/nginx/nginx.conf 在 http block 中添加：</p><pre><code>include /etc/nginx/sites-enabled/*;</code></pre><p>然后再/etc/nginx 目录下自己创建一个sites-enabled文件夹就好了<br>最后别忘记了重启nginx服务</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo博客搭建到服务器上</title>
    <link href="/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将hexo 博客搭建到github是一件十分简单得事情，但是在GitHub page中使用你得博客时难免会遇见速度慢、域名不宜与他人分享等等问题，所以当你准备把你网站搭建到服务时就可能遇见很多问题，那我就给大家分享我得在搭建时得心得。</p><a id="more"></a><h1 id="服务器准备阶段"><a href="#服务器准备阶段" class="headerlink" title="服务器准备阶段"></a>服务器准备阶段</h1><p>&emsp;&emsp;国内的服务器有很多，阿里云、百度云、腾讯云、牛七云等等。这些服务器都是大厂的旗下的服务器，所以稳定性还是可以保证的，我选择的是阿里云的学生版一年114元。一核2G的内存价格还是很良心的，如果你想要更低的价格，那某宝应该有适合你的选择。一般国内的互联网公司使用的服务器操作系统主要是Centos。选择Centos作为操作系统即可。当你购买服务之后，阿里会给你一个内网和外网的地址。外网地址就是我们使用浏览器可以查询到的地址，也是我们后面会主要使用到的地址。当然IP地址是不容易记住的我们需要购买一下域名，阿里云很方面都是一站式的。然后就是网站的备案，如果你网站使用的是国内的服务器，是需要备案的，如果你不备案，你的网站时无法访问的。备案的时间时比较长的过程和程序也相对比较麻烦。在这里大家注意一点就是，如果你的备案地址写的是你的学校，那么你就要将你的地址精确到你寝室的楼栋和房间号。</p><p><img src="/img/服务器.png" srcset="/img/loading.gif" alt=" "></p><h1 id="第一步在服务器上安装nginx"><a href="#第一步在服务器上安装nginx" class="headerlink" title="第一步在服务器上安装nginx"></a>第一步在服务器上安装nginx</h1><h2 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h2><p>&emsp;&emsp;Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。。 本例演示 CentOS 7 下安装和配置 Nginx 的基本步骤。</p><h2 id="步骤1：添加yum源"><a href="#步骤1：添加yum源" class="headerlink" title="步骤1：添加yum源"></a>步骤1：添加yum源</h2><pre><code>$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><p>安装完yum源之后，可以查看一下。</p><pre><code>repo id                                 repo name                                                              statusbase/7/x86_64                           CentOS-7                                                               10,097epel/x86_64                             Extra Packages for Enterprise Linux 7 - x86_64                         13,510extras/7/x86_64                         CentOS-7                                                                  307nginx/x86_64                            nginx repo                                                                170updates/7/x86_64                        CentOS-7                                                                1,010repolist: 25,094</code></pre><p>可以发现<font width="bolder" color="red">nginx repo</font>已经安装到本机了</p><h2 id="步骤2：安装"><a href="#步骤2：安装" class="headerlink" title="步骤2：安装"></a>步骤2：安装</h2><p>yum 安装 Nginx，非常简单，一条命令。</p><pre><code>$ sudo yum install nginx</code></pre><h2 id="步骤-3-配置-Nginx-服务"><a href="#步骤-3-配置-Nginx-服务" class="headerlink" title="步骤 3: 配置 Nginx 服务"></a>步骤 3: 配置 Nginx 服务</h2><p>设置开机启动</p><pre><code>$ sudo systemctl enable nginx</code></pre><p>启动服务</p><pre><code>$ sudo systemctl start nginx</code></pre><p>停止服务</p><pre><code>$ sudo systemctl restart nginx</code></pre><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><pre><code>$ sudo systemctl reload nginx</code></pre><p>到这里我们输入我们服务器外网的网址就可以看到<strong>nginx welcome</strong>的欢迎界面。此时就说明你的nginx已经安装完成了。</p><h1 id="在服务器上安装git"><a href="#在服务器上安装git" class="headerlink" title="在服务器上安装git"></a>在服务器上安装git</h1><p><P><br>&emsp;&emsp;当我们把nginx安装到我们的服务器之后，下一步就是安装git。如果之前你已经搭建过hexo博客并且已经将博客搭建在GitHub上时后面的步骤你将会稍微比较熟悉。<br>&lt;/p&gt;</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><pre><code>git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git</code></pre><h2 id="创建用户并配置其仓库"><a href="#创建用户并配置其仓库" class="headerlink" title="创建用户并配置其仓库"></a>创建用户并配置其仓库</h2><pre><code>useradd gitpasswd git // 设置密码su git // 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p projects/blog // 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git // 创建一个裸露的仓库cd blog.git/hooksvi post-receive // 创建 hook 钩子函数，输入了内容如下</code></pre><pre><code class="hljs plain">#!&#x2F;bin&#x2F;shgit --work-tree&#x3D;&#x2F;home&#x2F;git&#x2F;projects&#x2F;blog --git-dir&#x3D;&#x2F;home&#x2F;git&#x2F;repos&#x2F;blog.git checkout -f</code></pre><p>添加完毕后修改权限</p><pre><code>chmod +x post-receiveexit // 退出到 root 登录chown -R git:git /home/git/repos/blog.git // 添加权限</code></pre><h2 id="测试git仓库是否可用，另找空白文件夹"><a href="#测试git仓库是否可用，另找空白文件夹" class="headerlink" title="测试git仓库是否可用，另找空白文件夹"></a>测试git仓库是否可用，另找空白文件夹</h2><pre><code>git clone git@server_ip:/home/git/repos/blog.git</code></pre><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><h2 id="Git配置仓库"><a href="#Git配置仓库" class="headerlink" title="Git配置仓库"></a>Git配置仓库</h2><p>&emsp;&emsp;这一部分主要目的是让我们个人的电脑可以通过ssh方式连接到云服务器，然后我们就可以通过命令行方式将我们的博客Po到服务器上。操作如下： 安装git: yum install git 配置git用户 adduser git 修改用户权限:</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoers</code></pre><pre><code class="hljs plain">找到这个位置添加下面这句话 git ALL&#x3D;(ALL) ALL</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d76b9d87178?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>保存退出后 将sudoers文件权限改回原样</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，然后在~目录下创建.ssh文件夹</p><pre><code>        su git        cd ~        mkdir .ssh        cd .ssh</code></pre><p><strong>生成公钥密钥文件</strong>(重点)</p><font color="red" size="bolder">ssh-keygen</font><p><strong>此时在目录下就会有两个文件，分别是</strong></p><font color="red" size="bolder">id_rsa 和 id_rsa.pub</font><p>其中<strong>id_rsa.pub</strong>就是公钥文件 我们复制一份</p><font color="red" size="bolder">cp id_rsa.pub authorized_keys</font><p><strong>这样目录下就会有一个authorized_keys文件，它和id_rsa.pub一模一样。<br>最后我们修改它的权限</strong></p><pre><code>chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>&emsp;&emsp;但是大家一定要注意在远程连接服务其之前，我们一定要先对我能的服务器进行设置。<br>在root用户下修改 <strong>/etc/ssh/sshd_config</strong> 文件中的<strong>PasswordAuthentication no改为PasswordAuthentication yes</strong> 并保存。<br><img src="https://img.alicdn.com/tfs/TB1B8ELgHsTMeJjSszgXXacpFXa-799-554.png" srcset="/img/loading.gif" alt=" "><br>输入如下命令<strong>sudo service sshd restart</strong>重启SSH服务,就可以重新使用账号密码连接服务器了。<br><img src="https://img.alicdn.com/tfs/TB1OjQ_gMMPMeJjy1XbXXcwxVXa-812-264.png" srcset="/img/loading.gif" alt=" "></p><p>&emsp;&emsp;然后我们在<strong>自己的电脑上自己的电脑上自己的电脑上</strong>（重要的事说三遍），打开cmd，使用ssh方式连接我们的云服务器。<br>     <img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d7a77735c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>最后当你远程连接上你的服务器时，就会出现<br><img src="/img/服务器-4.png" srcset="/img/loading.gif" alt=" "></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我们需要更改hexo博客的根目录下的_config.yml文件将最后一行的的repo：后面改成 </p><pre><code>git@这里写服务器外网IP:/home/git/repos/blog.git</code></pre><p>之后大家就可以来尝试用hexo clean &amp; hexo g &amp; hexo d 来部署大家的博客了。<br><img src="/img/服务器-2.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多文件编译</title>
    <link href="/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<!--banner_img:是当前页面图片--><p>在编译多个文件的时候所出现的报错<br><a id="more"></a></p><h1 id="多文件编译遇见的问题"><a href="#多文件编译遇见的问题" class="headerlink" title="多文件编译遇见的问题"></a>多文件编译遇见的问题</h1><p><img src="/img/报错截图.jpg" srcset="/img/loading.gif" alt=" "></p><p>该错误出现在 command line 为</p><pre><code class="hljs plain">gcc coordin.h file1.cpp file2.cpp -o file1</code></pre><p><strong>解决方法为：</strong><br><strong>解决方法是用如下命令进行编译(使用 -l 来连接 stdc++):</strong></p><pre><code class="hljs plain">gcc coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre><p><strong>gcc编译cpp文件为什么要加-lstdc++?</strong></p><pre><code>   gcc可以编译c++文件，也可以编译c文件，但默认是编译c文件的，加-lstdc++表示编译c++文件，即链接c++库，加-lc表示链接c库，默认情况下就是链接c库，所以如果编译c文件可以不加-lc。</code></pre><p><strong>另外，你也可以使用 g++, 效果是一样的, stdc++会被自动连接:</strong><br><pre><code class="hljs plain">g++ coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单题（1136）</title>
    <link href="/2019/12/15/AC%EF%BC%881136%EF%BC%89/"/>
    <url>/2019/12/15/AC%EF%BC%881136%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这个一道递归优化问题</p><a id="more"></a><h1 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h1><p><strong>题目表述</strong><br>优化一下代码：<br><pre><code class="hljs plain">#include &lt;iostream&gt;using namespace std;int f(int n)&#123;if (n &lt; 0) return 0;if (n &#x3D;&#x3D; 0) return 1;return f(n - 1) + f(n - 2);&#125;int main()&#123;    int n;cin &gt;&gt; n;cout &lt;&lt; f(n);return 0;&#125;</code></pre><br><strong>输入</strong><br>    一个小于50的正整数n。<br><strong>输出</strong><br>    f(n)，不要换行。<br><strong>样例输入</strong><br>    3<br><strong>样例输出</strong><br>    3</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;这个题目看起来没有什么意思，但是我们通过分析计算我们会发现。<br>&emsp;&emsp;1. 递归50次后$int$是否够存，<br>&emsp;&emsp;2. 递归50次后会不会爆栈。<br>&emsp;&emsp;3. 我们应该如何优化。<br>&emsp;&emsp;我们将代码复制到编辑器里面后编译会发现在输入49后$int$会溢出说明这49的递归后是一个超过21亿的数，所以我们应该使用$long$ $long$来储存这个庞大的数值。然后就是爆栈的问题，在使用$long$ $long$之后还是能计算出来的说明还没有爆栈，还能计算。然后就是递归的优化问题了。</p><h3 id="什么是递归优化？"><a href="#什么是递归优化？" class="headerlink" title="什么是递归优化？"></a>什么是递归优化？</h3><p>&emsp;&emsp;递归优化是由于递归多次后递归深度过大，导致爆栈。或者是由于递归深度过深之后时间过长，导致之间效率低下。所以我们常见的递归优化有两种。</p><ol><li>尾递归。</li><li>将递归改循环。<br>两种方法，我们在记忆化之后我们发现这些数列之间的插值满足斐波拉切数列。所以我们就可以把这个递归函数改成一个循环函数。就可以实现对递归的优化。</li></ol><p><strong>答案</strong><br><pre><code class="hljs plain">#include &lt;iostream&gt;using namespace std;&#x2F;*int f(int n)&#123;if (n &lt; 0) return 0;if (n &#x3D;&#x3D; 0) return 1;return f(n - 1) + f(n - 2);&#125;*&#x2F;long long  fibo(int n)&#123;    long long nFirst &#x3D; 0;    long long nSecond &#x3D; 1;    long long  nThird &#x3D; 0;    for(int i &#x3D; 2 ; i &lt;&#x3D; n; i++)&#123;        nThird &#x3D; nFirst + nSecond;        nFirst &#x3D; nSecond;        nSecond &#x3D; nThird;    &#125;    return nThird;&#125;long long f(int n)&#123;    long long count &#x3D; 1;    if(n &#x3D;&#x3D; 1)&#123;        return 1;    &#125;    for (int i &#x3D; 1; i &lt; n; i++)    &#123;        count +&#x3D; fibo(i);    &#125;    return count+1;&#125;int main()&#123;    int n;cin &gt;&gt; n;cout &lt;&lt; f(n);return 0;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>顺序表简述</p><a id="more"></a><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p><strong>顺序映象</strong>：</p><p>&emsp;&emsp;—— 以x的存储位置和y的春初位置之间某种关系表示逻辑关系<x,y></p><p>最简单的一种顺序映象方式是：</p><p>&emsp;&ensp;令 y 的存储位置和 x 的存储位置相邻。用一组==地址连续==的存储单元==依次存放==线性表中的元素。==线性表的起始地址==，称作线性表的<strong>基地址</strong>。也就是第一个元素。</p><p>以“存储位置相邻”表示有序对$<a_{i-1},a_i>$,即：$LOC(a~i~) = LOC(a~i-1~) + C$;</p><p>&emsp;&ensp;所有数据元素的存储位置。$LOC(a~i~) = LOC(a~1~) + (i - 1) \times C$,其中LOC(a~1~)就是基地址。</p><ul><li>存取结构：与存储结构是两个不同的概念。</li><li>存取结构是在一个数据结构上对查找操作的时间性能的一种描述。</li><li><p>通常由两种存取结构；随机存取结构和顺序存取结构。</p><ul><li>随机存取结构是指在一个数据结构上进行查找的时间性能是$O(1)$,即查找任意一个数据元素的时间时候相等的，均为常数时间，例如顺序表示一种随机存期结构。</li><li>顺序存取结构是指在一个数据结构上进行查找的时间性能是$O(n)$，即查找一个数据元素的时间复杂度是线性的，与该元素在结构中的位置有关，例如单链表是一种顺序存储结构。</li></ul></li></ul><h2 id="顺序映象的C语言描述"><a href="#顺序映象的C语言描述" class="headerlink" title="顺序映象的C语言描述"></a>顺序映象的C语言描述</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTSIZE 100  <span class="hljs-comment">//存储空间最大分配量</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType elem[LISTSZIE];    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">//当前长度</span>&#125;Sqlist; <span class="hljs-comment">//Sqlist，代表线性表;</span></code></pre><ul><li>在线性表的静态分配顺序存储结构中，线性表的最多数据元素个数为LSITSIZE，元素数量不能随意增加，这是以数组方式描述线性表的缺点。</li></ul><p>&emsp;&ensp;为了实现线性表最大存储数据元素数可随意变化，可以使用一个动态的数组来取代上面的固定长度数组，如下描述。</p><p>线性表的动态分配顺序储存结构：<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//初始分配量</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTINCREMENT 10 <span class="hljs-comment">//分配分配增量</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType *elem;  <span class="hljs-comment">//储存空间基址</span>    <span class="hljs-keyword">int</span> length; <span class="hljs-comment">//当前长度</span>    <span class="hljs-keyword">int</span> listsize; <span class="hljs-comment">//当前分配的存储容量</span>&#125;SqList;<span class="hljs-comment">// 俗称 顺序表</span></code></pre></p><h3 id="线性表操作"><a href="#线性表操作" class="headerlink" title="线性表操作"></a>线性表操作</h3><h3 id="1-InitList-amp-L"><a href="#1-InitList-amp-L" class="headerlink" title="1.InitList(&amp;L);"></a>1.InitList(&amp;L);</h3><p>&emsp;&emsp;InitList(&amp;L); 的实现是一个加工型的运算，因此，将L设为引用参数，首先动态分配存储空间，然后，将length设置为0，表示表中没有数据元素。</p><p>代码实现：<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span> <span class="hljs-params">(SqList &amp;L)</span></span>&#123;    L.elem = (ElemType* )<span class="hljs-built_in">malloc</span>(LIST_INIT_SIZE * <span class="hljs-keyword">sizeof</span> (ElemType));    <span class="hljs-keyword">if</span> (!L.elem)&#123;        <span class="hljs-built_in">exit</span> (<span class="hljs-number">1</span>);<span class="hljs-comment">//储存分配失败</span>    &#125;    L.length = <span class="hljs-number">0</span>;    L.listsize = LIST_INIT_SIZE;<span class="hljs-comment">//初始储存容量;</span>    <span class="hljs-keyword">return</span> OK;&#125;</code></pre></p><h3 id="2-LocateElme-L-x-compare"><a href="#2-LocateElme-L-x-compare" class="headerlink" title="2.LocateElme(L,x,compare());"></a>2.LocateElme(L,x,compare());</h3><ul><li>线性表中的<strong>按置操作</strong>是指在线性表中查找与给定值X相等的数据元素。</li><li>顺序表中完成该运算最简单的方法是：从第一个元素a~1~起依次和X比较，直到找到一个与X相等的数据元素，则返回它在顺序表中的存储下标记或序号(二者差1);或者查遍整个表都没有找到与X相等的元素，返回ERROR。</li></ul><p>代码实现：<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">LocateElem_Sq</span> <span class="hljs-params">(SqList L, ElemType x)</span></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= L.length<span class="hljs-number">-1</span> &amp;&amp; L.elem[i] != x)&#123;        i++;    &#125;    <span class="hljs-keyword">if</span>(i &gt; L.length - <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> ERROR;    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;&#125;</code></pre></p><blockquote><p>本算法的主要运算是比较，显然比较的次数与x在表中的位置有关，也与表长有关。当a~1~ = x时，比较一次成功，当a~n~ = x时比较n次成功，按值查找的平均比较次数为 $\frac{(N+1)}{2}$,时间性能为$O(n)$。</p></blockquote><h3 id="3-ListInsert-amp-L-i-e"><a href="#3-ListInsert-amp-L-i-e" class="headerlink" title="3. ListInsert(&amp;L, i, e)"></a>3. ListInsert(&amp;L, i, e)</h3><p>代码实现:<br><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-keyword">int</span> i, ElemType e)</span></span>&#123;    <span class="hljs-comment">//在顺序表L的第i个元素之前插入新的元素e</span>    <span class="hljs-comment">//i的合法范围为 1 &lt;=i&lt;=L.length+1</span>    ElemType *q = &amp;(L.elem[i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//q指示插入位置</span>    ElemType *p;    <span class="hljs-keyword">for</span> (p = &amp;(L.elem[L.length<span class="hljs-number">-1</span>]); p &gt;= q; --p)&#123;            *(p + <span class="hljs-number">1</span>) = *p;<span class="hljs-comment">//插入位置及之后的元素右移</span>            *q = e;<span class="hljs-comment">//插入e</span>        ++L.length;<span class="hljs-comment">//表长增1</span>    &#125;&#125;</code></pre><br>算法时间复杂度为：$O(ListLength(L))$</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//插入位置不合法</span>&#125;<span class="hljs-keyword">if</span> (L.length &gt;= L.listsize)&#123;    <span class="hljs-keyword">return</span> OVERFLOW;<span class="hljs-comment">//当前存储空间已满</span>&#125;</code></pre><h4 id="考虑移动元素的平均情况："><a href="#考虑移动元素的平均情况：" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设在第i个元素之前插入的概率为p~i~,则在长度为<em>n</em>的线性表中插入一个元素为所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_is = \sum_{i = 1}^{n + 1} P_i(n - i + 1)</script><p>所有为位置的概率的累加和。</p><p>&emsp;&emsp;若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_is = \frac{i}{n+1}\sum_{i=1}^{n+1}(n-i+1) = \frac{2}{n}</script><h3 id="4-ListDelete-amp-L-i-amp-e-的实现："><a href="#4-ListDelete-amp-L-i-amp-e-的实现：" class="headerlink" title="4. ListDelete(&amp;L, i, &amp;e)的实现："></a>4. ListDelete(&amp;L, i, &amp;e)的实现：</h3><p>代码实现：<br><pre><code class="hljs plain">Status LsitDelet_Sq (SqList &amp;L, int i, ElemType &amp;e)&#123;    if((i &lt; 1) || (i &gt; L.length))&#123;        return ERROR;&#x2F;&#x2F;删除位置不合法    &#125;    p &#x3D; &amp;(L.elem[i-1]);&#x2F;&#x2F;p为被删除元素的位置    e &#x3D; *p;&#x2F;&#x2F;被删除元素的值赋给e,可以查看被删元素    q &#x3D; L.elem + L.length-1;&#x2F;&#x2F;表尾元素的位置，基址加上一个整数值    for (++p; p &lt;&#x3D; q; ++p)&#123;        *(p-1) &#x3D; *p;&#x2F;&#x2F;被删除元素之后的元素左移        --L.length;&#x2F;&#x2F;表长减一    &#125;    return OK;&#125;</code></pre><br>算法时间复杂度为：$O(ListLength(L))$</p><h4 id="考虑移动元素的平均情况：-1"><a href="#考虑移动元素的平均情况：-1" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设删除第i个元素的概率为$q_i$,则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_dl = \sum_{i=1}^{n}q_i(n-i)</script><p>&emsp;&emsp;假设定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_dl=\frac{1}{n}\sum_{i=1}^{n}(n-1)=\frac{n-1}{2}</script>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链式存储</title>
    <link href="/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>链式存储的基本实现</p><a id="more"></a><h2 id="1-3线性表的链式存储结构-单链表"><a href="#1-3线性表的链式存储结构-单链表" class="headerlink" title="1.3线性表的链式存储结构(单链表)"></a>1.3线性表的链式存储结构(单链表)</h2><p>&emsp;&emsp;用一组地址任意的存储来存放线性表中的元素。</p><p>&emsp;&emsp;以<strong>元素</strong>（数据元素的映象）+指针（指示后继元素存储位置）=<strong>结点</strong>（表示数据元素或数据元素的映象）</p><p>&emsp;&emsp;以“结点的序列”表示线性表<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————称作链表</p><p>&emsp;&emsp;以线性表中第一个数据元素a~1~的存储地址作为线性表中的地址，称作线性表的头指针。<br>&emsp;&emsp;有时为了操作方便，在第一个结点之前需加一个“头结点”，以指向头结点的指针为链表的头指针。</p><h3 id="单链表的C语言实现："><a href="#单链表的C语言实现：" class="headerlink" title="单链表的C语言实现："></a>单链表的C语言实现：</h3><pre><code>typedef struct LNode{    ElemType data;//数据域    struct LNode *next;//指针域}LNode, *LinkList;LinkList L;//L为单链表的头指针;</code></pre><p>单链表操作实现的基本实现：</p><ul><li>GetElem(L, i, e)&emsp;//取第i个数据元素</li><li>ListInsert(&amp;L, i, e)&emsp;//插入数据元素</li><li>ListDelete(&amp;L, i, e)&emsp;//删除数据元素</li><li>ClearList(&amp;L)&emsp;//重新置为一个空表</li><li>CreateList(&amp;L, n)&emsp;//生成含$n$个数据元素的链表</li></ul><p>找第1个数据元素，必须先找到第$i-1$个数据元素。因此，查找第i个数据元素的基本操作是==移动指针，比较j和i==。令指针p始终指向线性表中第j个数据元素。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dummy Node</title>
    <link href="/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/"/>
    <url>/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="链表Dummy-Node"><a href="#链表Dummy-Node" class="headerlink" title="链表Dummy Node"></a>链表Dummy Node</h1><h2 id="（一）Partition-List"><a href="#（一）Partition-List" class="headerlink" title="（一）Partition List"></a>（一）Partition List</h2><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-list/description/</a></p><p><strong>题目：给出一个链表和一个x值，要求返回一个顺序链表使得小于x的数在链表前面，大于等于x的数在链表后面，保证节点顺序不变。</strong></p><pre><code>      例如：$1-&gt;3-&gt;2-&gt;4-&gt;2, 3$ 变成：$1-&gt;2-&gt;2-&gt;3-&gt;4$</code></pre><font color="#435d6c" size="3px">解答：建立两个新的左、右指针及dummy node，使用head指针遍历整个链表，遇到大于等于head的节点则放到右链表，否则放到左链表。最后将左右链表相连。第一次犯错：忘记将又指针的尾部指向null;</font><p>代码：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;         <span class="hljs-keyword">if</span> (head == null) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                ListNode leftDummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode rightDummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode left = leftDummy;        ListNode right = rightDummy;                <span class="hljs-keyword">while</span> (head != null) &#123;            <span class="hljs-keyword">if</span> (head.val &gt;= x) &#123;                right.next = head;                right = right.next;            &#125; <span class="hljs-keyword">else</span> &#123;                left.next = head;                left = left.next;            &#125;            head = head.next;        &#125;        right.next = null;        left.next = rightDummy.next;        <span class="hljs-keyword">return</span> leftDummy.next;    &#125;&#125;</code></pre><h2 id="（二）-Merge-Two-Sorted-Lists"><a href="#（二）-Merge-Two-Sorted-Lists" class="headerlink" title="（二） Merge Two Sorted Lists"></a>（二） Merge Two Sorted Lists</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></p><font color="red">AC！</font><p><b>题目：将两个顺序链表合并成一个顺序链表；</b></p><font color="#435d6c" size="3px">解答：依次比较两个链表里的值大小进行排列；</font><p>改进：当一个链表指针指向null，另一个链表还没时，可以直接将重新排列的链表尾指向当前指针：<br><pre><code class="hljs c++">           <span class="hljs-keyword">if</span> (l1 != null) &#123;           head.next = l1;           &#125; <span class="hljs-keyword">else</span> &#123;           head.next = l2;          &#125;</code></pre></p><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode head = dummy;                <span class="hljs-keyword">while</span> (l2 != null &amp;&amp; l1 != null) &#123;            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;                head.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                head.next = l2;                l2 = l2.next;            &#125;            head = head.next;        &#125;         <span class="hljs-keyword">while</span> (l1 != null) &#123;            head.next = l1;            l1 = l1.next;            head = head.next;        &#125;        <span class="hljs-keyword">while</span> (l2 != null) &#123;            head.next = l2;            l2 = l2.next;            head = head.next;        &#125;        head.next = null;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></p><h2 id="（三）swap-two-nodes-in-linked-list"><a href="#（三）swap-two-nodes-in-linked-list" class="headerlink" title="（三）swap two nodes in linked list"></a>（三）swap two nodes in linked list</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/description/</a></p><font color="red" >AC！</font><p><b>题目：两两交换链表中节点位置。</b>如：$1-&gt;2-&gt;4-&gt;5-&gt;6$ 转变为: $2-&gt;1-&gt;5-&gt;4-&gt;6$</p><font color="#435d6c" size="3px">解答：使用两个指针遍历链表；</font><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == null) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        dummy.next = head;        ListNode headNext = head.next;        ListNode headPrev = dummy;                <span class="hljs-keyword">while</span> (head != null &amp;&amp; headNext != null) &#123;            headPrev.next = headNext;            head.next = headNext.next;            headNext.next = head;            headPrev = head;            head = head.next;            <span class="hljs-keyword">if</span> (head != null) &#123;                headNext = head.next;            &#125;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></p><h2 id="（四）reorder-list"><a href="#（四）reorder-list" class="headerlink" title="（四）reorder list"></a>（四）reorder list</h2><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/reorder-list/description/</a></p><p><b>题目：给定一个单链表：</b>$L0-&gt;L1-&gt;…-&gt;Ln-1-&gt;Ln,$</p><pre><code>      重新排序后为：$L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2-&gt;...$</code></pre><font color="#435d6c" size="3px">解答：第一次犯错：将链表尾连接到头之后，忘记将尾的前一个指针指向空；第二次犯错：忘记考虑链表头和prevTail重合的情况（偶数链表）。</font><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">while</span> (head != null &amp;&amp; head.next != null) &#123;            ListNode prevTail = head;            <span class="hljs-keyword">while</span> (prevTail.next.next != null) &#123;                prevTail = prevTail.next;            &#125;            ListNode tail = prevTail.next;            <span class="hljs-keyword">if</span> (head.next == tail) &#123;                <span class="hljs-keyword">break</span>;            &#125;             tail.next = head.next;            head.next = tail;            head = head.next.next;            prevTail.next = null;        &#125;    &#125;&#125;</code></pre></p><h2 id="（四）Rotate-List"><a href="#（四）Rotate-List" class="headerlink" title="（四）Rotate List"></a>（四）Rotate List</h2><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-list/description/</a></p><p><strong>题目：将链表尾部的k个节点移到链表头部；</strong></p><font color="#435d6c" size="3px">解答：每次将链表最后一个节点移动至链表头，移动k次；</font><p>第一次犯错：（超时）先遍历链表，得到链表长度length，循环只需执行 k%length 次；</p><p>代码：<br><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        ListNode tail = head;        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> (tail != null ) &#123;            length++;            tail = tail.next;        &#125;                <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span> || length == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> head;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k % length; i++) &#123;            ListNode preTail = head;            <span class="hljs-keyword">while</span> (preTail != null &amp;&amp; preTail.next != null &amp;&amp; preTail.next.next != null) &#123;                preTail = preTail.next;            &#125;            tail = preTail.next;            tail.next = head;            preTail.next = null;            head = tail;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>二叉树有多种遍历的方式我们简单总结一下</p><a id="more"></a><h1 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h1><p><p>&emsp;&emsp;<b>二叉树的遍历(treaversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</b>这是二叉树遍历的定义。二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分四种。</p></p><ol><li>前序遍历(PreOrder)<br></li><li>中序遍历(InOrder)<br></li><li>后续遍历(PastOrder)<br></li><li>层序遍历(LevelOrder)<br></li></ol><p>树的前中后序遍历是个递归的定义，在遍历到根节点的左/右子树时，也要遵循前/中/后序遍历的顺序，例如下面这棵树：</p><p>前序遍历：ABDECFG<br>中序遍历：DBEAFCG<br>后序遍历：DEBFGCA<br>层序遍历：ABCDEFG</p><p>树的结点结构体声明如下：<br>语言：C语言（为了省事用到了C++的栈，因为C语言要用栈的话要自己重新写一个出来，就偷了个懒）<br>编译器：VS</p><pre><code>typedef char DataType;typedef struct TreeNode{    DataType data;    struct TreeNode *left;    struct TreeNode *right;}TreeNode;</code></pre><p>前序遍历（先序遍历）<br>对于一棵树的前序遍历，递归的写法是最简单的（写起来），就是将一个大的问题转化为几个小的子问题，直到子问题可以很容易求解，最后将子问题的解组合起来就是大问题的解。</p><p>前序访问的递归写法<br>先放代码，如果看完觉得不太清楚可以看看下面的详细步骤图解。</p><pre><code>void PreOrder(const TreeNode *root){    if (root == NULL)                 //若结点为空    {        printf(&quot;# &quot;);        return;    }    printf(&quot;%c &quot;, root-&gt;data);        //输出根节点的值    PreOrder(root-&gt;left);             //前序访问左子树    PreOrder(root-&gt;right);            //前序访问右子树}</code></pre><p>比如说还是上面的这颗树：</p><p>访问根节点</p><p>访问左子树</p><p>走到这里之后发现根节点的左孩子还是一棵子树，那就将访问这棵子树看作是遍历整颗树的一个子问题，遍历这棵子树的方法和遍历整颗树的方法是一样的。<br>然后继续访问它的左子树：</p><p>为了理解起来方便一点，我在这里加上了它的两个为空的左右孩子<br>然后发现这（可能）还是一棵子树，就继续用这种方法来对待这颗子树，就是继续访问它的左子树：</p><p>发现这是一个空节点，那就直接返回，去访问它的右子树：</p><p>发现还是一个空节点，那么继续返回，这时候D和它的左右孩子结点都访问过了，继续返回，应该访问B的右子树了。</p><p>然后就和D结点一样的处理方法，-&gt;左孩子，发现是空，返回-&gt;右孩子，发现还是空，继续返回，发现这时候B的左右孩子都访问过了，继续返回。<br>访问右子树</p><p>然后和处理A的左子树的方法一样，最后访问到G结点的右子树时，发现是空，就返回，这时候树的所有节点都已经访问过了，所以可以一路返回到A结点的右子树完的地方，整个递归就结束了。</p><p>最后输出的前序访问序列便是：ABDECFG<br>前序访问的非递归写法<br>还是先上代码：</p><pre><code>void PreOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            printf(&quot;%c &quot;, cur-&gt;data);            s.push(cur);            cur = cur-&gt;left;        }        top = s.top();        s.pop();        cur = top-&gt;right;    }}</code></pre><p>非递归的写法比递归写法要麻烦一点，要用到栈来存储树的结点，在理解非递归方法的时候要重点理解栈中保存的元素的共同点是什么，在前序访问中，栈中元素都是自己和自己的左孩子都访问过了，而右孩子还没有访问到的节点，如果不太懂可以看下面的详细步骤图解。</p><p>首先我们要用一个指针（cur）来指向当前访问的结点</p><p>发现这个节点不为空，就将它的数据输出，然后将这个节点的地址（图上的栈中写了节点的值是为了便于理解，实际上栈中保存的是节点地址）压栈。</p><p>再去访问它的左子树，发现左孩子结点依旧不为空，继续输出并压栈。</p><p>同理压栈D节点</p><p>然后访问D的左孩子，发现为空，便从栈中拿出栈顶结点top，让cur = top-&gt;right,便访问到了D的右孩子。</p><p>发现D的右孩子还是为空，这个看一下栈，发现栈不为空，说明还存在右孩子没被访问过的节点，就继续从栈中拿出栈顶结点top，让cur = top-&gt;right，便访问到了B的右孩子。</p><p>B的右孩子处理方法和D一样，然后再从栈中拿出A节点，去访问A的右孩子C，在访问到G节点的右孩子之后，发现当前节点cur为空，栈中也没有元素可以取出来了，这时候就代表整棵树都被访问过了，便结束循环。</p><p>最后输出的前序访问序列便是：ABDECFG<br>中序遍历<br>对于一棵树的中序遍历，和前序一样，可以分为递归遍历和非递归遍历，递归遍历是相对简单的，还是子问题思想，将一个大问题分解，直到可以解决，最后解决整个大问题。</p><p>中序遍历的递归写法<br>还是先上代码：</p><pre><code>void InOrder(const TreeNode *root){    if (root == NULL)              //判断节点是否为空    {        printf(&quot;# &quot;);        return;    }    InOrder(root-&gt;left);           //中序遍历左子树    printf(&quot;%c &quot;, root-&gt;data);     //访问节点值    InOrder(root-&gt;right);          //中序遍历右子树}</code></pre><p>从根节点进入</p><p>发现根节点不为空，访问左子树</p><p>发现不为空，继续访问左子树</p><p>发现不为空，继续访问左子树</p><p>这时root为空了，就返回去访问它的根节点，刚才的访问只是路过，并没有真正地遍历节点的信息，在返回途中才是真正地遍历到了节点的信息。</p><p>访问到了D节点，下来要访问的是D的右孩子，因为D的左孩子已经访问过了。</p><p>发现还是空，就返回，而它的根节点D也访问过了，那么就继续返回，该访问D节点的父节点B了。</p><p>B访问过后下来要访问的是B的右孩子，因为是从B的左子树回来的路，B的左孩子已经访问过了。</p><p>然后和访问D一样，-&gt;左孩子，为空，返回访问根节点E，-&gt;右孩子，为空（这部分就不画了，和D节点的访问是一样的），最后返回，B已经访问过了，就继续返回，至此，整颗树的左子树访问完了。</p><ol><li><p>访问B的根节点A</p></li><li><p>遍历A的右子树<br>遍历右子树的过程和左子树一样，还是左-&gt;根-&gt;右的中序遍历下去，直到遍历到G的右孩子，发现为空，就返回，因为右子树都遍历过了，所以可以一直返回到root为A节点的那一层递归，整个遍历结束。</p></li></ol><p>最后输出的中序访问序列为：DBEAFCG</p><p>非递归写法<br>中序访问的非递归写法和前序一样，都要用到一个栈来辅助存储，不一样的地方在于前序访问时，栈中保存的元素是右子树还没有被访问到的节点的地址，而中序访问时栈中保存的元素是节点自身和它的右子树都没有被访问到的节点地址。</p><p>先上代码：</p><pre><code>void InOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            s.push(cur);            cur = cur-&gt;left;        }        cur = s.top();        s.pop();        printf(&quot;%c &quot;, cur-&gt;data);        cur = cur-&gt;right;    }}</code></pre><p>cur指针一路沿着最左边往下访问，路过的节点全部压栈，直到遇到空节点</p><p>从栈中取出栈顶节点top，输出栈顶结点的值并使cur = top-&gt;right，从第一步开始去遍历top的右子树。</p><p>遍历完之后，cur走到了D节点的右孩子，发现cur 为空，但栈中还有元素，就重复第二步</p><p>这时候，cur走到了E节点的右孩子，发现cur 为空，但栈中还有元素，就继续重复第二步，之后cur = top-&gt;right，cur指针继续去遍历A节点的右子树，从第一步开始</p><p>访问到F的左孩子节点发现是空，这时候栈中还有元素，就重复第二步</p><p>照这个规则依次访问下去，最后会访问到G节点的右孩子，这时候cur为空，栈也空了，就代表所有节点已经遍历完了，就结束循环，遍历完成。</p><p>最后输出的中序访问序列为:DBEAFCG</p><p>后序遍历<br>后序遍历还是分递归版本和非递归版本，后序遍历的递归版本和前序中序很相似，就是输出根节点值的时机不同，而后序遍历的非递归版本则要比前序和中序的要难一些，因为在返回根节点时要分从左子树返回和右子树返回两种情况，从左子树返回时不输出，从右子树返回时才需要输出根节点的值。</p><p>递归写法<br>先上代码：</p><pre><code>void PostOrder(TreeNode *root){    if (root == NULL)    {        printf(&quot;# &quot;);        return;    }    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    printf(&quot;%c &quot;, root-&gt;data);}</code></pre><p>后序遍历的递归版本和前中序非常相似，就是输出根节点值的时机不同，详细图解这里就不画了，可以联系前中序的递归版本来理解。</p><p>后序遍历的非递归写法<br>后序遍历的非递归同样要借助一个栈来保存元素，栈中保存的元素是它的右子树和自身都没有被遍历到的节点，与中序遍历不同的是先访问右子树，在回来的时候再输出根节点的值。需要多一个last指针指向上一次访问到的节点，用来确认是从根节点的左子树返回的还是从右子树返回的。</p><p>先上代码：</p><pre><code>void PostOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top, *last = NULL;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            s.push(cur);            cur = cur-&gt;left;        }        top = s.top();        if (top-&gt;right == NULL || top-&gt;right == last){            s.pop();            printf(&quot;%c &quot;, top-&gt;data);            last = top;        }        else {            cur = top-&gt;right;        }    }}</code></pre><p>还是沿着左子树一路往下走，将路过的节点都压栈，直到走到空节点。</p><p>然后从栈中看一下栈顶元素（只看一眼，用top指针记下，先不出栈），如果top节点没有右子树，或者last等于top的右孩子，说明top的右子树不存在或者遍历过了，就输出top节点的值，并将栈顶元素pop掉（出栈），反之则是从左子树回到根节点的，接下来要去右子树。</p><p>如图，top的右孩子为空，说明右子树不存在，就可以输出top的值并pop掉栈顶了，这时候用last指针记下top指向的节点，代表上一次处理的节点。（这一过程cur始终没有动，一直指向空）</p><p>继续从栈顶看一个元素记为top，然后发现top的右孩子不为空，而且last也不等于top-&gt;right，就使cur = top-&gt;right，回到第一步，用同样的方法来处理top的右子树，下一次回来的时候，last指针指向的是E节点。</p><p>这时候发现top的右孩子不为空，但是last等于top-&gt;right，说明top的右子树遍历完成，下一步就要输出top的值并且将这个节点出栈，下一次再从栈中看一个栈顶元素A即为top。</p><p>这时候再比较，发现top的right不为空，而且last也不等于top-&gt;right，说明top有右子树并且还没有遍历过，就让cur = top-&gt;right，回到第一步用同样的方法来遍历A的右子树。<br>到最后，cur访问到了G的左孩子，而top也一路出栈到了A节点，发现cur为空，并且栈中也为空，这时候便代表整个树已经遍历完成，结束循环。</p><p>最后输出的中序访问序列为:DEBFGCA</p><p>层序遍历<br>层序遍历是比较接近人的思维方式的一种遍历方法，将二叉树的每一层分别遍历，直到最后的叶子节点被全部遍历完，这里要用到的辅助数据结构是队列，队列具有先进先出的性质。</p><p>上代码：</p><pre><code>void LevelOrder(TreeNode *root){    std::queue&lt;TreeNode *&gt; q;    TreeNode *front;    if (root == NULL)return;    q.push(root);    while (!q.empty())    {        front = q.front();        q.pop();        if (front-&gt;left)            q.push(front-&gt;left);        if (front-&gt;right)            q.push(front-&gt;right);        printf(&quot;%c &quot;, front-&gt;data);    }}</code></pre><p>层序遍历的思路是，创建一个队列，先将根节点（A）入队，然后用front指针将根节点记下来，再将根节点出队，接下来看front节点（也就是刚才的根节点）有没有左孩子或右孩子，如果有，先左（B）后右（C）入队，最后输出front节点的值，只要队列还不为空，就说明还没有遍历完，就进行下一次循环，这时的队头元素（front）则为刚才入队的左孩子（B），然后front出队，再把它的左右孩子拉进来（如果有），因为队列的先进先出性质，B的左右孩子DE是排在C后面的，然后输出B，下一次循环将会拉人C的左右孩子FG，最后因为FG没有左右孩子，一直出队，没有入队元素，队列迟早会变为空，当队列为空时，整颗树就层序遍历完成了，结束循环。</p><p>根节点入队，并用front指针标记</p><p>队头出队，并将左右孩子拉进队列</p><p>重复1，2</p><p>直到队列为空</p><p>这时候便代表整个树遍历完成，结束循环。<br>最后输出的层序访问序列为:ABCDEF</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MinGw如何调试？</title>
    <link href="/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>MinGw调试方法</p><a id="more"></a><h1 id="MinGW调试命令"><a href="#MinGW调试命令" class="headerlink" title="MinGW调试命令"></a>MinGW调试命令</h1><p>&emsp;&emsp;MinGW（Minimalist GNU for Windows）提供了一套简单方便的Windows下的基于GCC程序开发环境。MinGW收集了一系列免费的Windows是用的头文件和库文件；同时整合了GNU的工具集，特别是GNU程序开发工具，如经典的gcc，g++，make等。MinGW是完全免费的自由软件，它在Windows平台下模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好的基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。简单的说，它是个精简的C/C++编译器，它实际上是将经典的开源C语言/C++编译器GCC/G++移植到了Windows下，并且包含了Win32API，因此可以将源代码编译生成Windows下的可执行程序。虽然VC6等编译器，只要点击鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑，而MinGW则只会生成一个可执行文件</p><hr><h2 id="gdb调试测试代码-test-c-："><a href="#gdb调试测试代码-test-c-：" class="headerlink" title="gdb调试测试代码(test.c)："></a>gdb调试测试代码(test.c)：</h2><pre><code>#include &lt;stdio.h&gt;void swap(int *a,int *b){    int temp = *a;    *a = *b;    *b = temp;}int main(void){    int a=1,b=2;    swap(&amp;a,&amp;b);    printf(&quot;a = %d ,b = %d\n&quot;,a,b);    return 0;}</code></pre><h3 id="要支持调试，在编译时要加入-g选项，编译命令："><a href="#要支持调试，在编译时要加入-g选项，编译命令：" class="headerlink" title="要支持调试，在编译时要加入-g选项，编译命令："></a>要支持调试，在编译时要加入-g选项，编译命令：</h3><pre><code>gcc text.c -g text.exe</code></pre><h3 id="出现调试命令："><a href="#出现调试命令：" class="headerlink" title="出现调试命令："></a>出现调试命令：</h3><pre><code>GNU gdb (GDB) 7.6.1Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;mingw32&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from D:\mypro\C\test.exe...done.(gdb)</code></pre><h3 id="gdb调试命令表："><a href="#gdb调试命令表：" class="headerlink" title="gdb调试命令表："></a>gdb调试命令表：</h3><div class="table-container"><table><thead><tr><th>命令</th><th style="text-align:center">解释</th><th style="text-align:right">简写</th></tr></thead><tbody><tr><td>file</td><td style="text-align:center">加载一个可执行文件，也可以在运行gdb的时候加载，两种方法都不会运行程序</td><td style="text-align:right">无</td></tr><tr><td>list</td><td style="text-align:center">列出可执行源码的一部分，通常在程序开始运行前执行，用来设置断点</td><td style="text-align:right">l</td></tr><tr><td>next</td><td style="text-align:center">单步调试，不进入函数</td><td style="text-align:right">n</td></tr><tr><td>step</td><td style="text-align:center">单步调试，进入函数</td><td style="text-align:right">s</td></tr><tr><td>run</td><td style="text-align:center">运行加载了的程序</td><td style="text-align:right">r</td></tr><tr><td>continue</td><td style="text-align:center">继续执行程序</td><td style="text-align:right">c</td></tr><tr><td>quit</td><td style="text-align:center">退出调试</td><td style="text-align:right">q</td></tr><tr><td>print</td><td style="text-align:center">输出制定的变量的值，变量要在程序运行处可见</td><td style="text-align:right">p</td></tr><tr><td>break</td><td style="text-align:center">设置断点</td><td style="text-align:right">b</td></tr><tr><td>info break</td><td style="text-align:center">查看断点的信息</td><td style="text-align:right">i b</td></tr><tr><td>delete</td><td style="text-align:center">删除断点</td><td style="text-align:right">d</td></tr><tr><td>watch</td><td style="text-align:center">监视一个变量的值，一旦值发生变化，程序将会被暂停执行</td><td style="text-align:right">wa</td></tr><tr><td>help</td><td style="text-align:center">查看gdb的帮助信息</td><td style="text-align:right">h</td></tr></tbody></table></div><h3 id="1-l命令，列出部分代码："><a href="#1-l命令，列出部分代码：" class="headerlink" title="1.l命令，列出部分代码："></a>1.l命令，列出部分代码：</h3><p>在(gdb)后面输入l可以显示一部分代码再输入一次l可以显示全部代码</p><pre><code>(gdb) l2   3   void swap(int *a,int *b){4       int temp = *a;5       *a = *b;6       *b = temp;7   }8   9   int main(void)10  {11      int a=1,b=2;(gdb)(gdb) l12      swap(&amp;a,&amp;b);13      printf(&quot;a = %d ,b = %d\n&quot;,a,b);14      return 0;15  }(gdb) l(gdb) Line number 16 out of range; test.c has 15 lines</code></pre><h3 id="2-start命令，开始运行，会停到main入口处："><a href="#2-start命令，开始运行，会停到main入口处：" class="headerlink" title="2.start命令，开始运行，会停到main入口处："></a>2.start命令，开始运行，会停到main入口处：</h3><pre><code>(gdb) startTemporary breakpoint 1 at 0x401491: file test.c, line 11.Starting program: D:\mypro\C/test.exe [New Thread 8000.0x18c4][New Thread 8000.0x2418]Temporary breakpoint 1, main () at test.c:1111      int a=1,b=2</code></pre><h3 id="4-n命令：单步调试，不进入函数，跳到第12行"><a href="#4-n命令：单步调试，不进入函数，跳到第12行" class="headerlink" title="4.n命令：单步调试，不进入函数，跳到第12行:"></a>4.n命令：单步调试，不进入函数，跳到第12行:</h3><pre><code>(gdb) n12      swap(&amp;a,&amp;b);</code></pre><h3 id="5-s命令：单步调试，进入函数，跳到第4行"><a href="#5-s命令：单步调试，进入函数，跳到第4行" class="headerlink" title="5.s命令：单步调试，进入函数，跳到第4行:"></a>5.s命令：单步调试，进入函数，跳到第4行:</h3><pre><code>gdb) sswap (a=0x61ff2c, b=0x61ff28) at test.c:44       int temp = *a;</code></pre><h3 id="6-b命令设置断点（b-第n行代码的行数）："><a href="#6-b命令设置断点（b-第n行代码的行数）：" class="headerlink" title="6.b命令设置断点（b + 第n行代码的行数）："></a>6.b命令设置断点（b + 第n行代码的行数）：</h3><pre><code>(gdb) b 6Breakpoint 2 at 0x401478: file test.c, line 6.</code></pre><h3 id="7-r命令-运行程序，直到下一个断点就停："><a href="#7-r命令-运行程序，直到下一个断点就停：" class="headerlink" title="7.r命令,运行程序，直到下一个断点就停："></a>7.r命令,运行程序，直到下一个断点就停：</h3><pre><code>The program being debugged has been started already.Start it from the beginning? (y or n)...Breakpoint 2, swap (a=0x61ff2c, b=0x61ff28) at test.c:66       *b = temp;</code></pre><h3 id="7-p命令-输出制定的变量的值，变量要在程序运行处可见"><a href="#7-p命令-输出制定的变量的值，变量要在程序运行处可见" class="headerlink" title="7.p命令,输出制定的变量的值，变量要在程序运行处可见:"></a>7.p命令,输出制定的变量的值，变量要在程序运行处可见:</h3><pre><code>(gdb) p *a$1 = 2(gdb) p *b$2 = 2(gdb) p a$3 = (int *) 0x61ff2c(gdb) p b$4 = (int *) 0x61ff28</code></pre><p>next一下，再看b的值：</p><pre><code>(gdb) n7   }(gdb) p *b$5 = 1</code></pre><h3 id="8-i-b命令-查看断点信息"><a href="#8-i-b命令-查看断点信息" class="headerlink" title="8.i b命令,查看断点信息:"></a>8.i b命令,查看断点信息:</h3><pre><code>(gdb) i bNum     Type           Disp Enb Address    What2       breakpoint     keep y   0x00401478 in swap at test.c:6    breakpoint already hit 1 time</code></pre><h3 id="9-d命令-删除断点，不加断点位置即删除所有断点"><a href="#9-d命令-删除断点，不加断点位置即删除所有断点" class="headerlink" title="9.d命令,删除断点，不加断点位置即删除所有断点:"></a>9.d命令,删除断点，不加断点位置即删除所有断点:</h3><pre><code>(gdb) d Delete all breakpoints? (y or n) [answered Y; input not from terminal](gdb) i bNo breakpoints or watchpoints.</code></pre><h3 id="10-没有断点后，再试一下r命令，可以看到，执行完了程序："><a href="#10-没有断点后，再试一下r命令，可以看到，执行完了程序：" class="headerlink" title="10.没有断点后，再试一下r命令，可以看到，执行完了程序："></a>10.没有断点后，再试一下r命令，可以看到，执行完了程序：</h3><pre><code>(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) [answered Y; input not from terminal]error return ../../gdb-7.6.1/gdb/windows-nat.c:1275 was 5Starting program: D:\mypro\C/test.exe [New Thread 1976.0x1460][New Thread 1976.0x5e0]a = 2 ,b = 1[Inferior 1 (process 1976) exited normally</code></pre><h3 id="11-q命令，退出gdb："><a href="#11-q命令，退出gdb：" class="headerlink" title="11.q命令，退出gdb："></a>11.q命令，退出gdb：</h3><pre><code>(gdb) q</code></pre>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>remove_list_entry</title>
    <link href="/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/"/>
    <url>/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学习如何写有品味的代码</p><a id="more"></a><h1 id="remove-list-entry（无需-if-逻辑）"><a href="#remove-list-entry（无需-if-逻辑）" class="headerlink" title="remove_list_entry（无需 if 逻辑）"></a>remove_list_entry（无需 if 逻辑）</h1><p>&emsp;&emsp;这是期TED里面的内容，内容是采访linux的之父Linus Torvalds。<br>&emsp;&emsp;Linus Torvalds两次改变了技术，第一次是Linux内核，它帮助互联网的发展，第二次是Git，全球开发者使用的源代码管理系统。在一次TED的采访中，Torvalds以极其开放的态度讨论了他独特的工作方式和性格特点。Torvalds说：“我不是一个空想家，我是一名工程师，我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹，看着满天星辰说，“我想到那儿去。”但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去，这就是我。”***</p><p>&emsp;&emsp;在聊天中CA问道了一个关于代码品味的的问题，这个问题其实很有意思，对于很多写代码的人来说，有好的代码风格和代码品味就好比有了一种审美品味一样。就好比在写代码时你的缩进习惯一样。</p><blockquote><p>第一段代码</p></blockquote><pre><code class="hljs plain">remove_list_entry(entry)&#123;    prev &#x3D; NULL;    walk &#x3D; head;​    &#x2F;&#x2F; Walk the list​    while (walk !&#x3D; entry)    &#123;        prev &#x3D; walk;        walk &#x3D; walk-&gt;next;    &#125;        &#x2F;&#x2F; Remove the entry by updating the     &#x2F;&#x2F; head or the previous entry    if(!prev)    &#123;        head &#x3D; entry-&gt;next;    &#125;    else    &#123;        prev-&gt;next &#x3D; entry-&gt;next;    &#125; &#125;</code></pre><blockquote><p>第二段代码</p></blockquote><pre><code class="hljs plain">remove_list_entry(entry)&#123;    &#x2F;&#x2F; The &quot;indirect&quot; pointer points to the    &#x2F;&#x2F; *address* of the thing we&#39;ll update    indirect &#x3D; &amp;head;​    &#x2F;&#x2F; Walk the list, looking for the thing that    &#x2F;&#x2F; points to the entry we want to remove     while ((*indirect) !&#x3D; entry))    &#123;        indirect &#x3D; &amp;(*indirect)-&gt;next;    &#125;​    &#x2F;&#x2F; .. and just remove it    *indirect &#x3D; entry-&gt;next;&#125;</code></pre><font color="red" size="2px">这里我注释一下哈，这两段代码都是伪码。所以看起来有点奇怪</font><p>&emsp;&emsp;看起来这两段代码功能上都一样的但是，第一段的最后用了一个if和一个else目的在于处理特殊情况，但是第二段代码很简洁没有if和else来处理特殊情况，这是一种很有意思且巧妙的思想同样<b>Dummy Node链表</b>也是一种处理方式，在这里不讨论，后面我回专门来说这种链表。</p><pre><code class="hljs plain">Node *head, *prev, *walk;void remove_list_entry(Node* entry)&#123;    prev &#x3D; NULL;    &#x2F;&#x2F; walk 这一变量名，十分巧妙，    &#x2F;&#x2F; 变量命名的不二法门就是对应其物理（实际）意义    walk &#x3D; head;    while (walk !&#x3D; entry)    &#123;        prev &#x3D; walk;        walk &#x3D; walk-&gt;next;    &#125;    &#x2F;&#x2F; 也即没有执行 while 循环，walk &#x3D;&#x3D; entry，entry &#x3D;&#x3D; head    if (!prev)        head &#x3D; entry-&gt;next;    else        prev-&gt;next &#x3D; entry-&gt;next;&#125;</code></pre><pre><code class="hljs plain">void remove_list_entry(Node* entry)&#123;    Node **indirect;    indirect &#x3D; &amp;head;    while ((*indirect) !&#x3D; entry)        indirect &#x3D; &amp;(*indirect)-&gt;next;    *indirect &#x3D; entry-&gt;next;&#125;</code></pre><font color="#24495e" size="2"><p>&emsp;&emsp;这是两段代码的表准形式</p></font><p>&emsp;&emsp;为什么要区分是头指针呢，因为整个程序的逻辑是找到被删除指针的前一个指针，如果被删除的指针为头指针，显然其没有前一个指针。显然这种的代码不具很好的 taste，话说 Jobs 也很爱讲 taste（Windows 最大的特点就是 has no taste）。<b>这两段代码的显著区别就是第二段代码省略了 if 语句，</b>对头指针和前一个指针做了统一化处理。头指针没有前一个指针，但有自己的地址，自己的地址自然还是指向自己。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/06/hello-world/"/>
    <url>/2019/12/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>first txt<br><a id="more"></a></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
