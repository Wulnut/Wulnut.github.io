<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>忆第一次美赛</title>
    <link href="/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
    <url>/2020/03/10/%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p>这不仅仅只是一次比赛那么简单</p><a id="more"></a><p>&emsp;&emsp;会战的失败原因是拿破仑一世对敌情侦察不够，临战前分散兵力，初战不利便改变决心，指挥不果断。惠灵顿<br>在进行会战决策、选择阵地、组织防御和协调联军作战方面显示了统帅才能。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>&emsp;&emsp;到我开始写这篇回忆的时候已经，已经距离美赛结束9个小时左右了。当我点下发送的那一刻，我们这场耗时80个小时三天零8个小时的比赛就真的全部结束了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/mail.png">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">提交</div></center><p>&emsp;&emsp;在关掉电脑之后我狠狠的删自己一巴掌之后，倒上床了就睡了过去。</p><h1 id="前夜"><a href="#前夜" class="headerlink" title="前夜"></a>前夜</h1><p>&emsp;&emsp;由于今年疫情的特殊原因，这次本应该在线下的比赛。被迫转移到了线上，腾讯会议是我和两个好伙伴交流与<br>讨论的唯一途径。在阿凡群里面我们对我们的设备做好了最后的调试，也大概确定了我们所希望努力的方向。就只等3月7号上<br>午出题了，大家还开玩笑说自己已经买好咖啡做好通宵的准备。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="/img/coffee.jpg">    <br>    <div style="font-size: 12px; color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">阿凡的饮料</div></center><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>&emsp;&emsp;当拿到题目的时候已经是翻译好的了，由于我们的队伍均是有CS专业同学组成的队伍，且我和阿凡都是第一次参加建模比赛。我们在比赛之前，也了解到每个题目的总体大概所需要的知识。对于C题来说相对我们来说相对友好一些。我也了解到，C题会用到数据挖掘、数据清洗、python。我觉得我在寒假期间稍微学习了一下python的基础知识，对于读懂python的基本语法应没有什么问题。但是看到题目的时候，复杂程度对于我来说几乎是没辙。怎么剔除文本中的乱码情况，怎么对给的数据进行清洗，什么是.tsv文件$\ldots$, 一系列问题我完全傻了。什么正则表达式，什么情感分析。我完全都不懂。</p><p>&emsp;&emsp;这原本是我觉得可以在前期帮助到我们队伍的东西，完全用了。负责建模的阿凡也就揽了过去，要我和阿豪去看后的题目。谁知道第一题我和阿豪就看的非常懵…问的很笼统。随后还是在知乎上有人解读才慢慢似懂非懂的大概知道第一题要我们干什么，上午我们也很快的解决的了第一题，下午便开始对后面的主要部分开始了思考，在赛前我说我会$\LaTeX$，可以负责写作。也在一个月的时间里系统的学习了，之前简单了解的知识。但是我对写作的理解太片面了。赛前准备的时候，看到网上的教程说，写作的同学不能不懂建模，不然写不出来，虽然不直接参与建模但是要对整个模型要明白。我觉得我明白了后一段话，而前段话我到现在才明白。第一天我们对题目的分析之后也就大概解决了第一题。<br>&emsp;&emsp;在第一天结束的时候,我对我这一天进行了总结，因为我感觉我很懵，感觉自己一直在神游，除了可以提一提建议，可以说没有做别的任何事。决定他们在建模的时候了解大概的思路，我就去找找文献，看一下所用到的方法。可以为后面的写作做好准备。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>&emsp;&emsp;因为第二题中a问用到了NLP文本情感分析，在了解学习之后需要需要用到python来进行机器学习。我想我学习过python看看能不能在网上找一下代码看看，能不能跑。但是我又再次错了，我装上了库。库不能运行，我也一直找不出问题。寻求开发者文档也没有结果。到最后我也跑成功，除了知道了大家用了什么方法，想干什么之外。我还是什么也不知道干什么。直到晚上我才明白，我应该开始写作。把要用到的图表先画上去，把$\LaTeX$用的图片环境都给配置好。为后面写作做节省时间。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>&emsp;&emsp;到第三天，也就到最后的冲刺阶段了，但是我们在之前的b题出现了一些新的问题，感觉在后面的拟合效果不好是不是我们的方法出现了问题，这也导致我们本就不自信的c题和d题，需要有所改动。当时我时我知道如果我们不加快进度可能时间会不太够。因为我们在第二天晚上就开始写了问题分析，稍微解决了一些写作上的问题，但是后面主题部分，模型的建立，模型的步骤、推广、在问题中的实际应用，也都没写，也就是我的失职。本应该同时经行的地方我确把这写东西寄托在别人身上。</p><h1 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h1><p>&emsp;&emsp;到了晚上8点，也就是说我们距离美赛结束还剩最后的16个小时。我们的主题部分，还又最为重要的摘要还没写。我从8点开始写摘要一直到10点才写完。我本人为自己写的很好。但是实际确实，完全没不了。完全不可能用在我们的论文中。这也就浪费了很多时间。在模型的建立部分我只是从阿凡那里获得，几乎是他所完成的。当时我们也比较急，当时他说你到低干了啥的时候确实十分内疚，我真的干了啥，我真的有在做什么…<br>&emsp;&emsp;之后我最不愿意看到的地方出现了，<code>我的</code> $\LaTeX$ <code>编译不了了</code>，这也是我从来没有遇到过的问题。我写了100次的$\LaTeX$也遇见过一些问题，但是今天在翻译复制上的之后出现的问题我也是第一次遇到，一直编译不过我是真的急了，当时看到时间已经凌晨了，如果再不解决我们就很有可能面临着无法提交的问题。我试用了各种方法，来解决。但是就是无法解决…然后我下载了TeXstduio,看看能不能有所改进，然后我才发现是“_”的问题，我也没有转义就一直无法编译…<br>&emsp;&emsp;但是这还没完，我在机翻复制之后表格环境还是出现了问题。因为实在不知道怎么解决，只能手画了…，然后还是阿凡，不断给我法写好的表格代码，才稍微加快的进度。眼看时间已经2点了，距离比赛还剩6个小时了。我还在翻译a题，我真的很慌，再加上不时出现的图片浮动位置变化的问题，对于复杂公式我也开始不能快速的书写出来，可以说完全写不了。还是只能在帮助下才能完成….</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我终于在7点左右把所有的问题都给完成了，我的两个好朋友也陪着我一起整整一夜没有睡觉。我也很感谢他们在最后也没有没指责我，因为我的原因，导致了整个队伍在最后如此狼狈的完成了这次的比赛。到了最后大家还在讨论是否能在最后把我们的论文做一下改进，做一下优化。直到最后在发送比赛邮件的时候，这似乎真的都成了历史，真的是一次非常难忘且独特的经历，看到大家那么努力的建模，却在最后应该我负起责任的时候出现了这么严重了的问题。这本来就是一个团队每个人每个环节都应该认真完成的比赛，要是有一环出现问题，那么到最后也是功亏一篑。而我就是那最后一环，原本想用$\LaTeX$来进行一次完美的排版，到了最后确实这样的结果。</p><h1 id="明白"><a href="#明白" class="headerlink" title="明白"></a>明白</h1><p>&emsp;&emsp; 原本我是不打算写这边回忆的，但是不记录一下却又十分而可惜，由于我的参与感太低，几乎在整个团队中没有做到一点贡献，到了我在应该。<br>做出贡献的时候我确掉了链子，掉链子似乎真的成为了我的专有名词，大家都说我靠不住。一开始我还不理解，直到现在我才<br>明在为什么，从赛前准备开始我的准备就不足，虽然知道自己的在哪方面存在问题存在不足。但是我还是存在不足的问题，感<br>觉自己已经准备好了，但是自己完全认识到事情真正是什么情况。总是逃避问题，不愿意去认识到错误。总觉得自己懂，觉得自己可以，但往往还是不明白。“哦，你又懂了”我一直告诉自己要谦逊，要虚心接受。但是我直到，现在我还没有想到问题的<br>本质是什么。但是通过这件事情，我才明白我为什么无法明白，是因为一直都逃避，不愿意接受别人本来就比自己强，自己本来就不明白，却非要不懂装懂。这才是我无法虚心接受的原因，如果对一些知识没了解过，就完全没有资格去说自己明白了，说别人说不对。<br>&emsp;&emsp;学长说我太浮躁，也是我一直的诟病。我也一直把阿凡作为我的现在榜样，希望能赶超他。如果我现在还是这种，对自己一直自我感觉良好的的状态，别说是望其项背了，可能就是只剩下望尘莫及了。直面逃避的问题，才是我应该做的。而不是说我要好好努力就行了。通过这次比赛我明白了很多，真正认识到了自己应该去努力的方向。寒假认识了GZTime,<br>我也应该明白了我后面发展方向。感觉就之前的经历都没有美赛这么锻炼人，虽然很难但是我认为我有必要再参加一次。好好的向我的两位好朋友好好道歉。在后面的时日里好好努力，去消除那本来就很大的差距，去弥补那缺失的学习能力.去成为一<br>为一个稳健且说到做到的人。</p><h2 id="后面是因为我而没用上的插图"><a href="#后面是因为我而没用上的插图" class="headerlink" title="后面是因为我而没用上的插图"></a>后面是因为我而没用上的插图</h2><p><img src="/img/WordArt.jpeg" srcset="/img/loading.gif" alt=" "><br><img src="/img/WordArt(1" srcset="/img/loading.gif" alt=" ">.jpeg)<br><img src="/img/WordArt(2" srcset="/img/loading.gif" alt=" ">.jpeg)<br><img src="/img/WordArt(3" srcset="/img/loading.gif" alt=" ">.jpeg)<br><img src="/img/WordArt(4" srcset="/img/loading.gif" alt=" ">.jpeg)</p><font color="#7ea497">致谢：阿凡、阿豪</font><font color="#f4f4f4">(虽然我不喜欢这种阿什么什么的称呼）</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mcm写作基本流程</title>
    <link href="/2020/03/05/mcm%E5%86%99%E4%BD%9C/"/>
    <url>/2020/03/05/mcm%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>美赛的基本写作流程</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过对优秀文章的阅读，美赛的文章有相对固定的写作套路。大部分都分为：</p><ul><li>摘要</li><li>问题重述<ul><li>问题背景</li><li>问题重述</li></ul></li><li>问题分析<ul><li>对问题一分析</li><li>对问题二分析</li><li>对问题三分析</li></ul></li><li>模型假设</li><li>符号说明</li><li>模型的建立与求解<ul><li>问题一</li><li>问题二</li><li>问题三</li></ul></li><li>模型的分析建议</li><li>模型的评估与优化</li><li>参考文献</li><li>附录</li></ul><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>摘要一般第一段写对问题总体环境的概述，第二段开始一般是回答第一个问题，第二段对第二个问题进行分析，第三段对三个问题分析。一般摘要的三段或四段都是与题目相对应。题目一般都是循序渐进，逐步解决问题。最后就是$\textbf{keywords}$ 这个就主要写所使用的模型。</p><h1 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h1><p>这个没什么好说得，就直接把问题重新再抄写一下就可以了，分为问题背景和问题重述</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>问题分析这部分就是对每个小问题，分别建模讨论使用得模型对所寻找的数据或题目所给的数据进行分析。然后再对得到的数据进行预测建立模型，</p><p>….</p><p>后面的就是独家内容了，嘿嘿嘿。晚点再更新….</p>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用LaTex编写流程图</title>
    <link href="/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/"/>
    <url>/2020/03/04/LaTex%E6%8F%92%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>简单介绍如何使用$\LaTeX$进行流程图的绘制</p><a id="more"></a><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/img/流程图.png" srcset="/img/loading.gif" alt=" "></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>\documentclass[UTF8]{ctexart}\usepackage{tikz} %%主要宏包\usetikzlibrary{shapes,arrows}\begin{document}\pagestyle{empty} % 无页眉页脚\tikzstyle{startstop} = [rectangle,rounded corners, minimum width=3cm,minimum height=1cm,text centered, draw=black,fill=red!30]\tikzstyle{io} = [trapezium, trapezium left angle = 70,trapezium right angle=110,minimum width=3cm,minimum height=1cm,text centered,draw=black,fill=blue!30]\tikzstyle{process} = [rectangle,minimum width=3cm,minimum height=1cm,text centered,text width =3cm,draw=black,fill=orange!30]\tikzstyle{decision} = [diamond,minimum width=3cm,minimum height=1cm,text centered,draw=black,fill=green!30]\tikzstyle{arrow} = [thick,-&gt;,&gt;=stealth]\begin{tikzpicture}[node distance=2cm]\node (start) [startstop] {Start};\node (input1) [io,below of=start] {Input};\node (process1) [process,below of=input1] {Process 1};\node (decision1) [decision,below of=process1,yshift=-0.5cm] {Decession 1};\node (process2a) [process,below of=decision1,yshift=-0.5cm] {Process 2aaaaaa aaaaaaa aaaa};\node (process2b) [process,right of =decision1,xshift=2cm] {Process 2b};\node (out1) [io,below of=process2a] {Output};\node (stop) [startstop,below of=out1] {Stop};\draw [arrow] (start) -- (input1);\draw [arrow] (input1) -- (process1);\draw [arrow] (process1) -- (decision1);\draw [arrow] (decision1) -- node[anchor=east] {yes} (process2a);\draw [arrow] (decision1) -- node[anchor=south] {no} (process2b);\draw [arrow] (process2b) |- (process1);\draw [arrow] (process2a) -- (out1);\draw [arrow] (out1) -- (stop);\end{tikzpicture}\end{document}</code></pre><h2 id="using-package"><a href="#using-package" class="headerlink" title="using package"></a>using package</h2><p>$\LaTeX$中绘图均要引入<code>tikz</code>宏包</p><pre><code>\usepackage{tikz}\usetikzlibrary{shapes.geometric, arrows}</code></pre><h2 id="对节点node进行定义"><a href="#对节点node进行定义" class="headerlink" title="对节点node进行定义"></a>对节点node进行定义</h2><pre><code>\tikzstyle{process} = [rectangle,minimum width=3cm,minimum height=1cm,text centered,text width =3cm,draw=black,fill=orange!30]</code></pre><h3 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h3><pre><code>rectangle:矩形，可加圆角(rounded corners)trapezium:平行四边形diamond:菱形</code></pre><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><pre><code>minimum widthminimum height</code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><pre><code>text centered:文本居中</code></pre><h3 id="文本宽度"><a href="#文本宽度" class="headerlink" title="文本宽度"></a>文本宽度</h3><pre><code>text width=3cm:文本超过3cm时会自动换行</code></pre><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><pre><code>draw</code></pre><h3 id="填充颜色"><a href="#填充颜色" class="headerlink" title="填充颜色"></a>填充颜色</h3><pre><code>fill</code></pre><h2 id="对箭头进行定义"><a href="#对箭头进行定义" class="headerlink" title="对箭头进行定义"></a>对箭头进行定义</h2><pre><code>tikzstyle{arrow} = [thick,-&gt;,&gt;=stealth]</code></pre><h3 id="线粗"><a href="#线粗" class="headerlink" title="线粗"></a>线粗</h3><pre><code>thick:粗thin:细</code></pre><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><pre><code>-&gt;:反向箭头&lt;-:正向箭头&lt;-&gt;:双向箭头</code></pre><h3 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h3><pre><code>dashed</code></pre><h3 id="箭头形状"><a href="#箭头形状" class="headerlink" title="箭头形状"></a>箭头形状</h3><pre><code>&gt;=stealth</code></pre><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><pre><code>\node (decision1) [decision,below of=process1,yshift=-0.5cm] {Decession 1};</code></pre><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><pre><code>(decision1):这个节点的name，后面需要用这个name调用这个节点。</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>decision：需要调用的节点的属性</code></pre><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><pre><code>below of=process1：定义节点的位置left of:right of:</code></pre><h3 id="偏移-对位置进行微调"><a href="#偏移-对位置进行微调" class="headerlink" title="偏移,对位置进行微调"></a>偏移,对位置进行微调</h3><pre><code>yshift:xshift:</code></pre><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><pre><code>{Decession 1}:结果显示的标题</code></pre><h2 id="画箭头"><a href="#画箭头" class="headerlink" title="画箭头"></a>画箭头</h2><pre><code>\draw [arrow] (decision1) -- node[anchor=east] {yes} (process2a);</code></pre><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><pre><code class="lang-[arrow]:需要调用的箭头的属性```">```(decision1)：箭头的其实位置</code></pre><pre><code class="lang-(process2a)：箭头的末端位置```">### 线型</code></pre><p>—：直线<br>|-：先竖线后横线<br>-|：向横线后竖线</p><pre><code>### 文字：如果需要在箭头上添加文字```{yes}:需要添加的文字</code></pre><h3 id="文字的位置-上南下北左东右西-与地图方位不一致"><a href="#文字的位置-上南下北左东右西-与地图方位不一致" class="headerlink" title="文字的位置,上南下北左东右西(与地图方位不一致)"></a>文字的位置,上南下北左东右西(与地图方位不一致)</h3><pre><code>[anchor=east]：[anchor=south]：[anchor=west]：[anchor=north]：[anchor=center]：</code></pre>]]></content>
    
    
    <categories>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cellular automata</title>
    <link href="/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2020/02/29/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>元胞自动机(cellular automata，CA) 是一种时间、空间、状态都离散，空间相互作用和时间因果关系为局部的网格动力学<br>模型，具有模拟复杂系统时空演化过程的能</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>元胞自动机是一个空间和状态都是离散的模型。该模型可以用一个四元组表示：</p><script type="math/tex; mode=display">C=(L_a, S, N_n, f)</script><p>其中：</p><ul><li>$S$表示细胞状态，是一个有限的、离散的状态集合；</li><li>$L_a$表示元胞空间，$a$是一个整数，表示细胞空间的维数；</li><li>$N$表示领域内元素的组合，$n$表示邻居的个数</li><li>$f$表示状态转移函数，即状态转移规则</li></ul><h2 id="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。"><a href="#对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元-有时也称作邻居-。" class="headerlink" title="对于一个元胞，在空间位置上与它相邻的元胞称为它的邻元(有时也称作邻居)。"></a>对于一个元胞，在空间位置上与它相邻的元胞称为它的<strong>邻元</strong>(有时也称作邻居)。</h2><p>邻域和邻元的定义可以是多样的</p><p>下图为一维CA网格邻域定义<br><img src="/img/一维CA网格.png" srcset="/img/loading.gif" alt=" "></p><p>下图为二维CA网格邻域定义<br><img src="/img/二维CA网格.png" srcset="/img/loading.gif" alt=" "></p><p>每个元胞有若干个状态，如：</p><ul><li>物理系统：（分子）固态，液态</li><li>生物系统：（细胞）死or活</li><li>社会系统： （个人）相信与不相信谎言</li><li>政治系统： （国家）战争与妥协…</li></ul><hr><p>&emsp;&emsp;在各种CA模型中，每个等份（单元格）代表一个元胞，CA的网格可以有不同的形式(维数，大小)。</p><ul><li>一维的CA模型是将直线分成若干相同的等份；</li><li>二维的CA模型是将一个平面分成许多正方形、六边形或三角行的网格（最常见的是将其划分成正方形）；</li><li>三位的CA模型将空间划分成许多立体网格。</li></ul><p><img src="/img/一维CA模型.png" srcset="/img/loading.gif" alt=" "> &emsp;&emsp; <img src="/img/二维CA模型.png" srcset="/img/loading.gif" alt=" "></p><hr><p>根据每个元胞及邻元的不同状态，由于状态更新规则决定这个元胞下一个时刻的状态。</p><p>序号$i$个体在$t=1,\dots,n$时刻的状态:</p><script type="math/tex; mode=display">S_t^{t+1}=f(S_i^t,N^t)=f(S_i^t,S_1^t,S_2^t,\dots,S_n^t)</script><p>其中$S_i^t,S_1^t,S_2^t,\dots,S_n^t$为个体$i$的邻元在$t$时刻的状态。</p><hr><p>规则可以是确定型的，也可以是随机型的。对于一个一维的CA，一个细胞具有两种可能的状态如生or死，相信或者不相信等等，表示为0or1.<br>如果规则一：我使用下图的左边的邻元定义<br>定义其状态更新规则：当一个个体的两个邻元都活或都死，该个体在下一时刻为死；反之，他的状态在下一时刻变为活。<br><img src="/img/规则表.png" srcset="/img/loading.gif" alt=" "></p><p>再如规则二：我仍然使用当前左边邻元定义，但重新定义其状态<br>更新规则为：当个体的两个邻元都活或都死，该个体再下一时刻<strong>改变状态</strong>;反之，<strong>该个体的状态在下一时刻保持不变</strong>。<br><img src="/img/规则表（2）.png" srcset="/img/loading.gif" alt=" "></p><hr><p>模型的构建</p><p>考虑以下问题：</p><ul><li>确定系统中有那些个体，如何分类？</li><li>个体有几种状态，分别是什么；</li><li>个体所处空间形式，是一位，二维还是多为；</li><li>个体的邻元形式及个数，这与网格形式及交互群体规模有关</li><li>根据个体状态、网格形式及邻元，确定个体状态的演变规则。<br>此外，还需确定：</li><li>系统中的个体与单元格是否一致。<br>简单的、经典的CA模型中，单元格与个体不加区分，每个单位格就是一个个体，个体始终在单元格中，个体的状态即为单元格的状态。但在一些复杂系统中，尤其在个体可以移动的系统中，将个体与单元格区分更为方便。</li><li>系统中是否离散事件。<br>采用CA模型描述的系统，每个时刻都需根据规则确定伟哥元胞的状态。除此之外，有的系统中某些个体会在特定时刻（有条件或无条件）发生状态变化，此时可以采用离散时间仿真方法，将该时刻列入事件表，根据事件表处理该类事件。</li></ul><font color="#f4f4f4"><a href="https://wenku.baidu.com/view/86050cb9aeaad1f347933f28.html" target="_blank" rel="noopener">推荐</a></font><font color="#f4f4f4">python 库中pandas 如果使用 pip install pandas 可以能会无法下载。如果无法下载则使用</font><pre><code>pip --default-time=100 install pandas</code></pre><font color="#f4f4f4">这行命令，可以进行下载。</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mathematical</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力-2</title>
    <link href="/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/27/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148814143&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;First a city with a population of 11 million was shut down and than a country of 1.4 billion people came to a halt. Most people have shown concern and understanding. Whenever there is a public health concern, people tend to react strongly, however some have allowed the fear to turn into bias. But sometimes the reaction is over the top. people have effectively closed borders, shouted hateful words and drive others away indiscriminately. Some have called the novel coronavirus the China Virus. We wrongly called the 1918 pandemic the Spanish Flu, and with better knowledge and conscience we never call AIDS or Ebola an African virus, because we don’t want people to associate a pathogen with a place or people, and we shouldn’t.<br>&emsp;&emsp;Coronacirus is feeding bias and discrimination against people, people from Wuhan and China, people across the aisle and in the neighborhood. It is understandable that people are panicking in the face of a big unknown. But we have a rough idea about this virus; it is highly infectious, and not as deadly as SARS. We wash hands, wear masks, keep our hygiene and keep ourselves happy to let the immune system do its work. Draconian isolation policy during the 14-day incubation will help us identify more cases. And hopefully the virus will burn out eventually or its impact will be mitigated when our immune systems with the help of supportive care will win out at last.<br>&emsp;&emsp;But discrimination will take its toll. The disregard of AIDS patients during the 1970s drove them underground and undetected, resulting in a large outbreak. And similar messaging on Ebola<br>made matters worse in 2014 in West Africa. In history we have treated leprosy, AIDS and even flu patients like outcast, partly because we were unable to deal with the disease, but largely because we could not understand the threat. But now we do.<br>&emsp;&emsp;Virus know no boundaries, be it AIDS, the flu SARS or 2019-nCoV. An epidemic of global scale demands the sharing of information, resources and moral support. Quarantines might work for a while, but it won’t last and it won’t solve all problems. We are now in a gigantic prisoner’s dilemma, the incentive to turn against each other is so strong even though banding together works better. Bias hurts your interests, you just don’t know yet.<br>&emsp;&emsp;In our modern, borderless world. We aren’t living in villages anymore. Even though we may pay a price dealing with strangers, we still do and we are better off because of it. </p><p><i>This is the time for facts, not fear. This is the time for science, not rumors. This is the time for solidarity, not stigma.</i><br>$\textbf{Dr.Tedros Adhanom Gheberyesus}—Director-General World Health Organization$</p>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wget、yum、rpm、apt-get都是啥？</title>
    <link href="/2020/02/27/yum/"/>
    <url>/2020/02/27/yum/</url>
    
    <content type="html"><![CDATA[<p>简略介绍wget、yum、rpm、apt-get。<br>详细了解yum</p><a id="more"></a><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p><strong>wget</strong>:类似于迅雷，是一种<code>下载工具</code>，通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理 名字是World Wide Web”与“get”的结合。</p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><strong>yum</strong>: 是redhat, centos 系统下的<code>软件安装方式</code>，基于Linux,全称为 Yellow dog Updater, Modified,是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器,基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><h3 id="yum常用选项和参数"><a href="#yum常用选项和参数" class="headerlink" title="yum常用选项和参数"></a>yum常用选项和参数</h3><h4 id="列举包文件"><a href="#列举包文件" class="headerlink" title="列举包文件"></a>列举包文件</h4><hr><pre><code>yum list #列出资源库中所有可以安装或更新的rpm包yum list updates　#列出资源库中所有可以更新的rpm包yum list installed　　#列出已经安装的所有的rpm包yum list extras　　#列出已经安装的但是不包含在官方资源库中的rpm包，例如安装了epel源的rpm包会列出来</code></pre><h4 id="列举资源信息"><a href="#列举资源信息" class="headerlink" title="列举资源信息"></a>列举资源信息</h4><hr><pre><code>yum info　　#列出资源库中所有可以安装或更新的rpm包的信息yum info perl　　#列出perl包信息yum info perl*　　#列出perl开头的所有包的信息yum info updates　　#列出资源库中所有可以更新的rpm包的信息yum info installed　　#列出已经安装的所有的rpm包的信息yum info extras　　#列出已经安装的但是不包含在资源库中的rpm包的信息</code></pre><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><hr><pre><code>yum search perl　#搜索匹配特定字符的rpm包，在包名称、包描述等中搜索yum provides libstdc++.so.6　　#反查包含特定文件名的rpm包，查询命令用yum provides */ifconfig，查询文件无需*/ 也可用yum whatprovides</code></pre><h4 id="管理包"><a href="#管理包" class="headerlink" title="管理包"></a>管理包</h4><hr><ul><li>安装rpm包<pre><code>yum install perl　　#安装perl包yum install perl*　　#安装perl开头的包yum remove perl* 　　#会删除perl* 所有包，以及相关依赖的包</code></pre></li><li>软件组件管理<pre><code>yum groupinstall &quot;Chinese Support&quot;　　#安装指定的组yum groupupdate &quot;Chinese Support&quot;　　#安装了的组成员软件包更新yum grouplist　　#安装了的组和可以安装的组一览显示yum groupremove &quot;Chinese Support&quot;　　#删除指定的组yum groupinfo &quot;Chinese Support&quot;　　#指定组所包含的软件包显示</code></pre><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4></li></ul><hr><pre><code>yum check-update　　#检查可更新的rpm包yum update　　#更新所有的rpm包yum update kernel kernel-source　　#更新指定的rpm包,如更新kernel和kernel sourceyum upgrade　　#大规模的版本升级,与yum update不同的是,连旧的淘汰的包也升级</code></pre><h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><hr><pre><code>yum clean packages　　#清除暂存中rpm包文件yum clean headers　　#清除暂存中rpm头文件yum clean oldheaders　　#清除暂存中旧的rpm头文件yum clean all　　#清除暂存中旧的rpm头文件和包文件</code></pre><h4 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h4><pre><code> -q #静默执行 -t #忽略错误 -R[分钟] #设置等待时间 -y #自动应答yes --skip-broken #忽略依赖问题 --nogpgcheck #忽略GPG验证</code></pre><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p><code>rpm</code>:软件管理;</p><p>redhat的软件格式 <code>rpm</code>  <code>r=redhat</code>  <code>p=package</code>   <code>m=management</code> 用于安装 卸载 <code>.rpm</code>软件</p><p>串联下：<br>&emsp;&emsp;使用<code>wget</code>下载一个 <code>rpm</code>包, 然后用<code>rpm -ivh xxx.rpm</code> 安装这个软件，嫌麻烦的话，就可以直接用 <code>yum  install  sqoop</code> 来自动下载和安装依赖的 <code>rpm</code>软件。</p><h2 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h2><p><code>apt-get</code>:是ubuntu下的一个软件安装方式，它是基于debain.</p><h2 id="通过yum安装工具"><a href="#通过yum安装工具" class="headerlink" title="通过yum安装工具"></a>通过yum安装工具</h2><h3 id="在Centos上安装gcc"><a href="#在Centos上安装gcc" class="headerlink" title="在Centos上安装gcc"></a>在Centos上安装gcc</h3><p>安装gcc</p><blockquote><p>yum -y install gcc</p></blockquote><p>安装g++</p><blockquote><p>yum -y install gcc-c++  </p></blockquote><h3 id="在Centos上安装目录生成树工具tree"><a href="#在Centos上安装目录生成树工具tree" class="headerlink" title="在Centos上安装目录生成树工具tree"></a>在Centos上安装目录生成树工具tree</h3><p>安装tree</p><blockquote><p>yum -y install tree</p></blockquote><p>同通过tree工具可以很快的查看目录树</p><h4 id="关于tree命令选项"><a href="#关于tree命令选项" class="headerlink" title="关于tree命令选项"></a>关于tree命令选项</h4><ul><li><code>-a</code> 显示所有文件和目录。</li><li><code>-A</code> 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li><li><code>-C</code> 在文件和目录清单加上色彩，便于区分各种类型。</li><li><code>-d</code> 显示目录名称而非内容。</li><li><code>-D</code> 列出文件或目录的更改时间。W</li><li><code>-f</code> 在每个文件或目录之前，显示完整的相对路径名称。</li><li><code>-F</code> 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/”,”=”,”@”,”|”号。</li><li><code>-g</code> 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li><li><code>-i</code> 不以阶梯状列出文件或目录名称。</li><li><code>-I</code>&lt;范本样式&gt; 不显示符合范本样式的文件或目录名称。</li><li><code>-l</code> 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li><li><code>-n</code> 不在文件和目录清单加上色彩。</li><li><code>-N</code> 直接列出文件和目录名称，包括控制字符。</li><li><code>-p</code> 列出权限标示。</li><li><code>-P</code>&lt;范本样式&gt; 只显示符合范本样式的文件或目录名称。</li><li><code>-q</code> 用”?”号取代控制字符，列出文件和目录名称。</li><li><code>-s</code> 列出文件或目录大小。</li><li><code>-t</code> 用文件和目录的更改时间排序。</li><li><code>-u</code> 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li><li><code>-x</code> 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li></ul><h4 id="在Centos下安装git"><a href="#在Centos下安装git" class="headerlink" title="在Centos下安装git"></a>在Centos下安装git</h4><p>首先检查机器上是否有git</p><blockquote><p>git —version</p></blockquote><p>如果出现了版本号则说明有<code>git</code>，如果是<code>bash：git：no found command</code>则说明没有<code>git</code>。</p><p>如果没有git工具：</p><blockquote><p>yum info git #查看<code>yum</code>源中的<code>git</code>版本<br>yum -y install git #安装git</p></blockquote><p>当出现<code>complete！</code>就表明安装完成</p><h4 id="在Centos下升级vim"><a href="#在Centos下升级vim" class="headerlink" title="在Centos下升级vim"></a>在Centos下升级vim</h4><h5 id="检查机器上是否有vim"><a href="#检查机器上是否有vim" class="headerlink" title="检查机器上是否有vim"></a>检查机器上是否有vim</h5><blockquote><p>rpm -qa|grep vim</p><p>如果以安装则会显示<br>vim-minimal-7.4.629-6.el7.x86_64<br>vim-filesystem-7.4.629-6.el7.x86_64<br>vim-enhanced-7.4.629-6.el7.x86_64<br>vim-common-7.4.629-6.el7.x86_64<br>vim-X11-7.4.629-6.el7.x86_64</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>如果缺少了其中某个，比如说： vim-enhanced这个包少了，则执行：<br>yum -y install vim-enhanced</p></blockquote><p>它会自动下载安装。如果上面三个包一个都没有显示，则直接输入命令：   </p><blockquote><p>yum -y install vim*</p></blockquote><h5 id="检查vim版本"><a href="#检查vim版本" class="headerlink" title="检查vim版本"></a>检查vim版本</h5><blockquote><p>vim —version</p></blockquote><p>如果想升级更高版本的vim</p><pre><code>sudo yum remove vim -y # 移除旧版本sudo yum install ncurses-devel python-devel -y # 安装必要组件git clone https://github.com/vim/vim.git  #下载源码编译安装cd vim/src./configure --with-features=huge --enable-pythoninterp=yes --enable-cscope --enable-fontset --with-python-config-dir=/usr/lib64/python2.7/config --enable-python3interp=yes --with-python-config-dir=/usr/lib/python3.6/config --enable-multibyte --prefix=/usr/local/vim/ # 根据自己实际情况设置编译参数make -j2 &amp;&amp; make install</code></pre><h1 id="conda环境"><a href="#conda环境" class="headerlink" title="conda环境"></a>conda环境</h1><h2 id="进入虚拟环境，使用"><a href="#进入虚拟环境，使用" class="headerlink" title="进入虚拟环境，使用"></a>进入虚拟环境，使用</h2><pre><code> $ conda activate spider-venv</code></pre><h2 id="退出虚拟环境，使用"><a href="#退出虚拟环境，使用" class="headerlink" title="退出虚拟环境，使用"></a>退出虚拟环境，使用</h2><pre><code> $ conda deactivate</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Centos</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日英语听力</title>
    <link href="/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/"/>
    <url>/2020/02/26/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>跟着CGTN学英语</p><a id="more"></a><h1 id="听力部分"><a href="#听力部分" class="headerlink" title="听力部分"></a>听力部分</h1><center><iframe src="//player.bilibili.com/player.html?aid=87085504&cid=148815381&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" ></iframe></center><hr><h3 id="英文全文"><a href="#英文全文" class="headerlink" title="英文全文"></a>英文全文</h3><p>&emsp;&emsp;It has been a month since Wuhan was <code>locked down</code> because of the <code>coronavirus</code>. Like a big <code>push on</code> a swing, the <code>epidemic</code> <code>tips</code> the balance in the world, and China is making effort to keep standing. The challenge <code>lies in</code> the country’s size, China is a big country with a large span, and the virus hit the center, <code>literally</code>. The <code>epicenter</code> is a <code>metropolis</code> of 16 million people in the middle of the country. To make matters worse, it is surrounded by many cities, also with millions of inhabitants.<br>&emsp;&emsp;Wuhan is a transport hub, and the virus is threatening to infect the whole surrounding area. The size of the country is a significant obstacle. But that’s only half the story. Because of its continental size, all the parts feed off each other. When Wuhan fell, the other provinces came to its aid.<br>&emsp;&emsp;As we speak, one-tenth of the intensive care doctors of the entire country is in Wuhan. A total of 40,000 medical staff moved to the center in a wartime fashion. China plans to take the virus full on.<br>&emsp;&emsp;Structure matters, another weight on scale is messaging. China has two-way traffic of communication, top-down and bottom-up. China is to do better bottom-up. When doctors in Wuhan sounded alarms of the new virus, the message got lost. An investigation is still ongoing on why. But one reason is obvious: there are too many layers, too much red tape, and too little incentives to send the messages up.<br>&emsp;&emsp;But China is strong when it comes to top-down messages. When the leadership is on the top of the problem, it has the willpower and wherewithal to make the call. And the grassroots answer. China launched a people’s war. That was exactly what was needed to deal with a traveling threat like an epidemic. China built two hospitals in 10 days, thousands of wards in a week, and shook the population into action. Top-down is fast and sharp. Nobody should argue against efficiency, especially when what’s at shake is a plague spreading. But keeping the balance is hard.<br>&emsp;&emsp; Every decision is a trade-off when it affects the lives of thousands and the livelihood of millions. We need to slow the spread. Draconian quarantines are being enforced in many parts of the country. Maintain a large network of isolation and a low rate of rogue behavior is the answer; the question is we still don’t know the exact extent of the infection. Isolating the infected while not infringing on people’s rights and decency is not an easy task.<br>&emsp;&emsp;Our economy relies on human transaction, but epidemic control depends on social distancing. We need to keep a distance, and yet we need to work together. So how do we balance saving lives and the saving economy? This is an issue that requires hard decision making. But the hardest is when to draw the line. With so little information on an adversary like the virus and so few weapons at out disposal, without treatment or vaccines, we are not able to answer the public’s question: when does it end?<br>&emsp;&emsp;Before the end of the Second World War, Winston Churchill described the war like this: <code>Victory at all costs, victory in spite of all terror, victory however long and hard the road may be, for without victory, there is no survival. Now, we are at war with a virus. And victory is still ahead of us</code>. Luckily, we still have a big country to fall back on, a world that lifts us, and s system that delivers results. There will be more hard decisions to be made. In the end, we hope those will be the best choices, and we must be proud of them. </p><hr><h3 id="词句"><a href="#词句" class="headerlink" title="词句"></a>词句</h3><ul><li><strong>locked down</strong>:锁定，封锁.</li><li><strong>coronavirus</strong>:n. 冠状病毒.</li><li><strong>push on</strong>: 推， 推进.</li><li><strong>epidemic</strong>: [ˌepɪˈdemɪk] n.流行病;(迅速的)泛滥，蔓延; adj.流行性的;极为盛行的.</li><li><strong>tip</strong>: n.尖端;尖儿;端;(装在顶端的)小部件;指点;实用的提示;</li><li><strong>lie in</strong>: 在于; lie(平躺， 撒谎).</li><li><strong>literally</strong>: adv.按字面;字面上;(强调事实可能令人惊讶)真正地，确实地;(加强即使字面意义并不真实的词语)简直;</li></ul><font size="3" color="#c2cb81"> 若有错误请在评论区指正！蟹蟹大家</font>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>Listen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器</title>
    <link href="/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/"/>
    <url>/2020/02/22/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(4)/</url>
    
    <content type="html"><![CDATA[<p>容器简介</p><a id="more"></a><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="概述"><a href="#概述" class="headerlink" title="- 概述"></a>- 概述</h3><ul><li>Vector是一个能够存放任意类型的动态数组</li><li>Vector的数据结构和操作与数组(array)类似，在内存中的表现形式是一段地址连续的空间</li><li>Vector与数组的区别在于，数组大小往往是定义是固定的(比如：char buffer[256]);Vec支持动态空间大小调整，随着空间的变化Vector内部会自动扩充内存空间</li><li>为了试用Vector，必须试用include指令包含该头文件,并通过std空间去访问：<pre><code>include &lt;vector&gt;int main() {  std :: vector v;}</code></pre></li></ul><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空vector</td><td>std :: vector<T> v;</td></tr><tr><td>创建一个容器是n的T类型的vector</td><td>std :: vector<T> v(n);</td></tr><tr><td>创建一个容量是n的T类型的vector，并且都初始化为i</td><td>std :: vector<T> n(n, i);</td></tr><tr><td>创建一个已有v的拷贝</td><td>std :: vector<T> copyOfV(v);</td></tr><tr><td>荣国一个数组创建一个vector</td><td>int array[] = {1,2,3}; std :: vector<int> v(array, array + 10);</td></tr></tbody></table></div><h3 id="向vector添加元素"><a href="#向vector添加元素" class="headerlink" title="向vector添加元素"></a>向vector添加元素</h3><p>向vector添加元素的方法为调用其push_back()函数，表示将元素添加至其尾部：</p><pre><code>std :: vector &lt;std :: wstring&gt; v3;for (std :: size_t i = 0; i &lt; 10; ++ i) {    std :: wstringstream wss;    wss &lt;&lt; TEXT(&quot;String[&quot;) &lt;&lt; i &lt;&lt; TEXT(&quot;]&quot;);    v3.push_back(wss.str());}</code></pre><h3 id="判断vector是否为空、获取vector大小"><a href="#判断vector是否为空、获取vector大小" class="headerlink" title="判断vector是否为空、获取vector大小"></a>判断vector是否为空、获取vector大小</h3><ul><li>如果要判断vector是否为空则调用empty()函数</li><li><p>如果要获取vector大小则调用size()函数</p><pre><code>std :: vector &lt;std :: wstring&gt; v3;bool isEmpty = v3.empty();int array[] = {1,2,3,4,5,6,7,8,9,10};std :: vector&lt;int&gt; v(array, array + 10)std :: size vSize = v.size();</code></pre></li></ul><h3 id="访问vector中元素"><a href="#访问vector中元素" class="headerlink" title="访问vector中元素"></a>访问vector中元素</h3><ul><li>要访问vector中的元素, 有两种方法：<ul><li>调用vector :: at()</li><li>调用vector :: operator[]</li></ul></li><li>两者的区别在于：<ul><li>operator[]提供了类似数组的存取方式，但不做边界的检查，有可能越界，但访问效率更高</li><li>at()进行边界检查，如果访问越界则抛出exception，但是访问效率不如operator[]</li></ul></li></ul><pre><code>std :: vector&lt;std::wstring&gt; v;v.reserve(10);for (std::size_t i = 0; i &lt; 3; ++ i) {    std :: wstringstream wss;    wss &lt;&lt; TEXT(&quot;String[&quot;) &lt;&lt; i &lt;&lt; TEXT(&quot;]&quot;);    v.push_back(wss.str());}try {    std :: wstring wsz1 = v[5]; // not bounds checked -will not throw    std :: wstring wsz2 = v.at(5); // bounds checked -will throw if out of range}catch (const std :: exception&amp; ex) {    Console :: WriteLine(ex.what());}</code></pre><h3 id="删除vector中的元素"><a href="#删除vector中的元素" class="headerlink" title="删除vector中的元素"></a>删除vector中的元素</h3><ul><li>clear：清除一整个vector</li><li>pop_back：弹出vector为元素</li><li><p>erase:删除vector中某一位置的元素</p><ul><li>用法一：指定iterator删除某一元素<pre><code>std :: vector&lt;int&gt; :: const_iterator it = v.begin();v.erase(it + 1); // erase the second element in the Vector</code></pre></li><li>用法二：通过某一条件函数找到vector中需要删除的元素。所谓条件函数是一个按照用户定义的条件返回true/false的函数对象。我们以remove_if为例说明。</li><li>remove_if函数定义在algorithm中，故需要include<algorithm></li><li><p>定义筛选器：一个一元函数对象(unary_function),关键在于重载operator()</p><pre><code>struct ContainsString : public std :: unary_function &lt;std :: wstring, bool&gt; {  ContainsString (const std::wstring&amp; wszMatch) : m_wszMatch(wszMatch) {}  bool operator()(const std :: wstring&amp; wszStringToMatch) const {      //注意因为它重载了()所以可以当一个函数来用      return (wszStringToMatch.find(m_wszMatch) != 1);  }  std :: wstring m_wszMatch;}</code></pre></li><li>在erase函数中调用remove_if执行删除:<pre><code>v.erase (std :: remove_if (  v.begin(),  v.end(),  ContainsString (L&quot;C++&quot;)),v.end());</code></pre></li><li>remove_if是不是真正remove了vector中的元素呢？<br>remove_if其实真正的做的事针对ContainsString条件对给出了erase函数需要操作的iterator位置。</li></ul></li></ul><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><ul><li>概述<ul><li>Deque事一个能够存放任意类型的双向队列</li><li>Deque提供的函数与vector类似，新增了两个函数：<ul><li>push_front:在头部插入一个元素</li><li>pop_front： 在头部弹出一个元素</li></ul></li><li>Deque采用了与vector不同的内存管理方式：大块分配内存</li><li>为了试用deque，必须用include质量包含如下文件，并通过std命名空间访问：<pre><code>#include &lt;deque&gt;int main() {  std :: deque dq;}</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li></ul></li><li>概述<ul><li>List是一个能够存放任意类型的双向链表(double linked list)</li><li>可以向List中接入一个子链表(sub-list)</li><li>为了使用List，必须使用include指令包含如下文件，并通过std命名空间去访问：<pre><code>#include &lt;list&gt;int main() {  std :: list l;}</code></pre></li></ul></li></ul><p>创建List</p><div class="table-container"><table><thead><tr><th>常用方式</th><th>代码</th></tr></thead><tbody><tr><td>创建一个T类型的空list</td><td>std :: list<T> l;</td></tr><tr><td>创建一个容量是n的T类型的list</td><td>std :: list<T> l(n);</td></tr><tr><td>创建一个容量是n的T类型的list，并且初始化都为x</td><td>std :: list<T> l(n, x);</td></tr><tr><td>创建一个已有list的拷贝</td><td>std :: list<T> copyOfList(l);</td></tr><tr><td>通过一个数组创建一个list</td><td>std :: wstring array[] = {1,2,3}; std :: list<std::wstring> l(array, array + 3)</td></tr></tbody></table></div><ul><li>向list添加元素<ul><li>向list添加元素的方式为调用其push_back, push_front函数将元素添加至其尾部或头部</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型编程</title>
    <link href="/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/"/>
    <url>/2020/02/21/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B(3)/</url>
    
    <content type="html"><![CDATA[<p>泛型编程</p><a id="more"></a><h1 id="泛型编程-概观"><a href="#泛型编程-概观" class="headerlink" title="泛型编程-概观"></a>泛型编程-概观</h1><ul><li>泛型编程(Generic programming) 是一种编程方法，这种方法将类型(type)以一种to-be-specified-later的方式给出，等到需要调用的时候，再以参数方式，通过具体的、特定的类别实例化(instantiate)一个具体的方法或对象</li><li>泛型编程作为一种编程的想法或思想，不依赖具体的语言</li><li>大多数面向对象的语言(O O languages)都支持泛型编程，(只不过在C++种以模板的这种形式表现出来)比如：C++、C#、Java、Ada….</li><li>C++里面的泛型是通过<strong>模板</strong>以及相关性质表现出来</li></ul><h1 id="特性-Traits"><a href="#特性-Traits" class="headerlink" title="特性(Traits)"></a>特性(Traits)</h1><h2 id="什么是traits以及为什么使用traits？"><a href="#什么是traits以及为什么使用traits？" class="headerlink" title="- 什么是traits以及为什么使用traits？"></a>- 什么是traits以及为什么使用traits？</h2><p>  假设给定一个数组，计算数组种所有元素的和：<br>  A[0] | A[1] |…| A[n] &emsp;&emsp;$\sum_{k=0}^n A[k]$</p><ul><li><p>我们可以很直接地写出如下的计算函数:</p><pre><code>template &lt;typename T&gt; inline T Sigma(const T const* start, const T const* end) {    T total = T(); // suppose T() actually creates a zero value    //T()是一个构造函数目的将total初始化为0；    while (start != end) {        total += *start ++ ;    }    return total;}</code></pre></li><li><p>当我们使用char类型调用模板函数是，问题就来了：</p><pre><code>char szNames[] = &quot;abc&quot;;std :: size_t nLength = strlen(szNames);char* p = szNames;char* q = szNames + nLength;printf(&quot;sigma(ezNames) = %d\n&quot;, Sigma(p,q));</code></pre><script type="math/tex; mode=display">294 = 0x0126</script><script type="math/tex; mode=display">0000 | 0001 | 0010 | 0110</script><p>Char类型能hold住的最大值为0xFF = 255 也就是两个字节所以0010和0110可容纳的但是abc加起来<strong>大于255</strong>就溢出到溢出到1这个bit</p></li><li><p>调用Sigma(szNames)的结果是38( = 0x26)!而并不是所期望的值(97 + 98 + 99 = 294)</p></li><li>原因显而易见的：char无法存下这个294这个值</li><li>如果要得到正确的结果，我们就不得不强制使用int类型：<pre><code>int s = Sigma&lt;int&gt;(p,q);</code></pre></li><li>但是这种不必要的转换是完全可以避免的!</li><li>解决方法是：为每个Sigma函数的参数类型T创建一种关联(association)，关联的类别就是用来储存Sigma结果的类型</li><li>这种关联可以看作是类型T的一种特性(characteristic fo the type T),因为sigma函数返回值的类型叫做T的trait</li><li>T与其trait的关系推演如下：<br>T -&gt; association -&gt; characteristic of T -&gt; another type -&gt; trait</li><li>Traits可以实现为模板类，而关联(association)则是针对每个具体类型T的特化。在这个例子里我们将trait命名为SigmaTraits, 叫做traits模板(traits template)</li></ul><p>Traits实现：</p><pre><code>template &lt;typename T&gt;class SigmaTraits { };//可以人为的将返回的数值边得相对的大template &lt;&gt;class SigmaTraits&lt;char&gt; {public:    typedef int ReturnType;};template &lt;&gt;class SigmaTraits&lt;short&gt; {public:    typedef int ReturnType;};template &lt;&gt;class SigmaTraits&lt;int&gt; {public:    typedef long ReturnType;};template &lt;&gt;class SigmaTraits&lt;unsigned int&gt; {public:    typedef  unsigned long ReturnType;};template &lt;&gt;class SigmaTraits&lt;float&gt; {public:    typedef double ReturnType;};</code></pre><ul><li>模板类SigmaTraits叫做traits template， 它含有其参数类型T的一个特性(trait), 即ReturnType</li><li><p>现在Sigma函数可以改写成:</p><pre><code>template &lt;typename T&gt;inline typename SigmaTraits&lt;T&gt; :: ReturnType Sigma (const T const* start, const T const* end) {  typedef typename SigmaTraits&lt;T&gt; :: ReturnType ReturnType;  ReturnType s = ReturnType();  while (start != end) {      s += *start ++;  }  return s;}</code></pre></li></ul><h1 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h1><h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><p>迭代器是指针的泛化(generalization of pointers)</p><ul><li>迭代器本身就是一个对象，指向另外一个(可以被迭代的)对象</li><li>用来迭代一组对象，即如果迭代器指向一组对象种的某个元素，则通过increment以后它就可以指向下组对象中的下一个元素</li></ul><h2 id="在STL中迭代器是容器与算法之前的接口"><a href="#在STL中迭代器是容器与算法之前的接口" class="headerlink" title="在STL中迭代器是容器与算法之前的接口"></a>在STL中迭代器是容器与算法之前的接口</h2><ul><li>算法通常以迭代器作为输入参数</li><li>容器只要提供一种方式，可以让迭代器访问容器中的元素即可</li></ul><h2 id="迭代器的基本思想"><a href="#迭代器的基本思想" class="headerlink" title="迭代器的基本思想"></a>迭代器的基本思想</h2><ul><li>在STL中，迭代器最终要的思想就是分离算法和容器，使之不需要相互依赖</li><li><p>迭代器将算法和容器粘合(stick)在一起从而使得一种算法的实现可以运用到多种不同的容器上，如下面的例子,find算法接受一对迭代器，分别指向容器的开始位置和最终位置</p><pre><code>template &lt;typename _InIt, typename _Ty&gt;inline _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val) {    //find first matching _Val    for (; _First != _Last; ++_First) {        if (*_First == _Val)          break;    }    return (_First);}</code></pre><p>find算法对于不同的容器，比如vector, list, deque均适用：</p><pre><code>std :: vector&lt;int&gt; v(...);std :: list&lt;int&gt; l(...);std :: deque&lt;int&gt; d(...);std :: vector&lt;int&gt; :: iterator itv = std :: find(v.begin(), v.end(), elementToFind)std :: list&lt;int&gt; :: iterator itl = std :: find(l.begin(), l.end(), elementToFind)std :: deque&lt;int&gt; :: iterator it3 = std :: find(d.begin(), d.end(), elementToFind)</code></pre><p>每种容器都有其对应的迭代器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类模板与操作符重载</title>
    <link href="/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
    <url>/2020/02/20/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-类模板"><a href="#C-类模板" class="headerlink" title="C++类模板"></a>C++类模板</h1><ul><li>与函数模板类似， 类页可以通过参数泛化，从而可以构建出一族不同类型的类实例</li><li>类模板参数可以是某一类型或常量（仅限int或者enum）</li></ul><p>一个类模板的例子：Stack<T></p><pre><code>const std::size_t DefaultStackSize = 1024;template &lt;typename T, std::size_t n = DefaultStackSize&gt;class Stack {public:    void Push(const T const&amp; element);    int Pop(T&amp; element);    int Top(T&amp; element) const;private:    std::vector&lt;T&gt; m_Members;    std::size_t m_nMaxSize = n;};</code></pre><ul><li>T可以是任意类别</li><li>模板实参也可以是一个int或enum的常量(此处是size_t, 本质是int类型)</li><li>n是编译时定义的常量</li><li>n可以有默认值</li><li>size_t类别的成员变量可以用n初始化</li></ul><h2 id="类模板的声明"><a href="#类模板的声明" class="headerlink" title="- 类模板的声明"></a>- 类模板的声明</h2><ul><li>声明类模板与申明函数模板类似</li><li><p>关键字class和typename都可以用，但是还是更倾向于去使用typename</p><pre><code>template &lt;typename T, std::size_t n&gt; class Stack{...}template &lt;class T, std::size_t n&gt; class Stack{...}</code></pre></li><li><p>在类模板内部，T可以像其他函数类别一样(比如int , char等)定义成员变量和成员函数</p><pre><code>void Push(const T const&amp; element)int Pop(T&amp; element);int Top(T&amp; element) const;std::vector&lt;T&gt; m_Members;</code></pre></li><li>除了Copy constructor 之外，如果在类模板中需要使用到这个类本身，比如定义operator，那么就应该医用其完整的定义(Stack<T,n>)而不是省略类别T。<pre><code>template &lt;typename T, std::size_t n&gt;class Stack{public:    ...    Stack (Stack&lt;T,n&gt; const&amp;); //copy constructor    Stack&lt;T&gt;&amp; operator = (Stack&lt;T,n&gt; const&amp;); // assignment operator    ...}</code></pre></li></ul><h2 id="类模板的实现"><a href="#类模板的实现" class="headerlink" title="- 类模板的实现"></a>- 类模板的实现</h2><ul><li><p>要定义一个类模板的成员函数，则要指明其是一个模板函数</p><p>Push函数：</p><pre><code>template &lt;typename T, std::size_t nMaxSize&gt;void Stack&lt;T, nMaxSize&gt; :: Push(const T const&amp; element) {    if (m_Members.size() &gt;= m_nMaxSize) {        // error handing...        return ;    }    m_Members.push_back(element);}</code></pre><p>Pop函数：</p><pre><code>template &lt;typename T, std :: size_t nMaxSize&gt;int Stack&lt;T, nMaxSize&gt; :: Pop(T&amp; element) {    if (m_Members.empty()) {        return 0;    }    element = m_Members.back(); // we have to first store the back element    m_Members.pop_back(); // because pop_back of a vector removes    return 1; // the last element but doesn&#39;t return it}</code></pre><p>Top函数：</p><pre><code>template &lt;typename T, std :: size_t nMaxSize&gt;int Stack&lt;T, nMaxSize&gt; :: Top(T&amp; element) const {    if (m_Members.empty()) {        return 0;    }    element = m_Members.back();    return 1;}</code></pre></li></ul><h2 id="使用类模板"><a href="#使用类模板" class="headerlink" title="- 使用类模板"></a>- 使用类模板</h2><ul><li>Stack<int> stack：定义了一类型为int的Stack， 大小为默认值</li><li>Stack<int, 100> stack：定义了一个类型为int, 大小为100的Stack</li><li>将100个元素Push到Stack中<pre><code>for (int i = 0; i &lt; 100; ++ i) {    stack.Push(i);}</code></pre></li><li>Pop出Stack顶部元素:<pre><code>int elementstack.Pop(element);</code></pre></li><li>获取Stack顶部元素:<pre><code>stack.Top(element);</code></pre></li><li><p>Stack的stack定义:</p><pre><code>Stack&lt;Stack&lt;int&gt; &gt;intStackStack; // 最右边要加一个空格Stack&lt;Stack&lt;int&gt;&gt; intStackStack; // ERROR: &gt;&gt; is not allowed</code></pre></li></ul><h2 id="类模板特化-specializations"><a href="#类模板特化-specializations" class="headerlink" title="- 类模板特化(specializations)"></a>- 类模板特化(specializations)</h2><ul><li>允许对一个类模板的某些模板参数类型做特化</li><li>特化的作用或好处在于：<ul><li>对于某种特殊的类别，可能可以做些特别的优化或提供不同的实现</li><li>避免在实例化类的时候引起一些可能产生的诡异行为</li></ul></li><li>特化一个类模板的时候也意味着需要特化其所有参数的成员的类型</li><li><p>如果要特化一个类，那么做法为：</p><ul><li>声明一个带template&lt;&gt;的类， 即空参数列表</li><li><p>在类名后紧跟的尖括号中显式指明类别，例如：</p><pre><code> template&lt;&gt; class Stack&lt;std::wstring&gt; { }</code></pre></li></ul></li><li><p>特化后的具体体现可以和柱模板的实现不一样，比如以下的特化增加了一个成员函数，并采用list作元素存取的实现</p><pre><code>template &lt;&gt;class Stack &lt;std :: wstring&gt; {public:    void SetStackStack(const std :: size_t n) {m_nMaxSize = n;}    // 添加一个新的成员函数    std :: size_t CurrentSize() const {return m_Members.size();}    void Push(const std :: wstring const&amp; element);    int Pop(std :: wstring const&amp; element);    int Top(std :: wstring const&amp; element) const;private:    std :: size_t m_nMaxSize;    std :: list &lt;std :: wstring&gt; m_Members;    //采用list作为Stack的内部实现，取代了主模板中用vector实现的方式};</code></pre></li></ul><h2 id="偏特化-Partial-specialization"><a href="#偏特化-Partial-specialization" class="headerlink" title="- 偏特化(Partial specialization)"></a>- 偏特化(Partial specialization)</h2><p>….不做了解，中间会产生二义性…晚点再说。</p><h2 id="默认模板实参"><a href="#默认模板实参" class="headerlink" title="- 默认模板实参"></a>- 默认模板实参</h2><ul><li>类似函数的默认参数，对于类模板而言也可以定义其模板参数的默认值，这些值就叫做<strong>默认模板参数</strong><pre><code>template &lt;typename T, typename TContainer = std :: vector&lt;T&gt;&gt;class Stack {    private : TContainer m_Container;}</code></pre></li><li>Stack<int> intStack: 使用默认的vector作为实参</li><li>Stack<std :: wstring, std :: list <std :: wstring> &gt; wstrStack: 指定使用list作为容器而非默认的vector</li></ul><h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><ul><li>关键字operator定义了一种特殊的函数，该函数的行为是将操作符应用用于某一特定的类型，使之能能够通过该操作符进行操作。如果定义了string类型的operator + ，那么连接两个字符串a和b的行为就可以用a+b进行操作</li><li>操作符重载给出了操作符的不同含义</li><li>编译器通过具体类别来识别某个操作符在该类型上的意义</li><li>本质上operator重载就是函数，即如果定义了string类型的Append函数，那么string类型的a+b和a.Append(b)是等价的</li></ul><h2 id="操作符重载的一般规则"><a href="#操作符重载的一般规则" class="headerlink" title="- 操作符重载的一般规则"></a>- 操作符重载的一般规则</h2><ul><li>不可以用operator定义一种新的操作符，比如<em>* ,因为没有两个</em>的操作符</li><li>对于内置类别(built-in type)， 不能再用operator重载</li><li><p>操作符重载的两种情况：</p><ul><li>静态成员函数</li><li><p>静态全局函数(如果该全集函数需要访问类的private或protected成员，则必须声明为friend成员)</p><pre><code>class ComplexType {  public:     //non-static member    ComplexType operator &lt; (ComplexType&amp; );    //global functions    friend ComplexType operator + (int, ComplexType&amp; );}</code></pre></li><li>一元操作符(Unary operators)如果声明为成员函数，则没有参数。如果声明为全局函数则有一个参数</li><li>二元操作符(Binary operator)如果声明为成员函数，则有一个参数。如果声明为全局函数，则有两个参数</li><li>如果一个操作符技能够用作一元操作，又能用作二元操作(&amp;, *, +, -)，则可以分别被重载</li><li>操作符不能带有默认参数</li><li>除了operator = ，所又其他操作符重载均可以被子类继承</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板观念与函数模板</title>
    <link href="/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <url>/2020/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>简单了解模板观念</p><a id="more"></a><h1 id="C-模板简介"><a href="#C-模板简介" class="headerlink" title="C++模板简介"></a>C++模板简介</h1><ul><li>模板(Templates)是C++的一种特性，允许函数或类通过泛型(generic types)的形式表现或运行</li><li>模板可以使得函数或类在因对不同类别(types)的时候可以正常工作，而无需为每个类型都写一份代码</li></ul><ul><li>一个简单的例子：<ul><li>如果要写一个取两个数中较大的函数Max，在不适用模板的情况下，我们不得不针对不同的类别(eg: int long char…)提供一种类别的重载</li></ul></li></ul><p>int 型</p><pre><code>  int Max(int a, int b) {      return (a &gt; b) ? a : b;  }</code></pre><p>long型</p><pre><code>  long Max(long a, long b) {      return (a &gt; b) ? a : b;  }</code></pre><p>char型</p><pre><code>  char Max(char a, char b) {      return (a &gt; b) ? a : b;  }</code></pre><ul><li><p>一个简单的例子</p><ul><li><p>如果使用模板，则可以省去一堆代码，从而将代码原型缩减到非常简介的表达：</p><pre><code>template &lt;typename T&gt; T Max(T a, T b) {   return (a &gt; b) ? a : b;}</code></pre></li></ul></li><li><p>C++ 主要有两种类型的模板：</p><ul><li>类模板(Class template):使用泛型参数的类(classes with generic parameters)</li><li>函数模板(Function template):使用泛型参数的函数(Functions with generic parameters)</li></ul></li><li><p>模板实例化</p><ul><li>模板的声明(declaration)其实并未给出一个函数或类的完全定义(definition)，只是提供了一个函数或类的语法框架(syntactical skeleton)</li><li><p>实例化时指从模板够检出一个真正的函数或类的过程，比如：</p><pre><code>   template &lt;typename T&gt;   struct Object{....}</code></pre></li><li>可以用来构建诸如Object<int>, Object<char>, Object<int*>, Object<MyClass*>等等不同类别的具体实例</li></ul></li><li><p>实例化有两种类型：</p><ul><li><strong>显式</strong>实例化-在代码中明确指定要正对哪位类别进行实例化</li><li><strong>隐式</strong>实例化-在首次使用时根据具体情况一种合适的型别惊醒实例化</li></ul></li></ul><h2 id="C-函数模板"><a href="#C-函数模板" class="headerlink" title="C++函数模板"></a>C++函数模板</h2><ul><li>什么时函数模板？<ul><li><strong>函数模板</strong>是参数化的一族函数(a family of functions)</li><li>通过函数模板，可以定义一系列函数，这些函数都是基于同一代码，但是可以用作在不同类别的参数上</li></ul></li></ul><pre><code>template &lt;typename T&gt;inline T Max(const T&amp; a, const T&amp; b) {    return (a &gt; b) ? a : b;}</code></pre><ul><li><p>定义函数模板</p><ul><li>定义一个函数模板，反水数中较大一个，该函数有两个参数：(a,b)</li><li>参数类别未定，以模板参数T表示</li><li>模板参数由关键字typename引入</li><li>也可以使用class代替typename来定义类型参数</li><li>从语法上讲使用class和使用typename没有区别</li><li>单从语义上，class可能会导致误区，即只有类才能作为类别参数；而事实上T所以表达的意思不仅仅只针对类，任何类别都可以</li></ul></li><li><p>参数推导</p><ul><li>模板参数是有传递给模板函数的实参所决定的</li><li>不允许自动类型转换：每个T必须严格匹配<pre><code>Max(1, 2) //两次实参的类型都是intMax(1, 2.0) //ERROR：第一参数的类别是int第二参数类别是double</code></pre></li><li>一般有两种处理这种错误的方法：<ol><li>用static_cast<double>或者强制转换参数类型以使两者匹配<pre><code>Max(static_cast&lt;double&gt;(1),2.0)</code></pre></li><li>显示指定T的类别<pre><code>Max&lt;double&gt;(1, 2.0)</code></pre></li></ol></li></ul></li><li><p>函数模板重载</p><ul><li>函数模板也可以像普通函数一样被重载</li><li>非模板函数可以和<strong>同名</strong>的模板函数共存</li><li>编译器同通过函数模板参数推导来决定使用调用哪个函数</li></ul><pre><code>inline int const&amp; Max(const int const&amp; a, const int const&amp; b)template &lt;typename T&gt;inline T const&amp; Max(const T const&amp; a, T const&amp; b)template &lt;typename T&gt;inline T const&amp; Max(const T const&amp; a, T const&amp; b, const T const&amp; c)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>泛型编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2020/02/16/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>堆的种类有很多这里我们讨论的时最大堆和最小堆</p><a id="more"></a><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>严格来说，堆也有不同种类。这是一种叫做二叉堆的数据结构，堆就是下图这样的二叉树。<br><img src="/img/堆的例子.png" srcset="/img/loading.gif" alt=""></p><p>最小堆的性质是儿子的值一定不小于父亲的值。而最大堆的性质则于其相反儿子的值一定更不大于父亲的值。<br>除此之外，树的节点时按从上到下、从左到右的顺序紧凑排列的。</p><p><img src="/img/插入数值.png" srcset="/img/loading.gif" alt=""><br>如上图所示，在向堆中插入数值时，首先在堆的末尾插入该数值，然后不断向上提升直到没有大小颠倒为止。</p><p><img src="/img/取出最小值.png" srcset="/img/loading.gif" alt=""><br>如上图所示，从队中删除最小值时，首先把堆的最后一个节点的数值复制到根节点上，并且删除最后一个结点。然后不断向下<br>交换直到没有大小颠倒为止。在向下交换的过程中，如果有两个儿子，那么选择数值较小的儿子（如果儿子比自己小的话）进行交换。</p><h2 id="堆的操作的复杂度"><a href="#堆的操作的复杂度" class="headerlink" title="堆的操作的复杂度"></a>堆的操作的复杂度</h2><p>堆的两种操作所花的时间都和数的深度成正比。因此，如果一共有$n$个元素，那么每个操作就可以在$O(log_n)$的时间内完成。</p><h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><p>注意:</p><ul><li>左儿子的编号是自己的编号 $×2+1$</li><li>右儿子的编号是自己的编号 $×2+2$</li></ul><pre><code>  const int N = 10000;  int heap[N], sz;  void push(int x) {      //自己节点的编号      int i = sz ++;      while(i &gt; 0) {          // 父亲结点的编号          int p = (i = 1) &gt;&gt; 2;          //如果已经没有大小颠倒则退出          if (heap[p] &lt;= x) break;          //父亲节点的数值放下来，而把自己提上去          heap[i] = heap[p];          i = p;      }      heap[i] = x;  }  int pop() {      //最小值      int ret = heap[0];      //要提到根的数值      int x = heap[--sz];      //从根开始向下交换      int i = 0;      while ((i &lt;&lt; 2) + 1 &lt; sz) {          //比较儿子的值          int a = i * 2 + 1, b = i * 2 + 2;          if (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) a = b;          //如果已经没有大小颠倒则退出          if (heap[a] &gt;= x) break;          //把儿子的数值提上来          heap[i] = heap[a];          i = a;      }      heap[i] = x;      return ret;  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 mcm/icm LaTeX写作</title>
    <link href="/2020/02/15/mcm-icm/"/>
    <url>/2020/02/15/mcm-icm/</url>
    
    <content type="html"><![CDATA[<p>mcm/icm 2020新版美赛$\LaTeX$模板 </p><a id="more"></a><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>&emsp;&emsp;2020年因为武汉疫情的原因，原定于2月14日的mcm/icm比赛采用了两个时间两次给的方式，今天上午我也看了一下题，D题的数据相对比较好搜集，作为一名游戏玩家，我觉得可以从EA的FIFA球员数据库种收取数据。虽然说我的建模能力很垃圾啊。但是搜集数据和LaTeX的写作是我能给我们这个团队做出贡献的方式。所以我就做一些利索能及的事就对了。</p><h2 id="说说LaTeX"><a href="#说说LaTeX" class="headerlink" title="说说LaTeX"></a>说说LaTeX</h2><p>&emsp;&emsp;LaTeX是我开始学习写markdown的时候就了解的一种排版方式，寒假这段时间我也好好学习了一下。<br>一开始觉得美赛要不要用word写但是想到要插入公式，解决排版问题使用LaTeX还是方便的多。因为在比赛之前我也尝试自己<br>按照之前获奖文章自己做一个美赛模板。</p><p><img src="/img/mcm_model_1.png" srcset="/img/loading.gif" alt=""></p><p>但是在比赛之前听过2020年的比赛写作排版有变动，一开始还有点慌。然后今天上官网看了一下。发现官方给了一个模板<br><img src="/img/mcm_code.png" srcset="/img/loading.gif" alt=""><br>我一开始还以为是一个.tex文件谁知道，是这个…</p><p>我运行了一下就是这个效果（我注明一下，我把红色字体改成了黑色）</p><p><img src="/img/mcm_model.png" srcset="/img/loading.gif" alt=""></p><p>效果还不错，嘿嘿。感觉这个还专门给了一个模板，可能是为了要人们知道今年的变化吧。但是我觉得应该是因为大多数中国学生，撰写论文的格式都不标准，所以今年专门给了一个word和LaTeX模板来共大家用。统一一下格式，让看论文的老师也能好看一点。</p><p>自习看了一下模板里面内容，注释也很清楚。生怕学生不会用。一开始我还在想怎么加一个content，谁知人家这个模板很贴心，已经将目录给你写好了。（只不过是注释掉了）</p><p><img src="/img/content.png" srcset="/img/loading.gif" alt=""></p><p>2020和2019版的模板我也分享给大家，有需自戳。</p><ul style:"color=#336699"><li><a href="/temp/mcm-icm2020模板.zip" download="2020mcm-icm模板">2020</a></li><li><a href="/temp/mcm-icm2019模板.zip" download="2019mcm-icm模板">2019</a></li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>mathematical-modeling</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>mathematical</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(完全背包)</title>
    <link href="/2020/02/14/%E8%83%8C%E5%8C%85_1/"/>
    <url>/2020/02/14/%E8%83%8C%E5%8C%85_1/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题:完全背包问题</p><a id="more"></a><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href = "http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲(01背包)</title>
    <link href="/2020/02/10/%E8%83%8C%E5%8C%85/"/>
    <url>/2020/02/10/%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>著名的背包问题：01背包问题</p><a id="more"></a><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p><p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p><p><strong>输出格式</strong><br>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0 &lt; N$, $V \leq 1000$</p><p>$0 &lt; v_i$, $w_i \leq 1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例</strong></p><pre><code>8</code></pre><p>S</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>&emsp;&emsp;这是最基础的背包问题，特点是：<font color = #f278>每种物品仅有一件，可以选择放或不放。</font></p><h5 id="用子问题定义状态："><a href="#用子问题定义状态：" class="headerlink" title="用子问题定义状态："></a>用子问题定义状态：</h5><p>即$f[i][v]$表示前$i$件物品恰放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p><script type="math/tex; mode=display">f[i][v] = max \begin{cases}    f[i-1][j] \\    f[i-1][j-c[i]] + w[i]\end{cases}</script><p>&emsp;&emsp;这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为$v$的背包中”；如果放第$i$件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f=[i-1][v-c[i]]$再加上通过放入第$i$件物品获得的价值$w[i]$。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><ul style = "color:#336699"><li><a href = "http://www.wulnut.top/2020/02/10/%E8%83%8C%E5%8C%85/">01背包问题</a></li><li><a href="http://www.wulnut.top/2020/02/14/%E8%83%8C%E5%8C%85_1/" target="_blank" rel="noopener">完全背包问题</a></li><li>多重背包问题</li><li>混合背包问题</li><li>维费用的背包问题</li><li>分组背包问题</li><li>背包问题求方案数</li><li>求背包问题的方案</li><li>有依赖的背包问题</li></ul><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL队列</title>
    <link href="/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/02/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>STL队列简述</p><a id="more"></a><h1 id="STL中队列-queue-的使用方法"><a href="#STL中队列-queue-的使用方法" class="headerlink" title="STL中队列(queue)的使用方法"></a><font color="#f278">STL中队列(queue)的使用方法</font></h1><h3 id="STL中队列的使用方法-queue"><a href="#STL中队列的使用方法-queue" class="headerlink" title="STL中队列的使用方法(queue)"></a><font style="text-align: 'center'">STL中队列的使用方法(queue)</font></h3><p>基本操作：</p><ul><li>push(x) 将x压入队列的末端</li><li>pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值</li><li>front() 返回第一个元素(队顶元素)</li><li>back() 返回最后被压入的元素(队尾元素)</li><li>empty() 当队列为空时，返回true</li><li>size() 返回队列的长度</li></ul><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p> 声明方法：<br>1、普通声明</p><pre><code>queue&lt;int&gt;q;</code></pre><p>2、结构体</p><pre><code>struct node{    int x, y;};queue&lt;node&gt;q;</code></pre><h3 id="STL-中优先队列的使用方法-priority-queue"><a href="#STL-中优先队列的使用方法-priority-queue" class="headerlink" title="STL 中优先队列的使用方法(priority_queue)"></a>STL 中<font color="#f278">优先队列</font>的使用方法(priority_queue)</h3><p>&emsp;&emsp;优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大互小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p><p>基本操作：</p><ul><li><p>empty() 如果队列为空返回真</p></li><li><p>pop() 删除对顶元素</p></li><li><p>push() 加入一个元素</p></li><li><p>size() 返回优先队列中拥有的元素个数</p></li><li><p>top() 返回优先队列对顶元素</p></li></ul><p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p><p>使用方法：</p><p>头文件：</p><pre><code>#include &lt;queue&gt;</code></pre><p>声明方式：</p><p>1、普通方法：<br>    priority_queue<int>q;   //通过操作，按照元素从大到小的顺序出队<br>    priority_queue<int,vector<int>, greater<int> &gt;q;  //通过操作，按照元素从小到大的顺序出队</p><p>2、自定义优先级：</p><pre><code>struct cmp {     　　operator bool ()(int x, int y)     　　{        　　　　 return　x &gt; y; // x小的优先级高               //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高　　}};priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;    //定义方法//其中，第二个参数为容器类型。第三个参数为比较函数。</code></pre><p>3、结构体声明方式：</p><pre><code>struct node {     　　int x, y;     　　friend bool operator &lt; (node a, node b)     　　{         　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高     　　}};priority_queue&lt;node&gt;q;   //定义方法//在该结构中，y为值, x为优先级。//通过自定义operator&lt;操作符来比较元素中的优先级。//在重载“&lt;”时，最好不要重载“&gt;”，可能会发生编译错误</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拯救公主</title>
    <link href="/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/"/>
    <url>/2020/02/02/%E6%8B%AF%E6%95%91%E5%85%AC%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<p>BFS训练题</p><a id="more"></a><h2 id="拯救公主"><a href="#拯救公主" class="headerlink" title="拯救公主"></a>拯救公主</h2><p>公主被恶人抓走，被关押在牢房的某个地方。牢房用 $ N \times M (N, M \le 200)N×M(N,M\le200) $ 的矩阵来表示。矩阵中的每项可以代表道路（@）、墙壁（#）、和守卫（x）。</p><p>英勇的骑士（r）决定孤身一人去拯救公主（a）。我们假设拯救成功的表示是 “骑士到达了公主所在的位置”。由于在通往公主所在位置的道路中可能遇到守卫，骑士一旦遇到守卫，必须杀死守卫才能继续前进。</p><p>现假设骑士可以向上、下、左、右四个方向移动，每移动一个位置需要 11 个单位时间，杀死一个守卫需要花费额外的 11 个单位时间。同时假设骑士足够强壮，有能力杀死所有的守卫。</p><p>给定牢房矩阵，公主、骑士和守卫在矩阵中的位置，请你计算拯救行动成功需要花费最短时间。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>1、两个整数代表 $N$ 和 $M, (N, M \le 200)M,(N,M\le200)$.<br>2、随后 $N$ 行，每行有 $M$ 个字符。”@” 代表道路，”a” 代表公主，”r” 代表骑士，”x” 代表守卫, “#” 代表墙壁。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果拯救行动成功，输出一个整数，表示行动的最短时间。<br>如果不可能成功，输出 “Impossible”。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h3><pre><code>7 8#@#####@#@a#@@r@#@@#x@@@@@#@@#@##@@@##@@@#@@@@@@@@@@@@@@</code></pre><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h3><pre><code>13</code></pre><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h3><pre><code>13 40@x@@##x@#x@x#xxxx##@#x@x@@#x#@#x#@@x@#@xxx###x@x#@@##xx@@@#@x@@#x@xxx@@#x@#x@@x@#@x#@x#x#@@##@@x#@xx#xxx@@x##@@@#@x@@x@x@##x@@@x#xx#@@#xxxx#@@x@x@#@x@@@x@#@#x@#@#xxxxx##@@x##x@xxx@@#x@x####@@@x#x##@#@#xxx#@#x##xxxx@@#xx@@@x@xxx#@#xxx@x######x@xxxx#@x@@@@##@x#xx#xxx@#xx#@#####x#@xxx##@#@x##x##x#@x#@a#xx@##@#@##xx@#@@x@xx#x#@x@#x#@##@xrx@x#xxxx@##x##xx#@#x@xx@#x@@#@###x##x@x#@@#@@x@x@@xx@@@@##@@x@@xx#xx@x###@xxx#@#x#@@###@#@##@x#@x@#@@#@@#@#x@x#x#x###@x@@xxx####x@x##@x####xx#@x#x#@x#x######@@#x@#xxxx#xx@@@#xx#x#####@</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>7</code></pre><h3 id="ans"><a href="#ans" class="headerlink" title="ans"></a>ans</h3><pre><code>//ac#include &lt;bits/stdc++.h&gt;using namespace std;char maze[205][205];bool vis[205][205];int dir[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};int n, m;struct node {    int x;    int y;    int d;    node(int xx, int yy, int dd) : x(xx), y(yy), d(dd) {}    friend bool operator &lt; (node a, node b) {        return a.d &gt; b.d;    }};int bfs(int x, int y) {    priority_queue&lt;node&gt; q;    vis[x][y] = true;    q.push(node(x, y, 0));    while(!q.empty()) {        node now = q.top();        q.pop();        for (int i = 0; i &lt; 4; ++i) {            int tx = now.x + dir[i][0];            int ty = now.y + dir[i][1];            if (0 &gt; tx || tx &gt;= n || 0 &gt; ty || ty &gt;= m || maze[tx][ty] == &#39;#&#39; || vis[tx][ty])            continue;            if (maze[tx][ty] == &#39;a&#39;) {                return now.d + 1;            }            else if (maze[tx][ty] == &#39;x&#39;) {                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 2));            }            else{                vis[tx][ty] = true;                q.push(node(tx, ty, now.d + 1));            }        }    }    return -1;}int main(){    freopen(&quot;note.txt&quot;, &quot;r&quot;, stdin);    freopen(&quot;ans.txt&quot;, &quot;w&quot;, stdout);    int i, j;    int ans = -1;    cin &gt;&gt; n &gt;&gt; m;    for (i = 0; i &lt; n; ++i) {        cin &gt;&gt; maze[i];    }    for (i = 0; i &lt; n; ++i) {        for (j = 0; j &lt; m; ++j) {            if (maze[i][j] == &#39;r&#39;){                break;            }        }        if (maze[i][j] == &#39;r&#39;) break;    }    ans = bfs(i, j);    if (ans == -1) {        cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl;    }    else{        cout &lt;&lt; ans &lt;&lt; endl;    }    return 0;}</code></pre><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>&emsp;&emsp;这个题目的棋盘范围超过了100也就是说使用dfs算法是非常危险的方法，因为dfs的时间复杂度为 $O(2^n)$ 而bfs的时间复杂度为$O(M*N)$所以使用dfs是会为超时的。</p><p>&emsp;&emsp;所以弃用dfs是必须的，一般再求最少问题时一般都是采用dfs算法使用。但是我们注意这个棋盘的范围超过了100。对于bfs来说<br>空间复杂度问题就显现的比较明显。如果采用一般的队列方式来存储帮助bfs的实现，时肯定不行的。此时就要记住。一般这种情况下求极值问题要求优化，我们就采用用<strong>优先队列</strong>的方法。来进行优化。其实质上对空间复杂度的优化就是对时间复杂度的优化。要不断使用最优秀的数据结构来解决时间于内存上的算法优化问题。</p><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踏青</title>
    <link href="/2020/01/26/%E8%B8%8F%E9%9D%92/"/>
    <url>/2020/01/26/%E8%B8%8F%E9%9D%92/</url>
    
    <content type="html"><![CDATA[<p>DFS训练题</p><a id="more"></a><hr><p>垃圾桶和他的朋友周末相约去召唤师峡谷踏青。他们发现召唤师峡谷的地图是由一块块格子组成的，有的格子上是草丛，有的是空地。草丛通过上下左右四个方向扩展到其他草丛形成一片草地，任何一片草地中的格子都是草丛，并且所有格子之间都能通过上下左右连通。如果用’#’代表草丛，’.’表示空地，下图的峡谷有<strong>2</strong>片草地</p><pre><code>##....##</code></pre><p>处在同一个草地的<strong>2</strong>个人可以相互看到，空地看不到草地里面的人。他们发现有一个朋友不见了，现在需要分头去找，每个人负责一片草地，垃圾桶想知道他们至少需要多少人。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入 $n,m$ $(1 \le n, m \le 100)$ 表示峡谷大小。</p><p>接下来输入 $m$ 行字符串表示峡谷的地形。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输出至少需要多少个人。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code>5 6.#......#.....#..#...##..#....</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code>5</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
      <category>DFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(7)</title>
    <link href="/2020/01/21/python_ex40/"/>
    <url>/2020/01/21/python_ex40/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是组织好的、可重复使用得、用来实现单一或相关联功能的代码。在程序中，函数的使用能提高应用的模块性、代码的重用旅和可读性。</p><font color="#f4f4f4" weight="bold" size="32">内容施工中...</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(6)</title>
    <link href="/2020/01/20/python_ex39/"/>
    <url>/2020/01/20/python_ex39/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h3 id="3-修改列表元素"><a href="#3-修改列表元素" class="headerlink" title="3.修改列表元素"></a>3.修改列表元素</h3><p>列表创建之后，可以对列表中单个元素或指定范围元素(切片)进行修改，方法是：</p><ol><li>list[index] = newValue: 对指定索引index的列表元素进行修改</li><li><p>list[::] = newList: 对指定方位的列表元素进行修改</p><pre><code> list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;] list[0] = &quot;eee&quot; print(&quot;list:&quot;,list) list[1:3] = [&quot;ggg&quot;,&quot;kkk&quot;] print(&quot;list:&quot;,list)</code></pre></li></ol><p>4.删除列表元素<br>列表创建后，可以根据需要使用列表函数，del语句或切片和删除指定袁术或所有元素。</p><ol><li>del list[index]: 删除索引为index元素</li><li>list.pop(): 删除列表末尾的元素。</li><li>list.pop(index): 删除索引的元素。</li><li>list.remove(item): 删除列表元素item。</li><li>list.clear(): 删除列表中所有元素。</li><li>list[::] = []: 对指定范围的列表元素进行</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    #del list[3]    #list.pop()    #list.pop(0)    #list.remove(&quot;aaa&quot;)    #list.clear()    #list[2:3] = []    print(&quot;list:&quot;,list)</code></pre><p>list.remove(item)<br><img src="/img/list.remove.png" srcset="/img/loading.gif" alt=" "></p><p>list.clear()<br><img src="/img/list.clear.png" srcset="/img/loading.gif" alt=" "></p><p>list[::] = []<br><img src="/img/list[].png" srcset="/img/loading.gif" alt=" "></p><h2 id="列表复制和删除"><a href="#列表复制和删除" class="headerlink" title="列表复制和删除"></a>列表复制和删除</h2><h3 id="1-列表复制"><a href="#1-列表复制" class="headerlink" title="1.列表复制"></a>1.列表复制</h3><p>列表复制有两种方法。</p><ol><li>list_copy = list.copy(): 列表浅复制。当列表list改变时，list_copy中的元素不会随之变化。</li><li>list_copy = list: 列表复制。当列表list改变时，list_copy中的元素也会随之改变。</li></ol><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    list_copy = list.copy()    print(&quot;list:&quot;,list)    print(&quot;list_copy:&quot;,list_copy)</code></pre><p><img src="/img/list.copy.png" srcset="/img/loading.gif" alt=" "></p><h3 id="2-列表删除"><a href="#2-列表删除" class="headerlink" title="2.列表删除"></a>2.列表删除</h3><p>当列表不再使用后，可以使用del语句删除列表，其一般格式：</p><pre><code>del 列表名</code></pre><p>del 可以索引删除也可以全部删除</p><pre><code>    list = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]    print(&quot;list:&quot;,list)    del list    print(&quot;list:&quot;,list)</code></pre><p><img src="/img/del.png" srcset="/img/loading.gif" alt=" "></p><h2 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h2><ol><li>+: 将多个列表组合成一个新的列表，新列表中的元素是多个元素的有序组合。</li><li>*: 将整数n和列表相乘可以得到一个将原列表重复n次的新列表。</li><li>in: 用于判断给定对象是否再列表中，如果再则返回True：否则返回False</li><li>not in: 用于判断给定对象是否不在列表中，如果不在则返回True；否则返回False</li><li>关系运算符：两个列表可以使用&lt;,&gt;等关系运算进行比较操作，其规则是从两个列表的第1个元素开始比较，如果比较有结果就结束；否则继续继续比较两个列表后面对应位置的元素。</li></ol><h2 id="列表统计"><a href="#列表统计" class="headerlink" title="列表统计"></a>列表统计</h2><p>列表统计函数：</p><ol><li>len(list): 返回列表list中的元素个数</li><li>max(list): 返回列表list中元素的最大值</li><li>min(list): 返回列表list中元素的最小值</li><li>sum(list): 返回列表list中所有元素的和</li><li>list.count(key): 返回关键字key在列表中出现的次数</li></ol><h2 id="列表元素查找和排序"><a href="#列表元素查找和排序" class="headerlink" title="列表元素查找和排序"></a>列表元素查找和排序</h2><h3 id="1-列表元素查找"><a href="#1-列表元素查找" class="headerlink" title="1.列表元素查找"></a>1.列表元素查找</h3><p>list.index()函数用于查找并返回关键字在列表中第1次出现的位置，其一般格式为：</p><pre><code>list.index(key)</code></pre><p>其中，key为要在列表中查找的元素。</p><h3 id="2-列表元素的排序"><a href="#2-列表元素的排序" class="headerlink" title="2.列表元素的排序"></a>2.列表元素的排序</h3><p>列表创建后，可以使用一下函数更具关键字对列表中的元素进行排序、倒序或临时排序。</p><ol><li>list.sort(): 对列表中的元素按照一定的规则进行排序</li><li>list.reverse(): 对列表list中的元素按照一定的规则反向排序</li><li>sorted(list): 对列表list中的元素进行临时排序，返回副本。但是原列表中的元素次序不变</li></ol><font color="#f4f4f4" weight="bold" size="32">To be continue</font>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(5)</title>
    <link href="/2020/01/19/python_ex38/"/>
    <url>/2020/01/19/python_ex38/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表(list)是写在方括号[]之间、用于逗号隔开的元素集合。<br>列表中的元素可以是零个或多个。只有零个元素的列表称为空列表[]。<br>列表中的元素可以相同。例如：</p><pre><code>[&quot;c/c++&quot;,&quot;Python&quot;,&quot;Java&quot;]</code></pre><p>该列表中的个元素均不同。</p><pre><code>[1,1,2,3,4]</code></pre><p>该列表中有重复元素。</p><p>列表中的元素可以类型相同，如[2,4,6,8];也可以是类型不同，如列表[“Rose”,”Female”,18];还可以是复杂的数据类型，如列表[(1,0),(0,1)]</p><p>同字符串类似，列表支持元素的双向索引，正向第1个元素的索引是0，第2个元素的索引是1，以此类推。反向最后1个元素的索引是-1，倒数第2个元素的索引是-2，以此类推。</p><h2 id="列表创建"><a href="#列表创建" class="headerlink" title="列表创建"></a>列表创建</h2><p>通常使用[]运算符或list()函数创建列表。</p><h3 id="1-使用-运算符"><a href="#1-使用-运算符" class="headerlink" title="1.使用[]运算符"></a>1.使用[]运算符</h3><p>使用[]运算符创建列表的一般格式为：</p><pre><code>列表名 = [元素1, 元素2, 元素3, ....]</code></pre><p>其中列表中的元素可以是相同类型或不同类型，简单数据或组合数据。</p><pre><code>list1 = []list2 = [1, 2, 3.2]list3 = [&quot;石油&quot;,&quot;汽车&quot;,&quot;建筑&quot;,&quot;IT&quot;]list4 = [&#39;Alice&#39;,18,&#39;Beth&#39;,19]</code></pre><h3 id="2-使用list-函数创建列表"><a href="#2-使用list-函数创建列表" class="headerlink" title="2.使用list()函数创建列表"></a>2.使用list()函数创建列表</h3><p>使用内置函数list()创建列表的一般格式为:</p><pre><code>列表名 = list(sequence)</code></pre><p>其中，sequence可以是字符串、元组、结合或range()函数返回结果等迭代对象</p><h2 id="列表访问"><a href="#列表访问" class="headerlink" title="列表访问"></a>列表访问</h2><h3 id="1-访问列表"><a href="#1-访问列表" class="headerlink" title="1.访问列表"></a>1.访问列表</h3><p>(1)访问列表及元素<br>可以使用列表名访问整个列表，也可以通过list[index]访问索引为index的元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]print(&quot;carlist[2]:&quot;,carlist[2])print(&quot;carlist[-1]:&quot;,carlist[-1])</code></pre><p>(2)列表切片<br>Python支持使用切片访问列表指定范围的元素,语法格式为:</p><pre><code>arr[index_start:index_end:step]</code></pre><p>注意结束是指在结束的数字前的一个数字结束。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;carlist[2:5]:&quot;,carlist[2:5])print(&quot;carlist[2:5:2]:&quot;,carlist[2:5:2])</code></pre><p>(3)遍历列表<br>可以使用for语句遍历列表，即逐个访问列表中的每个元素。</p><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]print(&quot;print:&quot;,end = &#39; &#39;)for car in carlist:    print(car,end = &#39; &#39;)</code></pre><h3 id="2-添加列表元素"><a href="#2-添加列表元素" class="headerlink" title="2.添加列表元素"></a>2.添加列表元素</h3><p>列表创建后，可以使用列表函数或切片为列表添加新的元素。</p><ol><li>list.append(newItem): 在列表末尾添加新的元素newItem。</li><li>list.insert(index,newItem):在列表末尾添加新元素newItem。</li><li>list.extend(seq):在列表末尾添加迭代对象seq中的所有元素作为列表新元素。</li><li>list.[len(list):] = newList:使用切片在列表list末尾添加新元素(newList中的元素)</li></ol><pre><code>carlist = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;,&quot;eee&quot;,&quot;fff&quot;,&quot;bbb&quot;]#carlist.append(&quot;ggg&quot;)#carlist.insert(2,&quot;ggg&quot;)#carlist.extend([&quot;yyy&quot;,&quot;ggg&quot;])carlist[6:] = [&quot;iii&quot;,&quot;ggg&quot;] print(carlist)</code></pre><font color="#f4f4f4" weight="bold" size="32">To be continue</font><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly" target="_blank" rel="noopener">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(4)</title>
    <link href="/2020/01/18/python_ex37/"/>
    <url>/2020/01/18/python_ex37/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h2><p>条件运算相当于一个二分支结构语句的功能，包含三个表达式，其一般格式为：</p><pre><code>表达式1 if 表达式 else 表达式2</code></pre><p>条件运算的执行过程是：如果if后面的表达式值为True，则以表达式1的值为条件运算的结构；<br>否则，以表达式2的值为条件运算的结果。<br>可以将整个条件运算作为一个表达式，出现在其他表达式中。</p><pre><code>score = int(input(&quot;Please enter:&quot;))flag = &quot;ok&quot; if score &gt;= 60 else &quot;no&quot;print(&quot;score: &quot;,flag)</code></pre><p><img src="/img/条件运算.png" srcset="/img/loading.gif" alt=" "></p><p>但是我们要注意表达式1与if之间不能加换行。</p><h2 id="选择结构嵌套"><a href="#选择结构嵌套" class="headerlink" title="选择结构嵌套"></a>选择结构嵌套</h2><p>当在一个选择结构中需要进一步的条件选择时，可以在if语句中再嵌套使用if语句，形成选择结构嵌套以实现相应功能。</p><pre><code>a = 3; b = 2; c = 4if a &gt; b:    if a &gt; c:        print(&quot;最大的数是：&quot;, a)    else:        print(&quot;最大的数是：&quot;, c)else:    if b &gt; c:        print(&quot;最大的数是: &quot;, b)    else:        print(&quot;最大的数是: &quot;, c)</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环结构依据某一条件反复执行某段程序，即语句块。该语句块被执行的次数称为循环次数。</p><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句用于循环执行一段程序，即再满足某种条件的情况下循环执行某段程序，以处理需要重复处理的<br>相同任务。while语句的一般格式为：</p><pre><code>while 表达式：   语句块[else：   else 子句语句块]</code></pre><p>while语句执行过程：如果表达式的值为True，则执行while后面的语句块；否则，执行else子语句语句块，结束循环。其中else子句为可选。</p><p>while语句</p><pre><code>n = 100sum = 0i = 1while i &lt;= n:    sum = sum + i    i += 1print(&quot;1到%d之和为: %d.&quot; % (n,sum))</code></pre><p>while-else语句</p><pre><code>mu1 = 1; i = 1; sum = 0while i &lt;= 10:    mu1 = mu1 * i    sum = sum + mu1    i = i + 1else:    print(&quot;循环结束!&quot;)print(&quot;sum =&quot;, sum)</code></pre><h3 id="while语句块中的input-函数"><a href="#while语句块中的input-函数" class="headerlink" title="while语句块中的input()函数"></a>while语句块中的input()函数</h3><p>while语句常常和input()函数结合使用，给变量循环输入数据，进行相应的处理。</p><pre><code>total = 0; ave = 0; count = 0score = int(input(&quot;请输入学生英语成绩: &quot;))print(&quot;输入&#39;-1&#39;结束输入\n&quot;)while score != -1:    total = total + score    count = count + 1    score = int(input(&quot;请输入学生英语成绩: &quot;))ave = total / countprint(&quot;录入学生英语成绩%d份,学生英语总成绩%d，平均成绩%4.2f.&quot; % (count, total, ave))</code></pre><p><img src="/img/while-input.png" srcset="/img/loading.gif" alt=" "><br>注意:%4.2f是值精度为2宽度为4。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句更合适循环访问系列或迭代对象(如字符串、列表、元组、字典等))中的元素，其一般格式：</p><pre><code>for 变量 in 序列或迭代对象：    语句块[else:    else 子句语句块]</code></pre><p>for语句执行过程是:当序列或迭代对象中的元素没有遍历完毕时，执行for语句中的语句块：<br>否则，执行else子句中的语句块，结束循环，其中，else子句时可选的。</p><pre><code>for letter in &#39;python&#39;:    print(letter, end=&#39; &#39;)print() #起到换行作用chemists = [&#39;道尔顿&#39;,&#39;门捷列夫&#39;,&#39;拉瓦锡&#39;,&#39;诺贝尔&#39;]print(&quot;化学家:&quot;,end=&#39; &#39;)for hxj in chemists:    print(hxj, end=&#39; &#39;)</code></pre><p><img src="/img/for.png" srcset="/img/loading.gif" alt=" "></p><p>一般情况下else子句是可选选项，可以做为在循环遍历结束之后给出提示信息。</p><h3 id="for语句中的range-函数"><a href="#for语句中的range-函数" class="headerlink" title="for语句中的range()函数"></a>for语句中的range()函数</h3><p>range()函数经常用在for循环中，用于控制循环次数。</p><pre><code>universities = [&#39;哈弗大学&#39;,&#39;斯坦福大学&#39;,&#39;剑桥大学&#39;,&#39;麻省理工学院&#39;,&#39;加州大学&#39;,&#39;普林斯顿大学&#39;,&#39;牛津大学&#39;,&#39;哥伦比亚大学&#39;,&#39;加州理工学院&#39;,&#39;芝加哥大学&#39;]print(&quot;2017《Times》世界大学排名前三的大学是：&quot;)for i in range(3):    print(str(i+1) + &quot;.&quot;, universities[i])</code></pre><h3 id="break-continue和pass语句"><a href="#break-continue和pass语句" class="headerlink" title="break,continue和pass语句"></a>break,continue和pass语句</h3><p>break语句用于退出循环，continue语句用于跳过该次循环,pass时空语句(不做任何处理)</p><h2 id="循环结构的嵌套"><a href="#循环结构的嵌套" class="headerlink" title="循环结构的嵌套"></a>循环结构的嵌套</h2><p>在一个循环结构的循环体内出现另一个循环结构，称为循环结构的嵌套。</p><pre><code>for i in range(1,6):    for j in range(i):        print(&quot;*&quot;, end=&#39; &#39;)    print() #该print是属于  第一层循环</code></pre><p><img src="/img/for-for.png" srcset="/img/loading.gif" alt=" "></p><p><a href="https://github.com/Wulnut/Learning-only/tree/master/pyhononly" target="_blank" rel="noopener">源码戳我</a></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(3)</title>
    <link href="/2020/01/17/python_ex36/"/>
    <url>/2020/01/17/python_ex36/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><p>单分支结构可用if单分支语句实现，其一般格式为：</p><pre><code>if表达式:    语句块</code></pre><p>语句的执行过程是：如果表达式的值为True，则执行语句中的语句块；否则，直接执行if语句的后续语句。</p><p>注意：</p><ol><li>if语句中的语句块可以包含单个语句，也可以包含多个语句。</li><li>如果语句块中只有一跳语句，也可以将整个if语句写在同一行中</li></ol><pre><code>    n = int(input(&quot;请输入一个整数: &quot;))    flag = str(n) + &quot; 是偶数!&quot;    if n % 2 != 0:        flag = str(n) + &quot; 是偶数!&quot;    print(flag)</code></pre><p><img src="/img/if.png" srcset="/img/loading.gif" alt=" "></p><ul><li><p>str() 函数将对象转化为适于人阅读的形式，就是把对象转换成字符串</p><pre><code>  class str(object=&#39;&#39;)</code></pre></li><li><p>object — 对象。</p></li></ul><h2 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h2><p>二分支结构可用if二分支语句实现，其一般格式为：</p><pre><code>if 表达式：    语句块1else：    语句块2</code></pre><p>语句执行过程是：如果表达式的值为True时，则执行语句块1；否则，执行语句块2</p><pre><code>a = 5b = 6print(&quot;a = %d, b = %d&quot; % (a,b))if a &gt; b:    max = aelse:     max = bprint(max)</code></pre><p><img src="/img/if-else.png" srcset="/img/loading.gif" alt=" "></p><h2 id="多分枝结构"><a href="#多分枝结构" class="headerlink" title="多分枝结构"></a>多分枝结构</h2><p>二分支结构只能根据条件的True和False决定处理两个分支中的一个。当实际处理的问题有多种条件时，就要用到多分支结构。<br>多分支结构可用if多分支语句实现，其一般格式为：</p><pre><code>if 表达式1：    语句块1elif 表达式2：    语句块2    ...[else:    语句块n+1]</code></pre><p>if多分支语句根据不同的表达式值确定执行哪个语句块，测试条件的顺序为表达式1，表达式2，…。一旦<br>遇到表达式的值为True，则执行该条件下的语句块，然后执行if语句的后续语句。</p><pre><code>score = int(input(&quot;请输入成绩:&quot;))if score &gt;= 90:    print(&quot;成绩等级:优秀！&quot;)elif score &gt;= 80:    print(&quot;成绩等级：良好！&quot;)elif score &gt;= 60:    print(&quot;成绩等级：不合格！&quot;)</code></pre><p><img src="/img/elif.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(2)</title>
    <link href="/2020/01/16/python_ex35/"/>
    <url>/2020/01/16/python_ex35/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><p>filter()函数用于过滤掉不符合条件的元素，返回一个迭代器对象，一般格式为：</p><pre><code>filter(function,iterable)</code></pre><p>其中，function为半段函数，iterable为可迭代对象。</p><pre><code>def IsEvenFunc(n):    return n % 2 == 0a = list(filter(IsEvenFunc,[1,2,3,4,5]))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/filter.png" srcset="/img/loading.gif" alt=" "></p><h2 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a>zip()函数</h2><p>zip()函数接收任意多个可迭代对象作为参数，将对象种对应的元素打包成一个<strong>元组</strong>，然后返回一个可迭代的zip对象<br>如果可迭代对象的长度不相同，取最短的可迭代对象的长度</p><pre><code>zip([iterable,...])</code></pre><p>其中,iterable为一个或多个迭代器。</p><pre><code>a = list(zip([&quot;泰山&quot;,&quot;黄山&quot;,&quot;庐山&quot;,&quot;华山&quot;],[&quot;山东&quot;,&quot;安徽&quot;,&quot;江西&quot;,&quot;陕西&quot;])) #打包print(&quot;a: &quot;,a)z = zip([1,2,3],[4,5,6]) #打包a = list(zip(*z)) #解包print(&quot;a: &quot;,a)</code></pre><p><img src="/img/zip.png" srcset="/img/loading.gif" alt=" "></p><p>zip(*z)是解包，但是要注意我们不能先迭代z然后再去解包</p><h2 id="枚举函数enumerate"><a href="#枚举函数enumerate" class="headerlink" title="枚举函数enumerate()"></a>枚举函数enumerate()</h2><p>枚举函数enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标。</p><pre><code>enumerate(sequence,[strat = 0])</code></pre><p>其中，sequence: 一个序列，迭代器或其他支持的迭代对象。<br>start: 下表其实位置，可选。</p><pre><code>weeks = [&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;,&#39;saturday&#39;]a = list(enumerate(weeks))print(&quot;a: &quot;,a)</code></pre><p><img src="/img/enumerate.png" srcset="/img/loading.gif" alt=" "></p><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p>map()函数把函数依此映射到序列或迭代器对象的每个元素上，并返回一个可迭代的map对象作为结果.</p><pre><code>map(function,iterable,....)</code></pre><p>其中，function为被调用的函数,iterable为一个或多个序列</p><pre><code>def cube(x):    return x ** 3a = list(map(cube,[1,2,3,4,5,6])) #计算列表中的各个元素的立方和print(&quot;a: &quot;,a)def add(x, y):    return x + ya = list(map(add,[1,2,3,4,5],[1,2,3,4,5])) #两个列表中相同位置的元素相加print(&quot;a: &quot;,a)a,b = map(int, input(&quot;请输入两个数(用空格隔开):&quot;).split())print(&quot;a = %d, b = %d.&quot;%(a,b))</code></pre><p><img src="/img/map.png" srcset="/img/loading.gif" alt=" "></p><ul><li>我们注意到使用了一个函数 input().split()其中split()可以接收键盘输入的两个数字。</li></ul><p>split()函数的原型为：</p><pre><code>    str1.split(str2=&quot; &quot;,num=string.count(str))</code></pre><p>str1 : 表示为字符串<br>str2 : 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。<br>num : 分割次数。默认为 -1, 即分隔所有。</p><h2 id="逻辑运算符和逻辑运算表达式"><a href="#逻辑运算符和逻辑运算表达式" class="headerlink" title="逻辑运算符和逻辑运算表达式"></a>逻辑运算符和逻辑运算表达式</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>名称</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>逻辑“与”</td><td>x and y</td><td>x为True或非0，返回y；否则返回x</td></tr><tr><td>or</td><td>逻辑“或”</td><td>x or y</td><td>x为True或非0，返回x；否则返回y</td></tr><tr><td>not</td><td>逻辑“非”</td><td>not x</td><td>x为True或非0，返回False；否则返回True</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>in</td><td>判断对象是否在序列中</td><td>obj sequence</td><td>obj 在 sequence中返回True，否则返回False</td></tr><tr><td>not in</td><td>判断对象是否不在序列中</td><td>obj not int sequence</td><td>obj 不在sequence中返回True，否则返回False</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python学习笔记(1)</title>
    <link href="/2020/01/15/python_ex34/"/>
    <url>/2020/01/15/python_ex34/</url>
    
    <content type="html"><![CDATA[<p>python入门学习</p><a id="more"></a><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>编程语言都先从最基本的基本语法开始</p><h2 id="type-and-isinstance-函数"><a href="#type-and-isinstance-函数" class="headerlink" title="type() and isinstance() 函数"></a>type() and isinstance() 函数</h2><p>type(object): 接收一个对象object来作为参数， 返回这个参数的数据类型<br>isinstance(object, class): 判断接收的对象object是否是给定的类型class的对象：如果是就返回True,如果不是返回False.</p><p>type(object):</p><pre><code>m = 120print(&quot;m Type: &quot;, type(m))m = &quot;大数据&quot;print(&quot;m Type: &quot;, type(m))</code></pre><p><img src="/img/type.png" srcset="/img/loading.gif" alt=" "></p><p>isinstance(object, class):</p><pre><code>a = 20print(&quot;a是整型么？&quot;, isinstance(a, int))</code></pre><p><img src="/img/isinstance.png" srcset="/img/loading.gif" alt=" "></p><p>在判断一个对象类型时，type() 和 isinstance()有一点区别：</p><ol><li>type()不会认为子类对象时一种父类类型，不考虑继承关系，也就是说type()只检测当前该数据的数据类型</li><li>isinstance()会认为子类队形时一种父类类型，会考虑继承关系，也就是说如果该数据时类的话isinstance()会<br>检测父类的数据类型</li></ol><h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><p>eval()函数用来执行一个字符串表达式，并返回表达式的值，其一般格式为：</p><pre><code>eval(expression[,globals[,locals]])</code></pre><p>其中，expression为表达式。globals为变量作用域，可选，必须是一个字典对象。locals为变量作用域，可选，可以是任何映射(map)对象</p><pre><code>a = eval(&#39;2 + 3&#39;)print(&quot;a: &quot;, a)a, b = eval(input(&quot;请输入两个数(用&#39;,&#39;隔开): &quot;))print(&quot;a: &quot;, a)print(&quot;b: &quot;, b)</code></pre><h2 id="简单了解位运算符"><a href="#简单了解位运算符" class="headerlink" title="简单了解位运算符"></a>简单了解位运算符</h2><p>使用’^’运算对字符加密和解密</p><pre><code>key = input(&quot;请输入加密密匙：&quot;)enc = input(&quot;请输入要加密的字符: &quot;)dec = ord(key) ^ ord(enc)print(&quot;加密结果:&quot;,chr(dec))enc = ord(key) ^ decprint(&quot;解密结果:&quot;,chr(enc))</code></pre><p>1<a href="/img/加密.png"> </a></p><p>在这段程序中我们看到了两个函数ord()和chr():</p><ul><li>ord()函数是对输入的字符转换成ASCII码</li><li>chr()函数是对输入的ASCII码(可以是十进制、十六进制)转换成对应的字符</li></ul>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker的基本操作</title>
    <link href="/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在Linux运维中我们经常会用到docker，docker通过丰富的镜像软件可以为我们的服务操作带来方便</p><a id="more"></a><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>&emsp;&emsp;首先Docker要求CentOS系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本是否支持安装docker。<br>如果内核版本过低就更新一下系统内核</p><pre><code>yum update</code></pre><p>然后安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>设置yum源：</p><pre><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><img src="/img/docker操作_6.png" srcset="/img/loading.gif" alt=" "></p><p>我们可以查看所有仓库中所有docker版本，并选择特定版本安装：</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p><img src="/img/docker操作_5.png" srcset="/img/loading.gif" alt=" "></p><p>做好这些前提准备之后我们就可以安装docker了</p><pre><code>sudo yum install docker-ce-17.12.0.ce</code></pre><p>启动、设置开启开机启动</p><pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre><p>完成上面的操作后验证安装是否成功(有client和service两部分表示docker安装启动都成功了):</p><pre><code>docker version</code></pre><p><img src="/img/docker操作_4.png" srcset="/img/loading.gif" alt=" "></p><p>查看docker启动状态：</p><pre><code>systemctl status docker</code></pre><p><img src="/img/docker操作_3.png" srcset="/img/loading.gif" alt=" "></p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>查询docker安装过的包：<br><img src="/img/docker操作_2.png" srcset="/img/loading.gif" alt=""></p><p>删除安装包：</p><pre><code>yum remove docker-ce.x86_64 ddocker-ce-cli.x86_64 -y</code></pre><p>删除镜像/容器等:</p><pre><code>rm -rf /var/lib/docker</code></pre><h2 id="然后我们还可可以删除容器的方法："><a href="#然后我们还可可以删除容器的方法：" class="headerlink" title="然后我们还可可以删除容器的方法："></a>然后我们还可可以删除容器的方法：</h2><ul><li><p>先停止运行的容器：</p><pre><code>  docker container stop [container-id]</code></pre></li><li><p>然后删除容器：</p></li></ul><pre><code>    docker container rm [container-id]</code></pre><ul><li>最后删除镜像：<pre><code>  docker image rmi [image-id]</code></pre></li></ul><p>获取对应的 id 可以通过命令：<strong>docker container ls</strong>和 <strong>docker image ls</strong>。<br><img src="/img/docker操作_1.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装图床的时可能遇见的问题</title>
    <link href="/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>当你有个人服务器的时候就可以把你的图片存在服务器上，这样就方便以后的存取，这事搭建图床时会遇见的问题。</p><a id="more"></a><h2 id="docker可能遇见的问题"><a href="#docker可能遇见的问题" class="headerlink" title="docker可能遇见的问题"></a>docker可能遇见的问题</h2><p>安装docker时使用在Liunx中使用Docker, 注: Liunx使用的是在虚拟机下的centOS7版本<br>在刚开始安装Docker时没有任何错误, 但是在后续的docker启动过程中, 出现以下问题:</p><pre><code>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>分析一下问题：</p><ol><li>首先查看了一下内核版本</li><li>因为使用命令: yum install docker下载时, 默认下载的是Docker的最新版本, 但是内核版本低的话可能不兼容新版本Docker, 所以有可能出现如上错误</li></ol><p>解决方法：</p><p><strong>步骤一:将以前下载好的Docker卸载干净, 使用如下命令:</strong></p><pre><code>yum remove docker-*</code></pre><p><strong>步骤二:更新该Liunx系统的内核版本,使用如下命令:</strong></p><pre><code>yum update</code></pre><p>建议更新完之后, 重启一下系统</p><p><strong>步骤三:继续下载安装docker(尽量使用高级管理员权限下载)使用如下命令</strong></p><pre><code>yum install docker</code></pre><p><strong>步骤四:使用如下命令启动docker</strong></p><pre><code>sudo systemctl start docker</code></pre><p>问题解决!<br>注：如果这样安装完之后还报错, 按照这个步骤再来一遍即可</p><p><strong>如果使用docker命令时出现如下错误:</strong></p><pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>第一个原因可能是因为docker没有启动<br>第二个原因就是因为docker出现错误<br>归根结底都是docker启动问题, 解决方案还是以上步骤</p><p>22端口是使用的是nginx的服务器<br>80是浏览器的默认端口<br>443端口我设置成图床服务的端口</p><h2 id="Centos-下-nginx-没有-sites-enabled-文件夹问题"><a href="#Centos-下-nginx-没有-sites-enabled-文件夹问题" class="headerlink" title="Centos 下 nginx 没有 sites-enabled 文件夹问题"></a>Centos 下 nginx 没有 sites-enabled 文件夹问题</h2><p>可能是Centos都会遇见的问题解决方法为：<br>编辑 /etc/nginx/nginx.conf 在 http block 中添加：</p><pre><code>include /etc/nginx/sites-enabled/*;</code></pre><p>然后再/etc/nginx 目录下自己创建一个sites-enabled文件夹就好了<br>最后别忘记了重启nginx服务</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo博客搭建到服务器上</title>
    <link href="/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>/2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将hexo 博客搭建到github是一件十分简单得事情，但是在GitHub page中使用你得博客时难免会遇见速度慢、域名不宜与他人分享等等问题，所以当你准备把你网站搭建到服务时就可能遇见很多问题，那我就给大家分享我得在搭建时得心得。</p><a id="more"></a><h1 id="服务器准备阶段"><a href="#服务器准备阶段" class="headerlink" title="服务器准备阶段"></a>服务器准备阶段</h1><p>&emsp;&emsp;国内的服务器有很多，阿里云、百度云、腾讯云、牛七云等等。这些服务器都是大厂的旗下的服务器，所以稳定性还是可以保证的，我选择的是阿里云的学生版一年114元。一核2G的内存价格还是很良心的，如果你想要更低的价格，那某宝应该有适合你的选择。一般国内的互联网公司使用的服务器操作系统主要是Centos。选择Centos作为操作系统即可。当你购买服务之后，阿里会给你一个内网和外网的地址。外网地址就是我们使用浏览器可以查询到的地址，也是我们后面会主要使用到的地址。当然IP地址是不容易记住的我们需要购买一下域名，阿里云很方面都是一站式的。然后就是网站的备案，如果你网站使用的是国内的服务器，是需要备案的，如果你不备案，你的网站时无法访问的。备案的时间时比较长的过程和程序也相对比较麻烦。在这里大家注意一点就是，如果你的备案地址写的是你的学校，那么你就要将你的地址精确到你寝室的楼栋和房间号。</p><p><img src="/img/服务器.png" srcset="/img/loading.gif" alt=" "></p><h1 id="第一步在服务器上安装nginx"><a href="#第一步在服务器上安装nginx" class="headerlink" title="第一步在服务器上安装nginx"></a>第一步在服务器上安装nginx</h1><h2 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h2><p>&emsp;&emsp;Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。。 本例演示 CentOS 7 下安装和配置 Nginx 的基本步骤。</p><h2 id="步骤1：添加yum源"><a href="#步骤1：添加yum源" class="headerlink" title="步骤1：添加yum源"></a>步骤1：添加yum源</h2><pre><code>$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><p>安装完yum源之后，可以查看一下。</p><pre><code>repo id                                 repo name                                                              statusbase/7/x86_64                           CentOS-7                                                               10,097epel/x86_64                             Extra Packages for Enterprise Linux 7 - x86_64                         13,510extras/7/x86_64                         CentOS-7                                                                  307nginx/x86_64                            nginx repo                                                                170updates/7/x86_64                        CentOS-7                                                                1,010repolist: 25,094</code></pre><p>可以发现<font width="bolder" color="red">nginx repo</font>已经安装到本机了</p><h2 id="步骤2：安装"><a href="#步骤2：安装" class="headerlink" title="步骤2：安装"></a>步骤2：安装</h2><p>yum 安装 Nginx，非常简单，一条命令。</p><pre><code>$ sudo yum install nginx</code></pre><h2 id="步骤-3-配置-Nginx-服务"><a href="#步骤-3-配置-Nginx-服务" class="headerlink" title="步骤 3: 配置 Nginx 服务"></a>步骤 3: 配置 Nginx 服务</h2><p>设置开机启动</p><pre><code>$ sudo systemctl enable nginx</code></pre><p>启动服务</p><pre><code>$ sudo systemctl start nginx</code></pre><p>停止服务</p><pre><code>$ sudo systemctl restart nginx</code></pre><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><pre><code>$ sudo systemctl reload nginx</code></pre><p>到这里我们输入我们服务器外网的网址就可以看到<strong>nginx welcome</strong>的欢迎界面。此时就说明你的nginx已经安装完成了。</p><h1 id="在服务器上安装git"><a href="#在服务器上安装git" class="headerlink" title="在服务器上安装git"></a>在服务器上安装git</h1><p><P><br>&emsp;&emsp;当我们把nginx安装到我们的服务器之后，下一步就是安装git。如果之前你已经搭建过hexo博客并且已经将博客搭建在GitHub上时后面的步骤你将会稍微比较熟悉。<br>&lt;/p&gt;</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><pre><code>git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git</code></pre><h2 id="创建用户并配置其仓库"><a href="#创建用户并配置其仓库" class="headerlink" title="创建用户并配置其仓库"></a>创建用户并配置其仓库</h2><pre><code>useradd gitpasswd git // 设置密码su git // 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p projects/blog // 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git // 创建一个裸露的仓库cd blog.git/hooksvi post-receive // 创建 hook 钩子函数，输入了内容如下</code></pre><pre><code>    #!/bin/sh    git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</code></pre><p>添加完毕后修改权限</p><pre><code>chmod +x post-receiveexit // 退出到 root 登录chown -R git:git /home/git/repos/blog.git // 添加权限</code></pre><h2 id="测试git仓库是否可用，另找空白文件夹"><a href="#测试git仓库是否可用，另找空白文件夹" class="headerlink" title="测试git仓库是否可用，另找空白文件夹"></a>测试git仓库是否可用，另找空白文件夹</h2><pre><code>git clone git@server_ip:/home/git/repos/blog.git</code></pre><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><h2 id="Git配置仓库"><a href="#Git配置仓库" class="headerlink" title="Git配置仓库"></a>Git配置仓库</h2><p>&emsp;&emsp;这一部分主要目的是让我们个人的电脑可以通过ssh方式连接到云服务器，然后我们就可以通过命令行方式将我们的博客Po到服务器上。操作如下： 安装git: yum install git 配置git用户 adduser git 修改用户权限:</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoers</code></pre><pre><code>    找到这个位置添加下面这句话 git ALL=(ALL) ALL</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d76b9d87178?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>保存退出后 将sudoers文件权限改回原样</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，然后在~目录下创建.ssh文件夹</p><pre><code>        su git        cd ~        mkdir .ssh        cd .ssh</code></pre><p><strong>生成公钥密钥文件</strong>(重点)</p><font color="red" size="bolder">ssh-keygen</font><p><strong>此时在目录下就会有两个文件，分别是</strong></p><font color="red" size="bolder">id_rsa 和 id_rsa.pub</font><p>其中<strong>id_rsa.pub</strong>就是公钥文件 我们复制一份</p><font color="red" size="bolder">cp id_rsa.pub authorized_keys</font><p><strong>这样目录下就会有一个authorized_keys文件，它和id_rsa.pub一模一样。<br>最后我们修改它的权限</strong></p><pre><code>chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>&emsp;&emsp;但是大家一定要注意在远程连接服务其之前，我们一定要先对我能的服务器进行设置。<br>在root用户下修改 <strong>/etc/ssh/sshd_config</strong> 文件中的<strong>PasswordAuthentication no改为PasswordAuthentication yes</strong> 并保存。<br><img src="https://img.alicdn.com/tfs/TB1B8ELgHsTMeJjSszgXXacpFXa-799-554.png" srcset="/img/loading.gif" alt=" "><br>输入如下命令<strong>sudo service sshd restart</strong>重启SSH服务,就可以重新使用账号密码连接服务器了。<br><img src="https://img.alicdn.com/tfs/TB1OjQ_gMMPMeJjy1XbXXcwxVXa-812-264.png" srcset="/img/loading.gif" alt=" "></p><p>&emsp;&emsp;然后我们在<strong>自己的电脑上自己的电脑上自己的电脑上</strong>（重要的事说三遍），打开cmd，使用ssh方式连接我们的云服务器。<br>     <img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d7a77735c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>最后当你远程连接上你的服务器时，就会出现<br><img src="/img/服务器-4.png" srcset="/img/loading.gif" alt=" "></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我们需要更改hexo博客的根目录下的_config.yml文件将最后一行的的repo：后面改成 </p><pre><code>git@这里写服务器外网IP:/home/git/repos/blog.git</code></pre><p>之后大家就可以来尝试用hexo clean &amp; hexo g &amp; hexo d 来部署大家的博客了。<br><img src="/img/服务器-2.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多文件编译</title>
    <link href="/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<!--banner_img:是当前页面图片--><p>在编译多个文件的时候所出现的报错<br><a id="more"></a></p><h1 id="多文件编译遇见的问题"><a href="#多文件编译遇见的问题" class="headerlink" title="多文件编译遇见的问题"></a>多文件编译遇见的问题</h1><p><img src="/img/报错截图.jpg" srcset="/img/loading.gif" alt=" "></p><p>该错误出现在 command line 为</p><pre><code>gcc coordin.h file1.cpp file2.cpp -o file1</code></pre><p><strong>解决方法为：</strong><br><strong>解决方法是用如下命令进行编译(使用 -l 来连接 stdc++):</strong></p><pre><code>gcc coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre><p><strong>gcc编译cpp文件为什么要加-lstdc++?</strong></p><pre><code>   gcc可以编译c++文件，也可以编译c文件，但默认是编译c文件的，加-lstdc++表示编译c++文件，即链接c++库，加-lc表示链接c库，默认情况下就是链接c库，所以如果编译c文件可以不加-lc。</code></pre><p><strong>另外，你也可以使用 g++, 效果是一样的, stdc++会被自动连接:</strong></p><pre><code>g++ coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单题（1136）</title>
    <link href="/2019/12/15/AC%EF%BC%881136%EF%BC%89/"/>
    <url>/2019/12/15/AC%EF%BC%881136%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这个一道递归优化问题</p><a id="more"></a><h1 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h1><p><strong>题目表述</strong><br>优化一下代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;int f(int n){    if (n &lt; 0) return 0;    if (n == 0) return 1;    return f(n - 1) + f(n - 2);}int main(){        int n;    cin &gt;&gt; n;    cout &lt;&lt; f(n);    return 0;}</code></pre><p><strong>输入</strong><br>    一个小于50的正整数n。<br><strong>输出</strong><br>    f(n)，不要换行。<br><strong>样例输入</strong><br>    3<br><strong>样例输出</strong><br>    3</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;这个题目看起来没有什么意思，但是我们通过分析计算我们会发现。<br>&emsp;&emsp;1. 递归50次后$int$是否够存，<br>&emsp;&emsp;2. 递归50次后会不会爆栈。<br>&emsp;&emsp;3. 我们应该如何优化。<br>&emsp;&emsp;我们将代码复制到编辑器里面后编译会发现在输入49后$int$会溢出说明这49的递归后是一个超过21亿的数，所以我们应该使用$long$ $long$来储存这个庞大的数值。然后就是爆栈的问题，在使用$long$ $long$之后还是能计算出来的说明还没有爆栈，还能计算。然后就是递归的优化问题了。</p><h3 id="什么是递归优化？"><a href="#什么是递归优化？" class="headerlink" title="什么是递归优化？"></a>什么是递归优化？</h3><p>&emsp;&emsp;递归优化是由于递归多次后递归深度过大，导致爆栈。或者是由于递归深度过深之后时间过长，导致之间效率低下。所以我们常见的递归优化有两种。</p><ol><li>尾递归。</li><li>将递归改循环。<br>两种方法，我们在记忆化之后我们发现这些数列之间的插值满足斐波拉切数列。所以我们就可以把这个递归函数改成一个循环函数。就可以实现对递归的优化。</li></ol><p><strong>答案</strong></p><pre><code>#include &lt;iostream&gt;using namespace std;/*int f(int n){    if (n &lt; 0) return 0;    if (n == 0) return 1;    return f(n - 1) + f(n - 2);}*/long long  fibo(int n){    long long nFirst = 0;    long long nSecond = 1;    long long  nThird = 0;    for(int i = 2 ; i &lt;= n; i++){        nThird = nFirst + nSecond;        nFirst = nSecond;        nSecond = nThird;    }    return nThird;}long long f(int n){    long long count = 1;    if(n == 1){        return 1;    }    for (int i = 1; i &lt; n; i++)    {        count += fibo(i);    }    return count+1;}int main(){        int n;    cin &gt;&gt; n;    cout &lt;&lt; f(n);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>训练题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>顺序表简述</p><a id="more"></a><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p><strong>顺序映象</strong>：</p><p>&emsp;&emsp;—— 以x的存储位置和y的春初位置之间某种关系表示逻辑关系<x,y></p><p>最简单的一种顺序映象方式是：</p><p>&emsp;&ensp;令 y 的存储位置和 x 的存储位置相邻。用一组==地址连续==的存储单元==依次存放==线性表中的元素。==线性表的起始地址==，称作线性表的<strong>基地址</strong>。也就是第一个元素。</p><p>以“存储位置相邻”表示有序对$<a_{i-1},a_i>$,即：$LOC(a~i~) = LOC(a~i-1~) + C$;</p><p>&emsp;&ensp;所有数据元素的存储位置。$LOC(a~i~) = LOC(a~1~) + (i - 1) \times C$,其中LOC(a~1~)就是基地址。</p><ul><li>存取结构：与存储结构是两个不同的概念。</li><li>存取结构是在一个数据结构上对查找操作的时间性能的一种描述。</li><li><p>通常由两种存取结构；随机存取结构和顺序存取结构。</p><ul><li>随机存取结构是指在一个数据结构上进行查找的时间性能是$O(1)$,即查找任意一个数据元素的时间时候相等的，均为常数时间，例如顺序表示一种随机存期结构。</li><li>顺序存取结构是指在一个数据结构上进行查找的时间性能是$O(n)$，即查找一个数据元素的时间复杂度是线性的，与该元素在结构中的位置有关，例如单链表是一种顺序存储结构。</li></ul></li></ul><h2 id="顺序映象的C语言描述"><a href="#顺序映象的C语言描述" class="headerlink" title="顺序映象的C语言描述"></a>顺序映象的C语言描述</h2><pre><code>#define LISTSIZE 100  //存储空间最大分配量typedef struct {    ElemType elem[LISTSZIE];    int length;  //当前长度}Sqlist; //Sqlist，代表线性表;</code></pre><ul><li>在线性表的静态分配顺序存储结构中，线性表的最多数据元素个数为LSITSIZE，元素数量不能随意增加，这是以数组方式描述线性表的缺点。</li></ul><p>&emsp;&ensp;为了实现线性表最大存储数据元素数可随意变化，可以使用一个动态的数组来取代上面的固定长度数组，如下描述。</p><p>线性表的动态分配顺序储存结构：</p><pre><code>#define LIST_INIT_SIZE 100  //初始分配量#define LISTINCREMENT 10 //分配分配增量typedef struct {    ElemType *elem;  //储存空间基址    int length; //当前长度    int listsize; //当前分配的存储容量}SqList;// 俗称 顺序表</code></pre><h3 id="线性表操作"><a href="#线性表操作" class="headerlink" title="线性表操作"></a>线性表操作</h3><h3 id="1-InitList-amp-L"><a href="#1-InitList-amp-L" class="headerlink" title="1.InitList(&amp;L);"></a>1.InitList(&amp;L);</h3><p>&emsp;&emsp;InitList(&amp;L); 的实现是一个加工型的运算，因此，将L设为引用参数，首先动态分配存储空间，然后，将length设置为0，表示表中没有数据元素。</p><p>代码实现：</p><pre><code>Status InitList_Sq (SqList &amp;L){    L.elem = (ElemType* )malloc(LIST_INIT_SIZE * sizeof (ElemType));    if (!L.elem){        exit (1);//储存分配失败    }    L.length = 0;    L.listsize = LIST_INIT_SIZE;//初始储存容量;    return OK;}</code></pre><h3 id="2-LocateElme-L-x-compare"><a href="#2-LocateElme-L-x-compare" class="headerlink" title="2.LocateElme(L,x,compare());"></a>2.LocateElme(L,x,compare());</h3><ul><li>线性表中的<strong>按置操作</strong>是指在线性表中查找与给定值X相等的数据元素。</li><li>顺序表中完成该运算最简单的方法是：从第一个元素a~1~起依次和X比较，直到找到一个与X相等的数据元素，则返回它在顺序表中的存储下标记或序号(二者差1);或者查遍整个表都没有找到与X相等的元素，返回ERROR。</li></ul><p>代码实现：</p><pre><code>Status LocateElem_Sq (SqList L, ElemType x){    int i = 0;    while (i &lt;= L.length-1 &amp;&amp; L.elem[i] != x){        i++;    }    if(i &gt; L.length - 1){        return ERROR;    }    else return i;}</code></pre><blockquote><p>本算法的主要运算是比较，显然比较的次数与x在表中的位置有关，也与表长有关。当a~1~ = x时，比较一次成功，当a~n~ = x时比较n次成功，按值查找的平均比较次数为 $\frac{(N+1)}{2}$,时间性能为$O(n)$。</p></blockquote><h3 id="3-ListInsert-amp-L-i-e"><a href="#3-ListInsert-amp-L-i-e" class="headerlink" title="3. ListInsert(&amp;L, i, e)"></a>3. ListInsert(&amp;L, i, e)</h3><p>代码实现:</p><pre><code>Status ListInsert_Sq (SqList &amp;L, int i, ElemType e){    //在顺序表L的第i个元素之前插入新的元素e    //i的合法范围为 1 &lt;=i&lt;=L.length+1    ElemType *q = &amp;(L.elem[i-1]);//q指示插入位置    ElemType *p;    for (p = &amp;(L.elem[L.length-1]); p &gt;= q; --p){            *(p + 1) = *p;//插入位置及之后的元素右移            *q = e;//插入e        ++L.length;//表长增1    }}</code></pre><p>算法时间复杂度为：$O(ListLength(L))$</p><pre><code>if (i &lt; 1 || i &gt; L.length + 1){    return ERROR;//插入位置不合法}if (L.length &gt;= L.listsize){    return OVERFLOW;//当前存储空间已满}</code></pre><h4 id="考虑移动元素的平均情况："><a href="#考虑移动元素的平均情况：" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设在第i个元素之前插入的概率为p~i~,则在长度为<em>n</em>的线性表中插入一个元素为所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_is = \sum_{i = 1}^{n + 1} P_i(n - i + 1)</script><p>所有为位置的概率的累加和。</p><p>&emsp;&emsp;若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_is = \frac{i}{n+1}\sum_{i=1}^{n+1}(n-i+1) = \frac{2}{n}</script><h3 id="4-ListDelete-amp-L-i-amp-e-的实现："><a href="#4-ListDelete-amp-L-i-amp-e-的实现：" class="headerlink" title="4. ListDelete(&amp;L, i, &amp;e)的实现："></a>4. ListDelete(&amp;L, i, &amp;e)的实现：</h3><p>代码实现：</p><pre><code>Status LsitDelet_Sq (SqList &amp;L, int i, ElemType &amp;e){    if((i &lt; 1) || (i &gt; L.length)){        return ERROR;//删除位置不合法    }    p = &amp;(L.elem[i-1]);//p为被删除元素的位置    e = *p;//被删除元素的值赋给e,可以查看被删元素    q = L.elem + L.length-1;//表尾元素的位置，基址加上一个整数值    for (++p; p &lt;= q; ++p){        *(p-1) = *p;//被删除元素之后的元素左移        --L.length;//表长减一    }    return OK;}</code></pre><p>算法时间复杂度为：$O(ListLength(L))$</p><h4 id="考虑移动元素的平均情况：-1"><a href="#考虑移动元素的平均情况：-1" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设删除第i个元素的概率为$q_i$,则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_dl = \sum_{i=1}^{n}q_i(n-i)</script><p>&emsp;&emsp;假设定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_dl=\frac{1}{n}\sum_{i=1}^{n}(n-1)=\frac{n-1}{2}</script>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链式存储</title>
    <link href="/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>链式存储的基本实现</p><a id="more"></a><h2 id="1-3线性表的链式存储结构-单链表"><a href="#1-3线性表的链式存储结构-单链表" class="headerlink" title="1.3线性表的链式存储结构(单链表)"></a>1.3线性表的链式存储结构(单链表)</h2><p>&emsp;&emsp;用一组地址任意的存储来存放线性表中的元素。</p><p>&emsp;&emsp;以<strong>元素</strong>（数据元素的映象）+指针（指示后继元素存储位置）=<strong>结点</strong>（表示数据元素或数据元素的映象）</p><p>&emsp;&emsp;以“结点的序列”表示线性表<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————称作链表</p><p>&emsp;&emsp;以线性表中第一个数据元素a~1~的存储地址作为线性表中的地址，称作线性表的头指针。<br>&emsp;&emsp;有时为了操作方便，在第一个结点之前需加一个“头结点”，以指向头结点的指针为链表的头指针。</p><h3 id="单链表的C语言实现："><a href="#单链表的C语言实现：" class="headerlink" title="单链表的C语言实现："></a>单链表的C语言实现：</h3><pre><code>typedef struct LNode{    ElemType data;//数据域    struct LNode *next;//指针域}LNode, *LinkList;LinkList L;//L为单链表的头指针;</code></pre><p>单链表操作实现的基本实现：</p><ul><li>GetElem(L, i, e)&emsp;//取第i个数据元素</li><li>ListInsert(&amp;L, i, e)&emsp;//插入数据元素</li><li>ListDelete(&amp;L, i, e)&emsp;//删除数据元素</li><li>ClearList(&amp;L)&emsp;//重新置为一个空表</li><li>CreateList(&amp;L, n)&emsp;//生成含$n$个数据元素的链表</li></ul><p>找第1个数据元素，必须先找到第$i-1$个数据元素。因此，查找第i个数据元素的基本操作是==移动指针，比较j和i==。令指针p始终指向线性表中第j个数据元素。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dummy Node</title>
    <link href="/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/"/>
    <url>/2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="链表Dummy-Node"><a href="#链表Dummy-Node" class="headerlink" title="链表Dummy Node"></a>链表Dummy Node</h1><h2 id="（一）Partition-List"><a href="#（一）Partition-List" class="headerlink" title="（一）Partition List"></a>（一）Partition List</h2><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-list/description/</a></p><p><strong>题目：给出一个链表和一个x值，要求返回一个顺序链表使得小于x的数在链表前面，大于等于x的数在链表后面，保证节点顺序不变。</strong></p><pre><code>      例如：$1-&gt;3-&gt;2-&gt;4-&gt;2, 3$ 变成：$1-&gt;2-&gt;2-&gt;3-&gt;4$</code></pre><font color="#435d6c" size="3px">解答：建立两个新的左、右指针及dummy node，使用head指针遍历整个链表，遇到大于等于head的节点则放到右链表，否则放到左链表。最后将左右链表相连。第一次犯错：忘记将又指针的尾部指向null;</font><p>代码：</p><pre><code>class Solution {    public ListNode partition(ListNode head, int x) {         if (head == null) {            return head;        }        ListNode leftDummy = new ListNode(0);        ListNode rightDummy = new ListNode(0);        ListNode left = leftDummy;        ListNode right = rightDummy;        while (head != null) {            if (head.val &gt;= x) {                right.next = head;                right = right.next;            } else {                left.next = head;                left = left.next;            }            head = head.next;        }        right.next = null;        left.next = rightDummy.next;        return leftDummy.next;    }}</code></pre><h2 id="（二）-Merge-Two-Sorted-Lists"><a href="#（二）-Merge-Two-Sorted-Lists" class="headerlink" title="（二） Merge Two Sorted Lists"></a>（二） Merge Two Sorted Lists</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></p><font color="red">AC！</font><p><b>题目：将两个顺序链表合并成一个顺序链表；</b></p><font color="#435d6c" size="3px">解答：依次比较两个链表里的值大小进行排列；</font><p>改进：当一个链表指针指向null，另一个链表还没时，可以直接将重新排列的链表尾指向当前指针：</p><pre><code>           if (l1 != null) {           head.next = l1;           } else {           head.next = l2;          }</code></pre><p>代码：</p><pre><code>class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode(0);        ListNode head = dummy;        while (l2 != null &amp;&amp; l1 != null) {            if (l1.val &lt;= l2.val) {                head.next = l1;                l1 = l1.next;            } else {                head.next = l2;                l2 = l2.next;            }            head = head.next;        }         while (l1 != null) {            head.next = l1;            l1 = l1.next;            head = head.next;        }        while (l2 != null) {            head.next = l2;            l2 = l2.next;            head = head.next;        }        head.next = null;        return dummy.next;    }}</code></pre><h2 id="（三）swap-two-nodes-in-linked-list"><a href="#（三）swap-two-nodes-in-linked-list" class="headerlink" title="（三）swap two nodes in linked list"></a>（三）swap two nodes in linked list</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/description/</a></p><font color="red" >AC！</font><p><b>题目：两两交换链表中节点位置。</b>如：$1-&gt;2-&gt;4-&gt;5-&gt;6$ 转变为: $2-&gt;1-&gt;5-&gt;4-&gt;6$</p><font color="#435d6c" size="3px">解答：使用两个指针遍历链表；</font><p>代码：</p><pre><code>class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null) {            return head;        }        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode headNext = head.next;        ListNode headPrev = dummy;        while (head != null &amp;&amp; headNext != null) {            headPrev.next = headNext;            head.next = headNext.next;            headNext.next = head;            headPrev = head;            head = head.next;            if (head != null) {                headNext = head.next;            }        }        return dummy.next;    }}</code></pre><h2 id="（四）reorder-list"><a href="#（四）reorder-list" class="headerlink" title="（四）reorder list"></a>（四）reorder list</h2><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/reorder-list/description/</a></p><p><b>题目：给定一个单链表：</b>$L0-&gt;L1-&gt;…-&gt;Ln-1-&gt;Ln,$</p><pre><code>      重新排序后为：$L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2-&gt;...$</code></pre><font color="#435d6c" size="3px">解答：第一次犯错：将链表尾连接到头之后，忘记将尾的前一个指针指向空；第二次犯错：忘记考虑链表头和prevTail重合的情况（偶数链表）。</font><p>代码：</p><pre><code>class Solution {    public void reorderList(ListNode head) {        while (head != null &amp;&amp; head.next != null) {            ListNode prevTail = head;            while (prevTail.next.next != null) {                prevTail = prevTail.next;            }            ListNode tail = prevTail.next;            if (head.next == tail) {                break;            }             tail.next = head.next;            head.next = tail;            head = head.next.next;            prevTail.next = null;        }    }}</code></pre><h2 id="（四）Rotate-List"><a href="#（四）Rotate-List" class="headerlink" title="（四）Rotate List"></a>（四）Rotate List</h2><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-list/description/</a></p><p><strong>题目：将链表尾部的k个节点移到链表头部；</strong></p><font color="#435d6c" size="3px">解答：每次将链表最后一个节点移动至链表头，移动k次；</font><p>第一次犯错：（超时）先遍历链表，得到链表长度length，循环只需执行 k%length 次；</p><p>代码：</p><pre><code>class Solution {    public ListNode rotateRight(ListNode head, int k) {        ListNode tail = head;        int length = 0;        while (tail != null ) {            length++;            tail = tail.next;        }        if (length == 0 || length == 1) {            return head;        }        for (int i = 0; i &lt; k % length; i++) {            ListNode preTail = head;            while (preTail != null &amp;&amp; preTail.next != null &amp;&amp; preTail.next.next != null) {                preTail = preTail.next;            }            tail = preTail.next;            tail.next = head;            preTail.next = null;            head = tail;        }        return head;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>二叉树有多种遍历的方式我们简单总结一下</p><a id="more"></a><h1 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h1><p><p>&emsp;&emsp;<b>二叉树的遍历(treaversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</b>这是二叉树遍历的定义。二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分四种。</p></p><ol><li>前序遍历(PreOrder)<br></li><li>中序遍历(InOrder)<br></li><li>后续遍历(PastOrder)<br></li><li>层序遍历(LevelOrder)<br></li></ol><p>树的前中后序遍历是个递归的定义，在遍历到根节点的左/右子树时，也要遵循前/中/后序遍历的顺序，例如下面这棵树：</p><p>前序遍历：ABDECFG<br>中序遍历：DBEAFCG<br>后序遍历：DEBFGCA<br>层序遍历：ABCDEFG</p><p>树的结点结构体声明如下：<br>语言：C语言（为了省事用到了C++的栈，因为C语言要用栈的话要自己重新写一个出来，就偷了个懒）<br>编译器：VS</p><pre><code>typedef char DataType;typedef struct TreeNode{    DataType data;    struct TreeNode *left;    struct TreeNode *right;}TreeNode;</code></pre><p>前序遍历（先序遍历）<br>对于一棵树的前序遍历，递归的写法是最简单的（写起来），就是将一个大的问题转化为几个小的子问题，直到子问题可以很容易求解，最后将子问题的解组合起来就是大问题的解。</p><p>前序访问的递归写法<br>先放代码，如果看完觉得不太清楚可以看看下面的详细步骤图解。</p><pre><code>void PreOrder(const TreeNode *root){    if (root == NULL)                 //若结点为空    {        printf(&quot;# &quot;);        return;    }    printf(&quot;%c &quot;, root-&gt;data);        //输出根节点的值    PreOrder(root-&gt;left);             //前序访问左子树    PreOrder(root-&gt;right);            //前序访问右子树}</code></pre><p>比如说还是上面的这颗树：</p><p>访问根节点</p><p>访问左子树</p><p>走到这里之后发现根节点的左孩子还是一棵子树，那就将访问这棵子树看作是遍历整颗树的一个子问题，遍历这棵子树的方法和遍历整颗树的方法是一样的。<br>然后继续访问它的左子树：</p><p>为了理解起来方便一点，我在这里加上了它的两个为空的左右孩子<br>然后发现这（可能）还是一棵子树，就继续用这种方法来对待这颗子树，就是继续访问它的左子树：</p><p>发现这是一个空节点，那就直接返回，去访问它的右子树：</p><p>发现还是一个空节点，那么继续返回，这时候D和它的左右孩子结点都访问过了，继续返回，应该访问B的右子树了。</p><p>然后就和D结点一样的处理方法，-&gt;左孩子，发现是空，返回-&gt;右孩子，发现还是空，继续返回，发现这时候B的左右孩子都访问过了，继续返回。<br>访问右子树</p><p>然后和处理A的左子树的方法一样，最后访问到G结点的右子树时，发现是空，就返回，这时候树的所有节点都已经访问过了，所以可以一路返回到A结点的右子树完的地方，整个递归就结束了。</p><p>最后输出的前序访问序列便是：ABDECFG<br>前序访问的非递归写法<br>还是先上代码：</p><pre><code>void PreOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            printf(&quot;%c &quot;, cur-&gt;data);            s.push(cur);            cur = cur-&gt;left;        }        top = s.top();        s.pop();        cur = top-&gt;right;    }}</code></pre><p>非递归的写法比递归写法要麻烦一点，要用到栈来存储树的结点，在理解非递归方法的时候要重点理解栈中保存的元素的共同点是什么，在前序访问中，栈中元素都是自己和自己的左孩子都访问过了，而右孩子还没有访问到的节点，如果不太懂可以看下面的详细步骤图解。</p><p>首先我们要用一个指针（cur）来指向当前访问的结点</p><p>发现这个节点不为空，就将它的数据输出，然后将这个节点的地址（图上的栈中写了节点的值是为了便于理解，实际上栈中保存的是节点地址）压栈。</p><p>再去访问它的左子树，发现左孩子结点依旧不为空，继续输出并压栈。</p><p>同理压栈D节点</p><p>然后访问D的左孩子，发现为空，便从栈中拿出栈顶结点top，让cur = top-&gt;right,便访问到了D的右孩子。</p><p>发现D的右孩子还是为空，这个看一下栈，发现栈不为空，说明还存在右孩子没被访问过的节点，就继续从栈中拿出栈顶结点top，让cur = top-&gt;right，便访问到了B的右孩子。</p><p>B的右孩子处理方法和D一样，然后再从栈中拿出A节点，去访问A的右孩子C，在访问到G节点的右孩子之后，发现当前节点cur为空，栈中也没有元素可以取出来了，这时候就代表整棵树都被访问过了，便结束循环。</p><p>最后输出的前序访问序列便是：ABDECFG<br>中序遍历<br>对于一棵树的中序遍历，和前序一样，可以分为递归遍历和非递归遍历，递归遍历是相对简单的，还是子问题思想，将一个大问题分解，直到可以解决，最后解决整个大问题。</p><p>中序遍历的递归写法<br>还是先上代码：</p><pre><code>void InOrder(const TreeNode *root){    if (root == NULL)              //判断节点是否为空    {        printf(&quot;# &quot;);        return;    }    InOrder(root-&gt;left);           //中序遍历左子树    printf(&quot;%c &quot;, root-&gt;data);     //访问节点值    InOrder(root-&gt;right);          //中序遍历右子树}</code></pre><p>从根节点进入</p><p>发现根节点不为空，访问左子树</p><p>发现不为空，继续访问左子树</p><p>发现不为空，继续访问左子树</p><p>这时root为空了，就返回去访问它的根节点，刚才的访问只是路过，并没有真正地遍历节点的信息，在返回途中才是真正地遍历到了节点的信息。</p><p>访问到了D节点，下来要访问的是D的右孩子，因为D的左孩子已经访问过了。</p><p>发现还是空，就返回，而它的根节点D也访问过了，那么就继续返回，该访问D节点的父节点B了。</p><p>B访问过后下来要访问的是B的右孩子，因为是从B的左子树回来的路，B的左孩子已经访问过了。</p><p>然后和访问D一样，-&gt;左孩子，为空，返回访问根节点E，-&gt;右孩子，为空（这部分就不画了，和D节点的访问是一样的），最后返回，B已经访问过了，就继续返回，至此，整颗树的左子树访问完了。</p><ol><li><p>访问B的根节点A</p></li><li><p>遍历A的右子树<br>遍历右子树的过程和左子树一样，还是左-&gt;根-&gt;右的中序遍历下去，直到遍历到G的右孩子，发现为空，就返回，因为右子树都遍历过了，所以可以一直返回到root为A节点的那一层递归，整个遍历结束。</p></li></ol><p>最后输出的中序访问序列为：DBEAFCG</p><p>非递归写法<br>中序访问的非递归写法和前序一样，都要用到一个栈来辅助存储，不一样的地方在于前序访问时，栈中保存的元素是右子树还没有被访问到的节点的地址，而中序访问时栈中保存的元素是节点自身和它的右子树都没有被访问到的节点地址。</p><p>先上代码：</p><pre><code>void InOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            s.push(cur);            cur = cur-&gt;left;        }        cur = s.top();        s.pop();        printf(&quot;%c &quot;, cur-&gt;data);        cur = cur-&gt;right;    }}</code></pre><p>cur指针一路沿着最左边往下访问，路过的节点全部压栈，直到遇到空节点</p><p>从栈中取出栈顶节点top，输出栈顶结点的值并使cur = top-&gt;right，从第一步开始去遍历top的右子树。</p><p>遍历完之后，cur走到了D节点的右孩子，发现cur 为空，但栈中还有元素，就重复第二步</p><p>这时候，cur走到了E节点的右孩子，发现cur 为空，但栈中还有元素，就继续重复第二步，之后cur = top-&gt;right，cur指针继续去遍历A节点的右子树，从第一步开始</p><p>访问到F的左孩子节点发现是空，这时候栈中还有元素，就重复第二步</p><p>照这个规则依次访问下去，最后会访问到G节点的右孩子，这时候cur为空，栈也空了，就代表所有节点已经遍历完了，就结束循环，遍历完成。</p><p>最后输出的中序访问序列为:DBEAFCG</p><p>后序遍历<br>后序遍历还是分递归版本和非递归版本，后序遍历的递归版本和前序中序很相似，就是输出根节点值的时机不同，而后序遍历的非递归版本则要比前序和中序的要难一些，因为在返回根节点时要分从左子树返回和右子树返回两种情况，从左子树返回时不输出，从右子树返回时才需要输出根节点的值。</p><p>递归写法<br>先上代码：</p><pre><code>void PostOrder(TreeNode *root){    if (root == NULL)    {        printf(&quot;# &quot;);        return;    }    PostOrder(root-&gt;left);    PostOrder(root-&gt;right);    printf(&quot;%c &quot;, root-&gt;data);}</code></pre><p>后序遍历的递归版本和前中序非常相似，就是输出根节点值的时机不同，详细图解这里就不画了，可以联系前中序的递归版本来理解。</p><p>后序遍历的非递归写法<br>后序遍历的非递归同样要借助一个栈来保存元素，栈中保存的元素是它的右子树和自身都没有被遍历到的节点，与中序遍历不同的是先访问右子树，在回来的时候再输出根节点的值。需要多一个last指针指向上一次访问到的节点，用来确认是从根节点的左子树返回的还是从右子树返回的。</p><p>先上代码：</p><pre><code>void PostOrderLoop(TreeNode *root){    std::stack&lt;TreeNode *&gt; s;    TreeNode *cur, *top, *last = NULL;    cur = root;    while (cur != NULL || !s.empty())    {        while (cur != NULL)        {            s.push(cur);            cur = cur-&gt;left;        }        top = s.top();        if (top-&gt;right == NULL || top-&gt;right == last){            s.pop();            printf(&quot;%c &quot;, top-&gt;data);            last = top;        }        else {            cur = top-&gt;right;        }    }}</code></pre><p>还是沿着左子树一路往下走，将路过的节点都压栈，直到走到空节点。</p><p>然后从栈中看一下栈顶元素（只看一眼，用top指针记下，先不出栈），如果top节点没有右子树，或者last等于top的右孩子，说明top的右子树不存在或者遍历过了，就输出top节点的值，并将栈顶元素pop掉（出栈），反之则是从左子树回到根节点的，接下来要去右子树。</p><p>如图，top的右孩子为空，说明右子树不存在，就可以输出top的值并pop掉栈顶了，这时候用last指针记下top指向的节点，代表上一次处理的节点。（这一过程cur始终没有动，一直指向空）</p><p>继续从栈顶看一个元素记为top，然后发现top的右孩子不为空，而且last也不等于top-&gt;right，就使cur = top-&gt;right，回到第一步，用同样的方法来处理top的右子树，下一次回来的时候，last指针指向的是E节点。</p><p>这时候发现top的右孩子不为空，但是last等于top-&gt;right，说明top的右子树遍历完成，下一步就要输出top的值并且将这个节点出栈，下一次再从栈中看一个栈顶元素A即为top。</p><p>这时候再比较，发现top的right不为空，而且last也不等于top-&gt;right，说明top有右子树并且还没有遍历过，就让cur = top-&gt;right，回到第一步用同样的方法来遍历A的右子树。<br>到最后，cur访问到了G的左孩子，而top也一路出栈到了A节点，发现cur为空，并且栈中也为空，这时候便代表整个树已经遍历完成，结束循环。</p><p>最后输出的中序访问序列为:DEBFGCA</p><p>层序遍历<br>层序遍历是比较接近人的思维方式的一种遍历方法，将二叉树的每一层分别遍历，直到最后的叶子节点被全部遍历完，这里要用到的辅助数据结构是队列，队列具有先进先出的性质。</p><p>上代码：</p><pre><code>void LevelOrder(TreeNode *root){    std::queue&lt;TreeNode *&gt; q;    TreeNode *front;    if (root == NULL)return;    q.push(root);    while (!q.empty())    {        front = q.front();        q.pop();        if (front-&gt;left)            q.push(front-&gt;left);        if (front-&gt;right)            q.push(front-&gt;right);        printf(&quot;%c &quot;, front-&gt;data);    }}</code></pre><p>层序遍历的思路是，创建一个队列，先将根节点（A）入队，然后用front指针将根节点记下来，再将根节点出队，接下来看front节点（也就是刚才的根节点）有没有左孩子或右孩子，如果有，先左（B）后右（C）入队，最后输出front节点的值，只要队列还不为空，就说明还没有遍历完，就进行下一次循环，这时的队头元素（front）则为刚才入队的左孩子（B），然后front出队，再把它的左右孩子拉进来（如果有），因为队列的先进先出性质，B的左右孩子DE是排在C后面的，然后输出B，下一次循环将会拉人C的左右孩子FG，最后因为FG没有左右孩子，一直出队，没有入队元素，队列迟早会变为空，当队列为空时，整颗树就层序遍历完成了，结束循环。</p><p>根节点入队，并用front指针标记</p><p>队头出队，并将左右孩子拉进队列</p><p>重复1，2</p><p>直到队列为空</p><p>这时候便代表整个树遍历完成，结束循环。<br>最后输出的层序访问序列为:ABCDEF</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MinGw如何调试？</title>
    <link href="/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>MinGw调试方法</p><a id="more"></a><h1 id="MinGW调试命令"><a href="#MinGW调试命令" class="headerlink" title="MinGW调试命令"></a>MinGW调试命令</h1><p>&emsp;&emsp;MinGW（Minimalist GNU for Windows）提供了一套简单方便的Windows下的基于GCC程序开发环境。MinGW收集了一系列免费的Windows是用的头文件和库文件；同时整合了GNU的工具集，特别是GNU程序开发工具，如经典的gcc，g++，make等。MinGW是完全免费的自由软件，它在Windows平台下模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好的基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。简单的说，它是个精简的C/C++编译器，它实际上是将经典的开源C语言/C++编译器GCC/G++移植到了Windows下，并且包含了Win32API，因此可以将源代码编译生成Windows下的可执行程序。虽然VC6等编译器，只要点击鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑，而MinGW则只会生成一个可执行文件</p><hr><h2 id="gdb调试测试代码-test-c-："><a href="#gdb调试测试代码-test-c-：" class="headerlink" title="gdb调试测试代码(test.c)："></a>gdb调试测试代码(test.c)：</h2><pre><code>#include &lt;stdio.h&gt;void swap(int *a,int *b){    int temp = *a;    *a = *b;    *b = temp;}int main(void){    int a=1,b=2;    swap(&amp;a,&amp;b);    printf(&quot;a = %d ,b = %d\n&quot;,a,b);    return 0;}</code></pre><h3 id="要支持调试，在编译时要加入-g选项，编译命令："><a href="#要支持调试，在编译时要加入-g选项，编译命令：" class="headerlink" title="要支持调试，在编译时要加入-g选项，编译命令："></a>要支持调试，在编译时要加入-g选项，编译命令：</h3><pre><code>gcc text.c -g text.exe</code></pre><h3 id="出现调试命令："><a href="#出现调试命令：" class="headerlink" title="出现调试命令："></a>出现调试命令：</h3><pre><code>GNU gdb (GDB) 7.6.1Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;mingw32&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from D:\mypro\C\test.exe...done.(gdb)</code></pre><h3 id="gdb调试命令表："><a href="#gdb调试命令表：" class="headerlink" title="gdb调试命令表："></a>gdb调试命令表：</h3><div class="table-container"><table><thead><tr><th>命令</th><th style="text-align:center">解释</th><th style="text-align:right">简写</th></tr></thead><tbody><tr><td>file</td><td style="text-align:center">加载一个可执行文件，也可以在运行gdb的时候加载，两种方法都不会运行程序</td><td style="text-align:right">无</td></tr><tr><td>list</td><td style="text-align:center">列出可执行源码的一部分，通常在程序开始运行前执行，用来设置断点</td><td style="text-align:right">l</td></tr><tr><td>next</td><td style="text-align:center">单步调试，不进入函数</td><td style="text-align:right">n</td></tr><tr><td>step</td><td style="text-align:center">单步调试，进入函数</td><td style="text-align:right">s</td></tr><tr><td>run</td><td style="text-align:center">运行加载了的程序</td><td style="text-align:right">r</td></tr><tr><td>continue</td><td style="text-align:center">继续执行程序</td><td style="text-align:right">c</td></tr><tr><td>quit</td><td style="text-align:center">退出调试</td><td style="text-align:right">q</td></tr><tr><td>print</td><td style="text-align:center">输出制定的变量的值，变量要在程序运行处可见</td><td style="text-align:right">p</td></tr><tr><td>break</td><td style="text-align:center">设置断点</td><td style="text-align:right">b</td></tr><tr><td>info break</td><td style="text-align:center">查看断点的信息</td><td style="text-align:right">i b</td></tr><tr><td>delete</td><td style="text-align:center">删除断点</td><td style="text-align:right">d</td></tr><tr><td>watch</td><td style="text-align:center">监视一个变量的值，一旦值发生变化，程序将会被暂停执行</td><td style="text-align:right">wa</td></tr><tr><td>help</td><td style="text-align:center">查看gdb的帮助信息</td><td style="text-align:right">h</td></tr></tbody></table></div><h3 id="1-l命令，列出部分代码："><a href="#1-l命令，列出部分代码：" class="headerlink" title="1.l命令，列出部分代码："></a>1.l命令，列出部分代码：</h3><p>在(gdb)后面输入l可以显示一部分代码再输入一次l可以显示全部代码</p><pre><code>(gdb) l2   3   void swap(int *a,int *b){4       int temp = *a;5       *a = *b;6       *b = temp;7   }8   9   int main(void)10  {11      int a=1,b=2;(gdb)(gdb) l12      swap(&amp;a,&amp;b);13      printf(&quot;a = %d ,b = %d\n&quot;,a,b);14      return 0;15  }(gdb) l(gdb) Line number 16 out of range; test.c has 15 lines</code></pre><h3 id="2-start命令，开始运行，会停到main入口处："><a href="#2-start命令，开始运行，会停到main入口处：" class="headerlink" title="2.start命令，开始运行，会停到main入口处："></a>2.start命令，开始运行，会停到main入口处：</h3><pre><code>(gdb) startTemporary breakpoint 1 at 0x401491: file test.c, line 11.Starting program: D:\mypro\C/test.exe [New Thread 8000.0x18c4][New Thread 8000.0x2418]Temporary breakpoint 1, main () at test.c:1111      int a=1,b=2</code></pre><h3 id="4-n命令：单步调试，不进入函数，跳到第12行"><a href="#4-n命令：单步调试，不进入函数，跳到第12行" class="headerlink" title="4.n命令：单步调试，不进入函数，跳到第12行:"></a>4.n命令：单步调试，不进入函数，跳到第12行:</h3><pre><code>(gdb) n12      swap(&amp;a,&amp;b);</code></pre><h3 id="5-s命令：单步调试，进入函数，跳到第4行"><a href="#5-s命令：单步调试，进入函数，跳到第4行" class="headerlink" title="5.s命令：单步调试，进入函数，跳到第4行:"></a>5.s命令：单步调试，进入函数，跳到第4行:</h3><pre><code>gdb) sswap (a=0x61ff2c, b=0x61ff28) at test.c:44       int temp = *a;</code></pre><h3 id="6-b命令设置断点（b-第n行代码的行数）："><a href="#6-b命令设置断点（b-第n行代码的行数）：" class="headerlink" title="6.b命令设置断点（b + 第n行代码的行数）："></a>6.b命令设置断点（b + 第n行代码的行数）：</h3><pre><code>(gdb) b 6Breakpoint 2 at 0x401478: file test.c, line 6.</code></pre><h3 id="7-r命令-运行程序，直到下一个断点就停："><a href="#7-r命令-运行程序，直到下一个断点就停：" class="headerlink" title="7.r命令,运行程序，直到下一个断点就停："></a>7.r命令,运行程序，直到下一个断点就停：</h3><pre><code>The program being debugged has been started already.Start it from the beginning? (y or n)...Breakpoint 2, swap (a=0x61ff2c, b=0x61ff28) at test.c:66       *b = temp;</code></pre><h3 id="7-p命令-输出制定的变量的值，变量要在程序运行处可见"><a href="#7-p命令-输出制定的变量的值，变量要在程序运行处可见" class="headerlink" title="7.p命令,输出制定的变量的值，变量要在程序运行处可见:"></a>7.p命令,输出制定的变量的值，变量要在程序运行处可见:</h3><pre><code>(gdb) p *a$1 = 2(gdb) p *b$2 = 2(gdb) p a$3 = (int *) 0x61ff2c(gdb) p b$4 = (int *) 0x61ff28</code></pre><p>next一下，再看b的值：</p><pre><code>(gdb) n7   }(gdb) p *b$5 = 1</code></pre><h3 id="8-i-b命令-查看断点信息"><a href="#8-i-b命令-查看断点信息" class="headerlink" title="8.i b命令,查看断点信息:"></a>8.i b命令,查看断点信息:</h3><pre><code>(gdb) i bNum     Type           Disp Enb Address    What2       breakpoint     keep y   0x00401478 in swap at test.c:6    breakpoint already hit 1 time</code></pre><h3 id="9-d命令-删除断点，不加断点位置即删除所有断点"><a href="#9-d命令-删除断点，不加断点位置即删除所有断点" class="headerlink" title="9.d命令,删除断点，不加断点位置即删除所有断点:"></a>9.d命令,删除断点，不加断点位置即删除所有断点:</h3><pre><code>(gdb) d Delete all breakpoints? (y or n) [answered Y; input not from terminal](gdb) i bNo breakpoints or watchpoints.</code></pre><h3 id="10-没有断点后，再试一下r命令，可以看到，执行完了程序："><a href="#10-没有断点后，再试一下r命令，可以看到，执行完了程序：" class="headerlink" title="10.没有断点后，再试一下r命令，可以看到，执行完了程序："></a>10.没有断点后，再试一下r命令，可以看到，执行完了程序：</h3><pre><code>(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) [answered Y; input not from terminal]error return ../../gdb-7.6.1/gdb/windows-nat.c:1275 was 5Starting program: D:\mypro\C/test.exe [New Thread 1976.0x1460][New Thread 1976.0x5e0]a = 2 ,b = 1[Inferior 1 (process 1976) exited normally</code></pre><h3 id="11-q命令，退出gdb："><a href="#11-q命令，退出gdb：" class="headerlink" title="11.q命令，退出gdb："></a>11.q命令，退出gdb：</h3><pre><code>(gdb) q</code></pre>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>remove_list_entry</title>
    <link href="/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/"/>
    <url>/2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学习如何写有品味的代码</p><a id="more"></a><h1 id="remove-list-entry（无需-if-逻辑）"><a href="#remove-list-entry（无需-if-逻辑）" class="headerlink" title="remove_list_entry（无需 if 逻辑）"></a>remove_list_entry（无需 if 逻辑）</h1><p>&emsp;&emsp;这是期TED里面的内容，内容是采访linux的之父Linus Torvalds。<br>&emsp;&emsp;Linus Torvalds两次改变了技术，第一次是Linux内核，它帮助互联网的发展，第二次是Git，全球开发者使用的源代码管理系统。在一次TED的采访中，Torvalds以极其开放的态度讨论了他独特的工作方式和性格特点。Torvalds说：“我不是一个空想家，我是一名工程师，我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹，看着满天星辰说，“我想到那儿去。”但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去，这就是我。”***</p><p>&emsp;&emsp;在聊天中CA问道了一个关于代码品味的的问题，这个问题其实很有意思，对于很多写代码的人来说，有好的代码风格和代码品味就好比有了一种审美品味一样。就好比在写代码时你的缩进习惯一样。</p><blockquote><p>第一段代码</p></blockquote><pre><code>remove_list_entry(entry){    prev = NULL;    walk = head;​    // Walk the list​    while (walk != entry)    {        prev = walk;        walk = walk-&gt;next;    }    // Remove the entry by updating the     // head or the previous entry    if(!prev)    {        head = entry-&gt;next;    }    else    {        prev-&gt;next = entry-&gt;next;    } }</code></pre><blockquote><p>第二段代码</p></blockquote><pre><code>remove_list_entry(entry){    // The &quot;indirect&quot; pointer points to the    // *address* of the thing we&#39;ll update    indirect = &amp;head;​    // Walk the list, looking for the thing that    // points to the entry we want to remove     while ((*indirect) != entry))    {        indirect = &amp;(*indirect)-&gt;next;    }​    // .. and just remove it    *indirect = entry-&gt;next;}</code></pre><font color="red" size="2px">这里我注释一下哈，这两段代码都是伪码。所以看起来有点奇怪</font><p>&emsp;&emsp;看起来这两段代码功能上都一样的但是，第一段的最后用了一个if和一个else目的在于处理特殊情况，但是第二段代码很简洁没有if和else来处理特殊情况，这是一种很有意思且巧妙的思想同样<b>Dummy Node链表</b>也是一种处理方式，在这里不讨论，后面我回专门来说这种链表。</p><pre><code>Node *head, *prev, *walk;void remove_list_entry(Node* entry){    prev = NULL;    // walk 这一变量名，十分巧妙，    // 变量命名的不二法门就是对应其物理（实际）意义    walk = head;    while (walk != entry)    {        prev = walk;        walk = walk-&gt;next;    }    // 也即没有执行 while 循环，walk == entry，entry == head    if (!prev)        head = entry-&gt;next;    else        prev-&gt;next = entry-&gt;next;}</code></pre><pre><code>void remove_list_entry(Node* entry){    Node **indirect;    indirect = &amp;head;    while ((*indirect) != entry)        indirect = &amp;(*indirect)-&gt;next;    *indirect = entry-&gt;next;}</code></pre><font color="#24495e" size="2"><p>&emsp;&emsp;这是两段代码的表准形式</p></font><p>&emsp;&emsp;为什么要区分是头指针呢，因为整个程序的逻辑是找到被删除指针的前一个指针，如果被删除的指针为头指针，显然其没有前一个指针。显然这种的代码不具很好的 taste，话说 Jobs 也很爱讲 taste（Windows 最大的特点就是 has no taste）。<b>这两段代码的显著区别就是第二段代码省略了 if 语句，</b>对头指针和前一个指针做了统一化处理。头指针没有前一个指针，但有自己的地址，自己的地址自然还是指向自己。</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/06/hello-world/"/>
    <url>/2019/12/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>first txt<br><a id="more"></a></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
