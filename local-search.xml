<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker的基本操作</title>
    <link href="undefined2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>2020/01/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在Linux运维中我们经常会用到docker，docker通过丰富的镜像软件可以为我们的服务操作带来方便</p><a id="more"></a><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>&emsp;&emsp;首先Docker要求CentOS系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本是否支持安装docker。<br>如果内核版本过低就更新一下系统内核</p><pre><code>yum update</code></pre><p>然后安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>设置yum源：</p><pre><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p><img src="https://img2018.cnblogs.com/blog/1068501/201811/1068501-20181128145022180-347869770.png" srcset="/img/loading.gif" alt=" "></p><p>我们可以查看所有仓库中所有docker版本，并选择特定版本安装：</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p><img src="https://img2018.cnblogs.com/blog/1068501/201811/1068501-20181128145202512-1932354955.png" srcset="/img/loading.gif" alt=" "></p><p>做好这些前提准备之后我们就可以安装docker了</p><pre><code>sudo yum install docker-ce-17.12.0.ce</code></pre><p>启动、设置开启开机启动</p><pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre><p>完成上面的操作后验证安装是否成功(有client和service两部分表示docker安装启动都成功了):</p><pre><code>docker version</code></pre><p><img src="https://img2018.cnblogs.com/blog/1068501/201811/1068501-20181128145435943-1657031411.png" srcset="/img/loading.gif" alt=" "></p><p>查看docker启动状态：</p><pre><code>systemctl status docker</code></pre><p><img src="https://img2018.cnblogs.com/blog/1068501/201811/1068501-20181128145740523-1861877184.png" srcset="/img/loading.gif" alt=" "></p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>查询docker安装过的包：<br><img src="https://img2018.cnblogs.com/blog/1068501/201811/1068501-20181128144322696-1037021590.png" srcset="/img/loading.gif" alt=""></p><p>删除安装包：</p><pre><code>yum remove docker-ce.x86_64 ddocker-ce-cli.x86_64 -y</code></pre><p>删除镜像/容器等:</p><pre><code>rm -rf /var/lib/docker</code></pre><h2 id="然后我们还可可以删除容器的方法："><a href="#然后我们还可可以删除容器的方法：" class="headerlink" title="然后我们还可可以删除容器的方法："></a>然后我们还可可以删除容器的方法：</h2><ul><li><p>先停止运行的容器：</p><pre><code>  docker container stop [container-id]</code></pre></li><li><p>然后删除容器：</p></li></ul><pre><code>    docker container rm [container-id]</code></pre><ul><li>最后删除镜像：<pre><code>  docker image rmi [image-id]</code></pre></li></ul><p>获取对应的 id 可以通过命令：<strong>docker container ls</strong>和 <strong>docker image ls</strong>。<br><img src="https://img-blog.csdnimg.cn/20190503075937144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzU5MDUx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安装图床的时可能遇见的问题</title>
    <link href="undefined2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>2020/01/09/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>当你有个人服务器的时候就可以把你的图片存在服务器上，这样就方便以后的存取，这事搭建图床时会遇见的问题。</p><a id="more"></a><h2 id="docker可能遇见的问题"><a href="#docker可能遇见的问题" class="headerlink" title="docker可能遇见的问题"></a>docker可能遇见的问题</h2><p>安装docker时使用在Liunx中使用Docker, 注: Liunx使用的是在虚拟机下的centOS7版本<br>在刚开始安装Docker时没有任何错误, 但是在后续的docker启动过程中, 出现以下问题:</p><pre><code>Job for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.</code></pre><p>分析一下问题：</p><ol><li>首先查看了一下内核版本</li><li>因为使用命令: yum install docker下载时, 默认下载的是Docker的最新版本, 但是内核版本低的话可能不兼容新版本Docker, 所以有可能出现如上错误</li></ol><p>解决方法：</p><p><strong>步骤一:将以前下载好的Docker卸载干净, 使用如下命令:</strong></p><pre><code>yum remove docker-*</code></pre><p><strong>步骤二:更新该Liunx系统的内核版本,使用如下命令:</strong></p><pre><code>yum update</code></pre><p>建议更新完之后, 重启一下系统</p><p><strong>步骤三:继续下载安装docker(尽量使用高级管理员权限下载)使用如下命令</strong></p><pre><code>yum install docker</code></pre><p><strong>步骤四:使用如下命令启动docker</strong></p><pre><code>sudo systemctl start docker</code></pre><p>问题解决!<br>注：如果这样安装完之后还报错, 按照这个步骤再来一遍即可</p><p><strong>如果使用docker命令时出现如下错误:</strong></p><pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>第一个原因可能是因为docker没有启动<br>第二个原因就是因为docker出现错误<br>归根结底都是docker启动问题, 解决方案还是以上步骤</p><p>22端口是使用的是nginx的服务器<br>80是浏览器的默认端口<br>443端口我设置成图床服务的端口</p><h2 id="Centos-下-nginx-没有-sites-enabled-文件夹问题"><a href="#Centos-下-nginx-没有-sites-enabled-文件夹问题" class="headerlink" title="Centos 下 nginx 没有 sites-enabled 文件夹问题"></a>Centos 下 nginx 没有 sites-enabled 文件夹问题</h2><p>可能是Centos都会遇见的问题解决方法为：<br>编辑 /etc/nginx/nginx.conf 在 http block 中添加：</p><pre><code>include /etc/nginx/sites-enabled/*;</code></pre><p>然后再/etc/nginx 目录下自己创建一个sites-enabled文件夹就好了<br>最后别忘记了重启nginx服务</p>]]></content>
    
    
    <categories>
      
      <category>-notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>将hexo博客搭建到服务器上</title>
    <link href="undefined2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>2020/01/08/hexo%20%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将hexo 博客搭建到github是一件十分简单得事情，但是在GitHub page中使用你得博客时难免会遇见速度慢、域名不宜与他人分享等等问题，所以当你准备把你网站搭建到服务时就可能遇见很多问题，那我就给大家分享我得在搭建时得心得。</p><a id="more"></a><h1 id="服务器准备阶段"><a href="#服务器准备阶段" class="headerlink" title="服务器准备阶段"></a>服务器准备阶段</h1><p>&emsp;&emsp;国内的服务器有很多，阿里云、百度云、腾讯云、牛七云等等。这些服务器都是大厂的旗下的服务器，所以稳定性还是可以保证的，我选择的是阿里云的学生版一年114元。一核2G的内存价格还是很良心的，如果你想要更低的价格，那某宝应该有适合你的选择。一般国内的互联网公司使用的服务器操作系统主要是Centos。选择Centos作为操作系统即可。当你购买服务之后，阿里会给你一个内网和外网的地址。外网地址就是我们使用浏览器可以查询到的地址，也是我们后面会主要使用到的地址。当然IP地址是不容易记住的我们需要购买一下域名，阿里云很方面都是一站式的。然后就是网站的备案，如果你网站使用的是国内的服务器，是需要备案的，如果你不备案，你的网站时无法访问的。备案的时间时比较长的过程和程序也相对比较麻烦。在这里大家注意一点就是，如果你的备案地址写的是你的学校，那么你就要将你的地址精确到你寝室的楼栋和房间号。</p><p><img src="/img/服务器.png" srcset="/img/loading.gif" alt=" "></p><h1 id="第一步在服务器上安装nginx"><a href="#第一步在服务器上安装nginx" class="headerlink" title="第一步在服务器上安装nginx"></a>第一步在服务器上安装nginx</h1><h2 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h2><p>&emsp;&emsp;Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器。。 本例演示 CentOS 7 下安装和配置 Nginx 的基本步骤。</p><h2 id="步骤1：添加yum源"><a href="#步骤1：添加yum源" class="headerlink" title="步骤1：添加yum源"></a>步骤1：添加yum源</h2><pre><code>$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><p>安装完yum源之后，可以查看一下。</p><pre><code>repo id                                 repo name                                                              statusbase/7/x86_64                           CentOS-7                                                               10,097epel/x86_64                             Extra Packages for Enterprise Linux 7 - x86_64                         13,510extras/7/x86_64                         CentOS-7                                                                  307nginx/x86_64                            nginx repo                                                                170updates/7/x86_64                        CentOS-7                                                                1,010repolist: 25,094</code></pre><p>可以发现<font width="bolder" color="red">nginx repo</font>已经安装到本机了</p><h2 id="步骤2：安装"><a href="#步骤2：安装" class="headerlink" title="步骤2：安装"></a>步骤2：安装</h2><p>yum 安装 Nginx，非常简单，一条命令。</p><pre><code>$ sudo yum install nginx</code></pre><h2 id="步骤-3-配置-Nginx-服务"><a href="#步骤-3-配置-Nginx-服务" class="headerlink" title="步骤 3: 配置 Nginx 服务"></a>步骤 3: 配置 Nginx 服务</h2><p>设置开机启动</p><pre><code>$ sudo systemctl enable nginx</code></pre><p>启动服务</p><pre><code>$ sudo systemctl start nginx</code></pre><p>停止服务</p><pre><code>$ sudo systemctl restart nginx</code></pre><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><pre><code>$ sudo systemctl reload nginx</code></pre><p>到这里我们输入我们服务器外网的网址就可以看到<strong>nginx welcome</strong>的欢迎界面。此时就说明你的nginx已经安装完成了。</p><h1 id="在服务器上安装git"><a href="#在服务器上安装git" class="headerlink" title="在服务器上安装git"></a>在服务器上安装git</h1><p><P><br>&emsp;&emsp;当我们把nginx安装到我们的服务器之后，下一步就是安装git。如果之前你已经搭建过hexo博客并且已经将博客搭建在GitHub上时后面的步骤你将会稍微比较熟悉。<br>&lt;/p&gt;</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><pre><code>git --version // 如无，则安装yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install -y git</code></pre><h2 id="创建用户并配置其仓库"><a href="#创建用户并配置其仓库" class="headerlink" title="创建用户并配置其仓库"></a>创建用户并配置其仓库</h2><pre><code>useradd gitpasswd git // 设置密码su git // 这步很重要，不切换用户后面会很麻烦cd /home/git/mkdir -p projects/blog // 项目存在的真实目录mkdir repos &amp;&amp; cd reposgit init --bare blog.git // 创建一个裸露的仓库cd blog.git/hooksvi post-receive // 创建 hook 钩子函数，输入了内容如下</code></pre><pre><code>    #!/bin/sh    git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</code></pre><p>添加完毕后修改权限</p><pre><code>chmod +x post-receiveexit // 退出到 root 登录chown -R git:git /home/git/repos/blog.git // 添加权限</code></pre><h2 id="测试git仓库是否可用，另找空白文件夹"><a href="#测试git仓库是否可用，另找空白文件夹" class="headerlink" title="测试git仓库是否可用，另找空白文件夹"></a>测试git仓库是否可用，另找空白文件夹</h2><pre><code>git clone git@server_ip:/home/git/repos/blog.git</code></pre><p>如果能把空仓库拉下来，就说明 git 仓库搭建成功了</p><h2 id="Git配置仓库"><a href="#Git配置仓库" class="headerlink" title="Git配置仓库"></a>Git配置仓库</h2><p>&emsp;&emsp;这一部分主要目的是让我们个人的电脑可以通过ssh方式连接到云服务器，然后我们就可以通过命令行方式将我们的博客Po到服务器上。操作如下： 安装git: yum install git 配置git用户 adduser git 修改用户权限:</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoers</code></pre><pre><code>    找到这个位置添加下面这句话 git ALL=(ALL) ALL</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d76b9d87178?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>保存退出后 将sudoers文件权限改回原样</p><pre><code>chmod 400 /etc/sudoers</code></pre><p>切换到git用户，然后在~目录下创建.ssh文件夹</p><pre><code>        su git        cd ~        mkdir .ssh        cd .ssh</code></pre><p><strong>生成公钥密钥文件</strong>(重点)</p><font color="red" size="bolder">ssh-keygen</font><p><strong>此时在目录下就会有两个文件，分别是</strong></p><font color="red" size="bolder">id_rsa 和 id_rsa.pub</font><p>其中<strong>id_rsa.pub</strong>就是公钥文件 我们复制一份</p><font color="red" size="bolder">cp id_rsa.pub authorized_keys</font><p><strong>这样目录下就会有一个authorized_keys文件，它和id_rsa.pub一模一样。<br>最后我们修改它的权限</strong></p><pre><code>chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>&emsp;&emsp;但是大家一定要注意在远程连接服务其之前，我们一定要先对我能的服务器进行设置。<br>在root用户下修改 <strong>/etc/ssh/sshd_config</strong> 文件中的<strong>PasswordAuthentication no改为PasswordAuthentication yes</strong> 并保存。<br><img src="https://img.alicdn.com/tfs/TB1B8ELgHsTMeJjSszgXXacpFXa-799-554.png" srcset="/img/loading.gif" alt=" "><br>输入如下命令<strong>sudo service sshd restart</strong>重启SSH服务,就可以重新使用账号密码连接服务器了。<br><img src="https://img.alicdn.com/tfs/TB1OjQ_gMMPMeJjy1XbXXcwxVXa-812-264.png" srcset="/img/loading.gif" alt=" "></p><p>&emsp;&emsp;然后我们在<strong>自己的电脑上自己的电脑上自己的电脑上</strong>（重要的事说三遍），打开cmd，使用ssh方式连接我们的云服务器。<br>     <img src="https://user-gold-cdn.xitu.io/2019/8/15/16c93d7a77735c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt=" "></p><p>最后当你远程连接上你的服务器时，就会出现<br><img src="/img/服务器-4.png" srcset="/img/loading.gif" alt=" "></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&emsp;&emsp;我们需要更改hexo博客的根目录下的_config.yml文件将最后一行的的repo：后面改成 </p><pre><code>git@这里写服务器外网IP:/home/git/repos/blog.git</code></pre><p>之后大家就可以来尝试用hexo clean &amp; hexo g &amp; hexo d 来部署大家的博客了。<br><img src="/img/服务器-2.png" srcset="/img/loading.gif" alt=" "></p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多文件编译</title>
    <link href="undefined2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>2019/12/26/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<!--banner_img:是当前页面图片--><p>在编译多个文件的时候所出现的报错<br><a id="more"></a></p><h1 id="多文件编译遇见的问题"><a href="#多文件编译遇见的问题" class="headerlink" title="多文件编译遇见的问题"></a>多文件编译遇见的问题</h1><p><img src="/img/报错截图.jpg" srcset="/img/loading.gif" alt=" "></p><p>该错误出现在 command line 为</p><pre><code>gcc coordin.h file1.cpp file2.cpp -o file1</code></pre><p><strong>解决方法为：</strong><br><strong>解决方法是用如下命令进行编译(使用 -l 来连接 stdc++):</strong></p><pre><code>gcc coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre><p><strong>gcc编译cpp文件为什么要加-lstdc++?</strong></p><pre><code>   gcc可以编译c++文件，也可以编译c文件，但默认是编译c文件的，加-lstdc++表示编译c++文件，即链接c++库，加-lc表示链接c库，默认情况下就是链接c库，所以如果编译c文件可以不加-lc。</code></pre><p><strong>另外，你也可以使用 g++, 效果是一样的, stdc++会被自动连接:</strong></p><pre><code>g++ coordin.h file1.cpp file2.cpp -o HelloWorld</code></pre>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单题（1136）</title>
    <link href="undefined2019/12/15/AC%EF%BC%881136%EF%BC%89/"/>
    <url>2019/12/15/AC%EF%BC%881136%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这个一道递归优化问题</p><a id="more"></a><h1 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h1><p><strong>题目表述</strong><br>优化一下代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;int f(int n){    if (n &lt; 0) return 0;    if (n == 0) return 1;    return f(n - 1) + f(n - 2);}int main(){        int n;    cin &gt;&gt; n;    cout &lt;&lt; f(n);    return 0;}</code></pre><p><strong>输入</strong><br>    一个小于50的正整数n。<br><strong>输出</strong><br>    f(n)，不要换行。<br><strong>样例输入</strong><br>    3<br><strong>样例输出</strong><br>    3</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&emsp;&emsp;这个题目看起来没有什么意思，但是我们通过分析计算我们会发现。<br>&emsp;&emsp;1. 递归50次后$int$是否够存，<br>&emsp;&emsp;2. 递归50次后会不会爆栈。<br>&emsp;&emsp;3. 我们应该如何优化。<br>&emsp;&emsp;我们将代码复制到编辑器里面后编译会发现在输入49后$int$会溢出说明这49的递归后是一个超过21亿的数，所以我们应该使用$long$ $long$来储存这个庞大的数值。然后就是爆栈的问题，在使用$long$ $long$之后还是能计算出来的说明还没有爆栈，还能计算。然后就是递归的优化问题了。</p><h3 id="什么是递归优化？"><a href="#什么是递归优化？" class="headerlink" title="什么是递归优化？"></a>什么是递归优化？</h3><p>&emsp;&emsp;递归优化是由于递归多次后递归深度过大，导致爆栈。或者是由于递归深度过深之后时间过长，导致之间效率低下。所以我们常见的递归优化有两种。</p><ol><li>尾递归。</li><li>将递归改循环。<br>两种方法，我们在记忆化之后我们发现这些数列之间的插值满足斐波拉切数列。所以我们就可以把这个递归函数改成一个循环函数。就可以实现对递归的优化。</li></ol><p><strong>答案</strong></p><pre><code>#include &lt;iostream&gt;using namespace std;/*int f(int n){    if (n &lt; 0) return 0;    if (n == 0) return 1;    return f(n - 1) + f(n - 2);}*/long long  fibo(int n){    long long nFirst = 0;    long long nSecond = 1;    long long  nThird = 0;    for(int i = 2 ; i &lt;= n; i++){        nThird = nFirst + nSecond;        nFirst = nSecond;        nSecond = nThird;    }    return nThird;}long long f(int n){    long long count = 1;    if(n == 1){        return 1;    }    for (int i = 1; i &lt; n; i++)    {        count += fibo(i);    }    return count+1;}int main(){        int n;    cin &gt;&gt; n;    cout &lt;&lt; f(n);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>-训练题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="undefined2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>2019/12/07/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>顺序表简述</p><a id="more"></a><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><p><strong>顺序映象</strong>：</p><p>&emsp;&emsp;—— 以x的存储位置和y的春初位置之间某种关系表示逻辑关系<x,y></p><p>最简单的一种顺序映象方式是：</p><p>&emsp;&ensp;令 y 的存储位置和 x 的存储位置相邻。用一组==地址连续==的存储单元==依次存放==线性表中的元素。==线性表的起始地址==，称作线性表的<strong>基地址</strong>。也就是第一个元素。</p><p>以“存储位置相邻”表示有序对$<a_{i-1},a_i>$,即：$LOC(a~i~) = LOC(a~i-1~) + C$;</p><p>&emsp;&ensp;所有数据元素的存储位置。$LOC(a~i~) = LOC(a~1~) + (i - 1) \times C$,其中LOC(a~1~)就是基地址。</p><ul><li>存取结构：与存储结构是两个不同的概念。</li><li>存取结构是在一个数据结构上对查找操作的时间性能的一种描述。</li><li><p>通常由两种存取结构；随机存取结构和顺序存取结构。</p><ul><li>随机存取结构是指在一个数据结构上进行查找的时间性能是$O(1)$,即查找任意一个数据元素的时间时候相等的，均为常数时间，例如顺序表示一种随机存期结构。</li><li>顺序存取结构是指在一个数据结构上进行查找的时间性能是$O(n)$，即查找一个数据元素的时间复杂度是线性的，与该元素在结构中的位置有关，例如单链表是一种顺序存储结构。</li></ul></li></ul><h2 id="顺序映象的C语言描述"><a href="#顺序映象的C语言描述" class="headerlink" title="顺序映象的C语言描述"></a>顺序映象的C语言描述</h2><pre><code>#define LISTSIZE 100  //存储空间最大分配量typedef struct {    ElemType elem[LISTSZIE];    int length;  //当前长度}Sqlist; //Sqlist，代表线性表;</code></pre><ul><li>在线性表的静态分配顺序存储结构中，线性表的最多数据元素个数为LSITSIZE，元素数量不能随意增加，这是以数组方式描述线性表的缺点。</li></ul><p>&emsp;&ensp;为了实现线性表最大存储数据元素数可随意变化，可以使用一个动态的数组来取代上面的固定长度数组，如下描述。</p><p>线性表的动态分配顺序储存结构：</p><pre><code>#define LIST_INIT_SIZE 100  //初始分配量#define LISTINCREMENT 10 //分配分配增量typedef struct {    ElemType *elem;  //储存空间基址    int length; //当前长度    int listsize; //当前分配的存储容量}SqList;// 俗称 顺序表</code></pre><h3 id="线性表操作"><a href="#线性表操作" class="headerlink" title="线性表操作"></a>线性表操作</h3><h3 id="1-InitList-amp-L"><a href="#1-InitList-amp-L" class="headerlink" title="1.InitList(&amp;L);"></a>1.InitList(&amp;L);</h3><p>&emsp;&emsp;InitList(&amp;L); 的实现是一个加工型的运算，因此，将L设为引用参数，首先动态分配存储空间，然后，将length设置为0，表示表中没有数据元素。</p><p>代码实现：</p><pre><code>Status InitList_Sq (SqList &amp;L){    L.elem = (ElemType* )malloc(LIST_INIT_SIZE * sizeof (ElemType));    if (!L.elem){        exit (1);//储存分配失败    }    L.length = 0;    L.listsize = LIST_INIT_SIZE;//初始储存容量;    return OK;}</code></pre><h3 id="2-LocateElme-L-x-compare"><a href="#2-LocateElme-L-x-compare" class="headerlink" title="2.LocateElme(L,x,compare());"></a>2.LocateElme(L,x,compare());</h3><ul><li>线性表中的<strong>按置操作</strong>是指在线性表中查找与给定值X相等的数据元素。</li><li>顺序表中完成该运算最简单的方法是：从第一个元素a~1~起依次和X比较，直到找到一个与X相等的数据元素，则返回它在顺序表中的存储下标记或序号(二者差1);或者查遍整个表都没有找到与X相等的元素，返回ERROR。</li></ul><p>代码实现：</p><pre><code>Status LocateElem_Sq (SqList L, ElemType x){    int i = 0;    while (i &lt;= L.length-1 &amp;&amp; L.elem[i] != x){        i++;    }    if(i &gt; L.length - 1){        return ERROR;    }    else return i;}</code></pre><blockquote><p>本算法的主要运算是比较，显然比较的次数与x在表中的位置有关，也与表长有关。当a~1~ = x时，比较一次成功，当a~n~ = x时比较n次成功，按值查找的平均比较次数为 $\frac{(N+1)}{2}$,时间性能为$O(n)$。</p></blockquote><h3 id="3-ListInsert-amp-L-i-e"><a href="#3-ListInsert-amp-L-i-e" class="headerlink" title="3. ListInsert(&amp;L, i, e)"></a>3. ListInsert(&amp;L, i, e)</h3><p>代码实现:</p><pre><code>Status ListInsert_Sq (SqList &amp;L, int i, ElemType e){    //在顺序表L的第i个元素之前插入新的元素e    //i的合法范围为 1 &lt;=i&lt;=L.length+1    ElemType *q = &amp;(L.elem[i-1]);//q指示插入位置    ElemType *p;    for (p = &amp;(L.elem[L.length-1]); p &gt;= q; --p){            *(p + 1) = *p;//插入位置及之后的元素右移            *q = e;//插入e        ++L.length;//表长增1    }}</code></pre><p>算法时间复杂度为：$O(ListLength(L))$</p><pre><code>if (i &lt; 1 || i &gt; L.length + 1){    return ERROR;//插入位置不合法}if (L.length &gt;= L.listsize){    return OVERFLOW;//当前存储空间已满}</code></pre><h4 id="考虑移动元素的平均情况："><a href="#考虑移动元素的平均情况：" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设在第i个元素之前插入的概率为p~i~,则在长度为<em>n</em>的线性表中插入一个元素为所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_is = \sum_{i = 1}^{n + 1} P_i(n - i + 1)</script><p>所有为位置的概率的累加和。</p><p>&emsp;&emsp;若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_is = \frac{i}{n+1}\sum_{i=1}^{n+1}(n-i+1) = \frac{2}{n}</script><h3 id="4-ListDelete-amp-L-i-amp-e-的实现："><a href="#4-ListDelete-amp-L-i-amp-e-的实现：" class="headerlink" title="4. ListDelete(&amp;L, i, &amp;e)的实现："></a>4. ListDelete(&amp;L, i, &amp;e)的实现：</h3><p>代码实现：</p><pre><code>Status LsitDelet_Sq (SqList &amp;L, int i, ElemType &amp;e){    if((i &lt; 1) || (i &gt; L.length)){        return ERROR;//删除位置不合法    }    p = &amp;(L.elem[i-1]);//p为被删除元素的位置    e = *p;//被删除元素的值赋给e,可以查看被删元素    q = L.elem + L.length-1;//表尾元素的位置，基址加上一个整数值    for (++p; p &lt;= q; ++p){        *(p-1) = *p;//被删除元素之后的元素左移        --L.length;//表长减一    }    return OK;}</code></pre><p>算法时间复杂度为：$O(ListLength(L))$</p><h4 id="考虑移动元素的平均情况：-1"><a href="#考虑移动元素的平均情况：-1" class="headerlink" title="考虑移动元素的平均情况："></a>考虑移动元素的平均情况：</h4><p>&emsp;&emsp;假设删除第i个元素的概率为$q_i$,则在长度为$n$的线性表中删除一个元素所需移动元素次数的期望值为：</p><script type="math/tex; mode=display">E_dl = \sum_{i=1}^{n}q_i(n-i)</script><p>&emsp;&emsp;假设定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为：</p><script type="math/tex; mode=display">E_dl=\frac{1}{n}\sum_{i=1}^{n}(n-1)=\frac{n-1}{2}</script>]]></content>
    
    
    <categories>
      
      <category>-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链式存储</title>
    <link href="undefined2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>2019/12/07/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-3线性表的链式存储结构-单链表"><a href="#1-3线性表的链式存储结构-单链表" class="headerlink" title="1.3线性表的链式存储结构(单链表)"></a>1.3线性表的链式存储结构(单链表)</h2><p>&emsp;&emsp;用一组地址任意的存储来存放线性表中的元素。</p><p>&emsp;&emsp;以<strong>元素</strong>（数据元素的映象）+指针（指示后继元素存储位置）=<strong>结点</strong>（表示数据元素或数据元素的映象）</p><p>&emsp;&emsp;以“结点的序列”表示线性表<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;————称作链表</p><p>&emsp;&emsp;以线性表中第一个数据元素a~1~的存储地址作为线性表中的地址，称作线性表的头指针。<br>&emsp;&emsp;有时为了操作方便，在第一个结点之前需加一个“头结点”，以指向头结点的指针为链表的头指针。</p><h3 id="单链表的C语言实现："><a href="#单链表的C语言实现：" class="headerlink" title="单链表的C语言实现："></a>单链表的C语言实现：</h3><pre><code>typedef struct LNode{    ElemType data;//数据域    struct LNode *next;//指针域}LNode, *LinkList;LinkList L;//L为单链表的头指针;</code></pre><p>单链表操作实现的基本实现：</p><ul><li>GetElem(L, i, e)&emsp;//取第i个数据元素</li><li>ListInsert(&amp;L, i, e)&emsp;//插入数据元素</li><li>ListDelete(&amp;L, i, e)&emsp;//删除数据元素</li><li>ClearList(&amp;L)&emsp;//重新置为一个空表</li><li>CreateList(&amp;L, n)&emsp;//生成含$n$个数据元素的链表</li></ul><p>找第1个数据元素，必须先找到第$i-1$个数据元素。因此，查找第i个数据元素的基本操作是==移动指针，比较j和i==。令指针p始终指向线性表中第j个数据元素。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dummy Node</title>
    <link href="undefined2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/"/>
    <url>2019/12/07/%E9%93%BE%E8%A1%A8Dummy%20Node/</url>
    
    <content type="html"><![CDATA[<p>值得思考的实现</p><a id="more"></a><h1 id="链表Dummy-Node"><a href="#链表Dummy-Node" class="headerlink" title="链表Dummy Node"></a>链表Dummy Node</h1><h2 id="（一）Partition-List"><a href="#（一）Partition-List" class="headerlink" title="（一）Partition List"></a>（一）Partition List</h2><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-list/description/</a></p><p><strong>题目：给出一个链表和一个x值，要求返回一个顺序链表使得小于x的数在链表前面，大于等于x的数在链表后面，保证节点顺序不变。</strong></p><pre><code>      例如：$1-&gt;3-&gt;2-&gt;4-&gt;2, 3$ 变成：$1-&gt;2-&gt;2-&gt;3-&gt;4$</code></pre><font color="#435d6c" size="3px">解答：建立两个新的左、右指针及dummy node，使用head指针遍历整个链表，遇到大于等于head的节点则放到右链表，否则放到左链表。最后将左右链表相连。第一次犯错：忘记将又指针的尾部指向null;</font><p>代码：</p><pre><code>class Solution {    public ListNode partition(ListNode head, int x) {         if (head == null) {            return head;        }        ListNode leftDummy = new ListNode(0);        ListNode rightDummy = new ListNode(0);        ListNode left = leftDummy;        ListNode right = rightDummy;        while (head != null) {            if (head.val &gt;= x) {                right.next = head;                right = right.next;            } else {                left.next = head;                left = left.next;            }            head = head.next;        }        right.next = null;        left.next = rightDummy.next;        return leftDummy.next;    }}</code></pre><h2 id="（二）-Merge-Two-Sorted-Lists"><a href="#（二）-Merge-Two-Sorted-Lists" class="headerlink" title="（二） Merge Two Sorted Lists"></a>（二） Merge Two Sorted Lists</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/description/</a></p><font color="red">AC！</font><p><b>题目：将两个顺序链表合并成一个顺序链表；</b></p><font color="#435d6c" size="3px">解答：依次比较两个链表里的值大小进行排列；</font><p>改进：当一个链表指针指向null，另一个链表还没时，可以直接将重新排列的链表尾指向当前指针：</p><pre><code>           if (l1 != null) {           head.next = l1;           } else {           head.next = l2;          }</code></pre><p>代码：</p><pre><code>class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode dummy = new ListNode(0);        ListNode head = dummy;        while (l2 != null &amp;&amp; l1 != null) {            if (l1.val &lt;= l2.val) {                head.next = l1;                l1 = l1.next;            } else {                head.next = l2;                l2 = l2.next;            }            head = head.next;        }         while (l1 != null) {            head.next = l1;            l1 = l1.next;            head = head.next;        }        while (l2 != null) {            head.next = l2;            l2 = l2.next;            head = head.next;        }        head.next = null;        return dummy.next;    }}</code></pre><h2 id="（三）swap-two-nodes-in-linked-list"><a href="#（三）swap-two-nodes-in-linked-list" class="headerlink" title="（三）swap two nodes in linked list"></a>（三）swap two nodes in linked list</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/description/</a></p><font color="red" >AC！</font><p><b>题目：两两交换链表中节点位置。</b>如：$1-&gt;2-&gt;4-&gt;5-&gt;6$ 转变为: $2-&gt;1-&gt;5-&gt;4-&gt;6$</p><font color="#435d6c" size="3px">解答：使用两个指针遍历链表；</font><p>代码：</p><pre><code>class Solution {    public ListNode swapPairs(ListNode head) {        if (head == null) {            return head;        }        ListNode dummy = new ListNode(0);        dummy.next = head;        ListNode headNext = head.next;        ListNode headPrev = dummy;        while (head != null &amp;&amp; headNext != null) {            headPrev.next = headNext;            head.next = headNext.next;            headNext.next = head;            headPrev = head;            head = head.next;            if (head != null) {                headNext = head.next;            }        }        return dummy.next;    }}</code></pre><h2 id="（四）reorder-list"><a href="#（四）reorder-list" class="headerlink" title="（四）reorder list"></a>（四）reorder list</h2><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/reorder-list/description/</a></p><p><b>题目：给定一个单链表：</b>$L0-&gt;L1-&gt;…-&gt;Ln-1-&gt;Ln,$</p><pre><code>      重新排序后为：$L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;L2-&gt;Ln-2-&gt;...$</code></pre><font color="#435d6c" size="3px">解答：第一次犯错：将链表尾连接到头之后，忘记将尾的前一个指针指向空；第二次犯错：忘记考虑链表头和prevTail重合的情况（偶数链表）。</font><p>代码：</p><pre><code>class Solution {    public void reorderList(ListNode head) {        while (head != null &amp;&amp; head.next != null) {            ListNode prevTail = head;            while (prevTail.next.next != null) {                prevTail = prevTail.next;            }            ListNode tail = prevTail.next;            if (head.next == tail) {                break;            }             tail.next = head.next;            head.next = tail;            head = head.next.next;            prevTail.next = null;        }    }}</code></pre><h2 id="（四）Rotate-List"><a href="#（四）Rotate-List" class="headerlink" title="（四）Rotate List"></a>（四）Rotate List</h2><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-list/description/</a></p><p><strong>题目：将链表尾部的k个节点移到链表头部；</strong></p><font color="#435d6c" size="3px">解答：每次将链表最后一个节点移动至链表头，移动k次；</font><p>第一次犯错：（超时）先遍历链表，得到链表长度length，循环只需执行 k%length 次；</p><p>代码：</p><pre><code>class Solution {    public ListNode rotateRight(ListNode head, int k) {        ListNode tail = head;        int length = 0;        while (tail != null ) {            length++;            tail = tail.next;        }        if (length == 0 || length == 1) {            return head;        }        for (int i = 0; i &lt; k % length; i++) {            ListNode preTail = head;            while (preTail != null &amp;&amp; preTail.next != null &amp;&amp; preTail.next.next != null) {                preTail = preTail.next;            }            tail = preTail.next;            tail.next = head;            preTail.next = null;            head = tail;        }        return head;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="undefined2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>2019/12/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>二叉树有多种遍历的方式我们简单总结一下</p><a id="more"></a><h1 id="二叉树遍历总结"><a href="#二叉树遍历总结" class="headerlink" title="二叉树遍历总结"></a>二叉树遍历总结</h1><p><p>&emsp;&emsp;<b>二叉树的遍历(treaversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</b>这是二叉树遍历的定义。二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分四种。</p></p><ol><li>前序遍历(PreOrder)<br></li><li>中序遍历(InOrder)<br></li><li>后续遍历(PastOrder)<br></li><li>层序遍历(LevelOrder)<br></li></ol><p>树的前中后序遍历是个递归的定义，在遍历到根节点的左/右子树时，也要遵循前/中/后序遍历的顺序，例如下面这棵树：</p><p>前序遍历：ABDECFG<br>中序遍历：DBEAFCG<br>后序遍历：DEBFGCA<br>层序遍历：ABCDEFG</p><p>树的结点结构体声明如下：<br>语言：C语言（为了省事用到了C++的栈，因为C语言要用栈的话要自己重新写一个出来，就偷了个懒）<br>编译器：VS</p><p>typedef char DataType;</p><p>typedef struct TreeNode{<br>    DataType data;<br>    struct TreeNode <em>left;<br>    struct TreeNode </em>right;<br>}TreeNode;</p><p>前序遍历（先序遍历）<br>对于一棵树的前序遍历，递归的写法是最简单的（写起来），就是将一个大的问题转化为几个小的子问题，直到子问题可以很容易求解，最后将子问题的解组合起来就是大问题的解。</p><p>前序访问的递归写法<br>先放代码，如果看完觉得不太清楚可以看看下面的详细步骤图解。</p><p>、、、<br>void PreOrder(const TreeNode *root)<br>{<br>    if (root == NULL)                 //若结点为空<br>    {<br>        printf(“# “);<br>        return;<br>    }<br>    printf(“%c “, root-&gt;data);        //输出根节点的值<br>    PreOrder(root-&gt;left);             //前序访问左子树<br>    PreOrder(root-&gt;right);            //前序访问右子树<br>}<br>、、、</p><p>比如说还是上面的这颗树：</p><p>访问根节点</p><p>访问左子树</p><p>走到这里之后发现根节点的左孩子还是一棵子树，那就将访问这棵子树看作是遍历整颗树的一个子问题，遍历这棵子树的方法和遍历整颗树的方法是一样的。<br>然后继续访问它的左子树：</p><p>为了理解起来方便一点，我在这里加上了它的两个为空的左右孩子<br>然后发现这（可能）还是一棵子树，就继续用这种方法来对待这颗子树，就是继续访问它的左子树：</p><p>发现这是一个空节点，那就直接返回，去访问它的右子树：</p><p>发现还是一个空节点，那么继续返回，这时候D和它的左右孩子结点都访问过了，继续返回，应该访问B的右子树了。</p><p>然后就和D结点一样的处理方法，-&gt;左孩子，发现是空，返回-&gt;右孩子，发现还是空，继续返回，发现这时候B的左右孩子都访问过了，继续返回。<br>访问右子树</p><p>然后和处理A的左子树的方法一样，最后访问到G结点的右子树时，发现是空，就返回，这时候树的所有节点都已经访问过了，所以可以一路返回到A结点的右子树完的地方，整个递归就结束了。</p><p>最后输出的前序访问序列便是：ABDECFG<br>前序访问的非递归写法<br>还是先上代码：</p><p>、、、<br>void PreOrderLoop(TreeNode <em>root)<br>{<br>    std::stack&lt;TreeNode </em>&gt; s;<br>    TreeNode <em>cur, </em>top;<br>    cur = root;<br>    while (cur != NULL || !s.empty())<br>    {<br>        while (cur != NULL)<br>        {<br>            printf(“%c “, cur-&gt;data);<br>            s.push(cur);<br>            cur = cur-&gt;left;<br>        }</p><pre><code>    top = s.top();    s.pop();    cur = top-&gt;right;}</code></pre><p>}<br>、、、</p><p>非递归的写法比递归写法要麻烦一点，要用到栈来存储树的结点，在理解非递归方法的时候要重点理解栈中保存的元素的共同点是什么，在前序访问中，栈中元素都是自己和自己的左孩子都访问过了，而右孩子还没有访问到的节点，如果不太懂可以看下面的详细步骤图解。</p><p>首先我们要用一个指针（cur）来指向当前访问的结点</p><p>发现这个节点不为空，就将它的数据输出，然后将这个节点的地址（图上的栈中写了节点的值是为了便于理解，实际上栈中保存的是节点地址）压栈。</p><p>再去访问它的左子树，发现左孩子结点依旧不为空，继续输出并压栈。</p><p>同理压栈D节点</p><p>然后访问D的左孩子，发现为空，便从栈中拿出栈顶结点top，让cur = top-&gt;right,便访问到了D的右孩子。</p><p>发现D的右孩子还是为空，这个看一下栈，发现栈不为空，说明还存在右孩子没被访问过的节点，就继续从栈中拿出栈顶结点top，让cur = top-&gt;right，便访问到了B的右孩子。</p><p>B的右孩子处理方法和D一样，然后再从栈中拿出A节点，去访问A的右孩子C，在访问到G节点的右孩子之后，发现当前节点cur为空，栈中也没有元素可以取出来了，这时候就代表整棵树都被访问过了，便结束循环。</p><p>最后输出的前序访问序列便是：ABDECFG<br>中序遍历<br>对于一棵树的中序遍历，和前序一样，可以分为递归遍历和非递归遍历，递归遍历是相对简单的，还是子问题思想，将一个大问题分解，直到可以解决，最后解决整个大问题。</p><p>中序遍历的递归写法<br>还是先上代码：</p><p>、、、<br>void InOrder(const TreeNode *root)<br>{<br>    if (root == NULL)              //判断节点是否为空<br>    {<br>        printf(“# “);<br>        return;<br>    }<br>    InOrder(root-&gt;left);           //中序遍历左子树<br>    printf(“%c “, root-&gt;data);     //访问节点值<br>    InOrder(root-&gt;right);          //中序遍历右子树<br>}<br>、、、</p><p>从根节点进入</p><p>发现根节点不为空，访问左子树</p><p>发现不为空，继续访问左子树</p><p>发现不为空，继续访问左子树</p><p>这时root为空了，就返回去访问它的根节点，刚才的访问只是路过，并没有真正地遍历节点的信息，在返回途中才是真正地遍历到了节点的信息。</p><p>访问到了D节点，下来要访问的是D的右孩子，因为D的左孩子已经访问过了。</p><p>发现还是空，就返回，而它的根节点D也访问过了，那么就继续返回，该访问D节点的父节点B了。</p><p>B访问过后下来要访问的是B的右孩子，因为是从B的左子树回来的路，B的左孩子已经访问过了。</p><p>然后和访问D一样，-&gt;左孩子，为空，返回访问根节点E，-&gt;右孩子，为空（这部分就不画了，和D节点的访问是一样的），最后返回，B已经访问过了，就继续返回，至此，整颗树的左子树访问完了。</p><ol><li><p>访问B的根节点A</p></li><li><p>遍历A的右子树<br>遍历右子树的过程和左子树一样，还是左-&gt;根-&gt;右的中序遍历下去，直到遍历到G的右孩子，发现为空，就返回，因为右子树都遍历过了，所以可以一直返回到root为A节点的那一层递归，整个遍历结束。</p></li></ol><p>最后输出的中序访问序列为：DBEAFCG</p><p>非递归写法<br>中序访问的非递归写法和前序一样，都要用到一个栈来辅助存储，不一样的地方在于前序访问时，栈中保存的元素是右子树还没有被访问到的节点的地址，而中序访问时栈中保存的元素是节点自身和它的右子树都没有被访问到的节点地址。</p><p>先上代码：</p><p>、、、<br>void InOrderLoop(TreeNode <em>root)<br>{<br>    std::stack&lt;TreeNode </em>&gt; s;<br>    TreeNode *cur;<br>    cur = root;<br>    while (cur != NULL || !s.empty())<br>    {<br>        while (cur != NULL)<br>        {<br>            s.push(cur);<br>            cur = cur-&gt;left;<br>        }</p><pre><code>    cur = s.top();    s.pop();    printf(&quot;%c &quot;, cur-&gt;data);    cur = cur-&gt;right;}</code></pre><p>}<br>、、、</p><p>cur指针一路沿着最左边往下访问，路过的节点全部压栈，直到遇到空节点</p><p>从栈中取出栈顶节点top，输出栈顶结点的值并使cur = top-&gt;right，从第一步开始去遍历top的右子树。</p><p>遍历完之后，cur走到了D节点的右孩子，发现cur 为空，但栈中还有元素，就重复第二步</p><p>这时候，cur走到了E节点的右孩子，发现cur 为空，但栈中还有元素，就继续重复第二步，之后cur = top-&gt;right，cur指针继续去遍历A节点的右子树，从第一步开始</p><p>访问到F的左孩子节点发现是空，这时候栈中还有元素，就重复第二步</p><p>照这个规则依次访问下去，最后会访问到G节点的右孩子，这时候cur为空，栈也空了，就代表所有节点已经遍历完了，就结束循环，遍历完成。</p><p>最后输出的中序访问序列为:DBEAFCG</p><p>后序遍历<br>后序遍历还是分递归版本和非递归版本，后序遍历的递归版本和前序中序很相似，就是输出根节点值的时机不同，而后序遍历的非递归版本则要比前序和中序的要难一些，因为在返回根节点时要分从左子树返回和右子树返回两种情况，从左子树返回时不输出，从右子树返回时才需要输出根节点的值。</p><p>递归写法<br>先上代码：</p><p>、、、<br>void PostOrder(TreeNode *root)<br>{<br>    if (root == NULL)<br>    {<br>        printf(“# “);<br>        return;<br>    }<br>    PostOrder(root-&gt;left);<br>    PostOrder(root-&gt;right);<br>    printf(“%c “, root-&gt;data);<br>}<br>、、、</p><p>后序遍历的递归版本和前中序非常相似，就是输出根节点值的时机不同，详细图解这里就不画了，可以联系前中序的递归版本来理解。</p><p>后序遍历的非递归写法<br>后序遍历的非递归同样要借助一个栈来保存元素，栈中保存的元素是它的右子树和自身都没有被遍历到的节点，与中序遍历不同的是先访问右子树，在回来的时候再输出根节点的值。需要多一个last指针指向上一次访问到的节点，用来确认是从根节点的左子树返回的还是从右子树返回的。</p><p>先上代码：</p><p>、、、<br>void PostOrderLoop(TreeNode <em>root)<br>{<br>    std::stack&lt;TreeNode </em>&gt; s;<br>    TreeNode <em>cur, </em>top, *last = NULL;<br>    cur = root;<br>    while (cur != NULL || !s.empty())<br>    {<br>        while (cur != NULL)<br>        {<br>            s.push(cur);<br>            cur = cur-&gt;left;<br>        }</p><pre><code>    top = s.top();    if (top-&gt;right == NULL || top-&gt;right == last){        s.pop();        printf(&quot;%c &quot;, top-&gt;data);        last = top;    }    else {        cur = top-&gt;right;    }}</code></pre><p>}<br>、、、</p><p>还是沿着左子树一路往下走，将路过的节点都压栈，直到走到空节点。</p><p>然后从栈中看一下栈顶元素（只看一眼，用top指针记下，先不出栈），如果top节点没有右子树，或者last等于top的右孩子，说明top的右子树不存在或者遍历过了，就输出top节点的值，并将栈顶元素pop掉（出栈），反之则是从左子树回到根节点的，接下来要去右子树。</p><p>如图，top的右孩子为空，说明右子树不存在，就可以输出top的值并pop掉栈顶了，这时候用last指针记下top指向的节点，代表上一次处理的节点。（这一过程cur始终没有动，一直指向空）</p><p>继续从栈顶看一个元素记为top，然后发现top的右孩子不为空，而且last也不等于top-&gt;right，就使cur = top-&gt;right，回到第一步，用同样的方法来处理top的右子树，下一次回来的时候，last指针指向的是E节点。</p><p>这时候发现top的右孩子不为空，但是last等于top-&gt;right，说明top的右子树遍历完成，下一步就要输出top的值并且将这个节点出栈，下一次再从栈中看一个栈顶元素A即为top。</p><p>这时候再比较，发现top的right不为空，而且last也不等于top-&gt;right，说明top有右子树并且还没有遍历过，就让cur = top-&gt;right，回到第一步用同样的方法来遍历A的右子树。<br>到最后，cur访问到了G的左孩子，而top也一路出栈到了A节点，发现cur为空，并且栈中也为空，这时候便代表整个树已经遍历完成，结束循环。</p><p>最后输出的中序访问序列为:DEBFGCA</p><p>层序遍历<br>层序遍历是比较接近人的思维方式的一种遍历方法，将二叉树的每一层分别遍历，直到最后的叶子节点被全部遍历完，这里要用到的辅助数据结构是队列，队列具有先进先出的性质。</p><p>上代码：<br>、、、<br>void LevelOrder(TreeNode <em>root)<br>{<br>    std::queue&lt;TreeNode </em>&gt; q;<br>    TreeNode *front;</p><pre><code>if (root == NULL)return;q.push(root);while (!q.empty()){    front = q.front();    q.pop();    if (front-&gt;left)        q.push(front-&gt;left);    if (front-&gt;right)        q.push(front-&gt;right);    printf(&quot;%c &quot;, front-&gt;data);}</code></pre><p>}<br>、、、<br>层序遍历的思路是，创建一个队列，先将根节点（A）入队，然后用front指针将根节点记下来，再将根节点出队，接下来看front节点（也就是刚才的根节点）有没有左孩子或右孩子，如果有，先左（B）后右（C）入队，最后输出front节点的值，只要队列还不为空，就说明还没有遍历完，就进行下一次循环，这时的队头元素（front）则为刚才入队的左孩子（B），然后front出队，再把它的左右孩子拉进来（如果有），因为队列的先进先出性质，B的左右孩子DE是排在C后面的，然后输出B，下一次循环将会拉人C的左右孩子FG，最后因为FG没有左右孩子，一直出队，没有入队元素，队列迟早会变为空，当队列为空时，整颗树就层序遍历完成了，结束循环。</p><p>根节点入队，并用front指针标记</p><p>队头出队，并将左右孩子拉进队列</p><p>重复1，2</p><p>直到队列为空</p><p>这时候便代表整个树遍历完成，结束循环。<br>最后输出的层序访问序列为:ABCDEF</p>]]></content>
    
    
    <categories>
      
      <category>-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinGw如何调试？</title>
    <link href="undefined2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <url>2019/12/07/MinGW%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>MinGw调试方法</p><a id="more"></a><h1 id="MinGW调试命令"><a href="#MinGW调试命令" class="headerlink" title="MinGW调试命令"></a>MinGW调试命令</h1><p>&emsp;&emsp;MinGW（Minimalist GNU for Windows）提供了一套简单方便的Windows下的基于GCC程序开发环境。MinGW收集了一系列免费的Windows是用的头文件和库文件；同时整合了GNU的工具集，特别是GNU程序开发工具，如经典的gcc，g++，make等。MinGW是完全免费的自由软件，它在Windows平台下模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好的基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。简单的说，它是个精简的C/C++编译器，它实际上是将经典的开源C语言/C++编译器GCC/G++移植到了Windows下，并且包含了Win32API，因此可以将源代码编译生成Windows下的可执行程序。虽然VC6等编译器，只要点击鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑，而MinGW则只会生成一个可执行文件</p><hr><h2 id="gdb调试测试代码-test-c-："><a href="#gdb调试测试代码-test-c-：" class="headerlink" title="gdb调试测试代码(test.c)："></a>gdb调试测试代码(test.c)：</h2><pre><code>#include &lt;stdio.h&gt;void swap(int *a,int *b){    int temp = *a;    *a = *b;    *b = temp;}int main(void){    int a=1,b=2;    swap(&amp;a,&amp;b);    printf(&quot;a = %d ,b = %d\n&quot;,a,b);    return 0;}</code></pre><h3 id="要支持调试，在编译时要加入-g选项，编译命令："><a href="#要支持调试，在编译时要加入-g选项，编译命令：" class="headerlink" title="要支持调试，在编译时要加入-g选项，编译命令："></a>要支持调试，在编译时要加入-g选项，编译命令：</h3><pre><code>gcc text.c -g text.exe</code></pre><h3 id="出现调试命令："><a href="#出现调试命令：" class="headerlink" title="出现调试命令："></a>出现调试命令：</h3><pre><code>GNU gdb (GDB) 7.6.1Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;mingw32&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from D:\mypro\C\test.exe...done.(gdb)</code></pre><h3 id="gdb调试命令表："><a href="#gdb调试命令表：" class="headerlink" title="gdb调试命令表："></a>gdb调试命令表：</h3><div class="table-container"><table><thead><tr><th>命令</th><th style="text-align:center">解释</th><th style="text-align:right">简写</th></tr></thead><tbody><tr><td>file</td><td style="text-align:center">加载一个可执行文件，也可以在运行gdb的时候加载，两种方法都不会运行程序</td><td style="text-align:right">无</td></tr><tr><td>list</td><td style="text-align:center">列出可执行源码的一部分，通常在程序开始运行前执行，用来设置断点</td><td style="text-align:right">l</td></tr><tr><td>next</td><td style="text-align:center">单步调试，不进入函数</td><td style="text-align:right">n</td></tr><tr><td>step</td><td style="text-align:center">单步调试，进入函数</td><td style="text-align:right">s</td></tr><tr><td>run</td><td style="text-align:center">运行加载了的程序</td><td style="text-align:right">r</td></tr><tr><td>continue</td><td style="text-align:center">继续执行程序</td><td style="text-align:right">c</td></tr><tr><td>quit</td><td style="text-align:center">退出调试</td><td style="text-align:right">q</td></tr><tr><td>print</td><td style="text-align:center">输出制定的变量的值，变量要在程序运行处可见</td><td style="text-align:right">p</td></tr><tr><td>break</td><td style="text-align:center">设置断点</td><td style="text-align:right">b</td></tr><tr><td>info break</td><td style="text-align:center">查看断点的信息</td><td style="text-align:right">i b</td></tr><tr><td>delete</td><td style="text-align:center">删除断点</td><td style="text-align:right">d</td></tr><tr><td>watch</td><td style="text-align:center">监视一个变量的值，一旦值发生变化，程序将会被暂停执行</td><td style="text-align:right">wa</td></tr><tr><td>help</td><td style="text-align:center">查看gdb的帮助信息</td><td style="text-align:right">h</td></tr></tbody></table></div><h3 id="1-l命令，列出部分代码："><a href="#1-l命令，列出部分代码：" class="headerlink" title="1.l命令，列出部分代码："></a>1.l命令，列出部分代码：</h3><p>在(gdb)后面输入l可以显示一部分代码再输入一次l可以显示全部代码</p><pre><code>(gdb) l2   3   void swap(int *a,int *b){4       int temp = *a;5       *a = *b;6       *b = temp;7   }8   9   int main(void)10  {11      int a=1,b=2;(gdb)(gdb) l12      swap(&amp;a,&amp;b);13      printf(&quot;a = %d ,b = %d\n&quot;,a,b);14      return 0;15  }(gdb) l(gdb) Line number 16 out of range; test.c has 15 lines</code></pre><h3 id="2-start命令，开始运行，会停到main入口处："><a href="#2-start命令，开始运行，会停到main入口处：" class="headerlink" title="2.start命令，开始运行，会停到main入口处："></a>2.start命令，开始运行，会停到main入口处：</h3><pre><code>(gdb) startTemporary breakpoint 1 at 0x401491: file test.c, line 11.Starting program: D:\mypro\C/test.exe [New Thread 8000.0x18c4][New Thread 8000.0x2418]Temporary breakpoint 1, main () at test.c:1111      int a=1,b=2</code></pre><h3 id="4-n命令：单步调试，不进入函数，跳到第12行"><a href="#4-n命令：单步调试，不进入函数，跳到第12行" class="headerlink" title="4.n命令：单步调试，不进入函数，跳到第12行:"></a>4.n命令：单步调试，不进入函数，跳到第12行:</h3><pre><code>(gdb) n12      swap(&amp;a,&amp;b);</code></pre><h3 id="5-s命令：单步调试，进入函数，跳到第4行"><a href="#5-s命令：单步调试，进入函数，跳到第4行" class="headerlink" title="5.s命令：单步调试，进入函数，跳到第4行:"></a>5.s命令：单步调试，进入函数，跳到第4行:</h3><pre><code>gdb) sswap (a=0x61ff2c, b=0x61ff28) at test.c:44       int temp = *a;</code></pre><h3 id="6-b命令设置断点（b-第n行代码的行数）："><a href="#6-b命令设置断点（b-第n行代码的行数）：" class="headerlink" title="6.b命令设置断点（b + 第n行代码的行数）："></a>6.b命令设置断点（b + 第n行代码的行数）：</h3><pre><code>(gdb) b 6Breakpoint 2 at 0x401478: file test.c, line 6.</code></pre><h3 id="7-r命令-运行程序，直到下一个断点就停："><a href="#7-r命令-运行程序，直到下一个断点就停：" class="headerlink" title="7.r命令,运行程序，直到下一个断点就停："></a>7.r命令,运行程序，直到下一个断点就停：</h3><pre><code>The program being debugged has been started already.Start it from the beginning? (y or n)...Breakpoint 2, swap (a=0x61ff2c, b=0x61ff28) at test.c:66       *b = temp;</code></pre><h3 id="7-p命令-输出制定的变量的值，变量要在程序运行处可见"><a href="#7-p命令-输出制定的变量的值，变量要在程序运行处可见" class="headerlink" title="7.p命令,输出制定的变量的值，变量要在程序运行处可见:"></a>7.p命令,输出制定的变量的值，变量要在程序运行处可见:</h3><pre><code>(gdb) p *a$1 = 2(gdb) p *b$2 = 2(gdb) p a$3 = (int *) 0x61ff2c(gdb) p b$4 = (int *) 0x61ff28</code></pre><p>next一下，再看b的值：</p><pre><code>(gdb) n7   }(gdb) p *b$5 = 1</code></pre><h3 id="8-i-b命令-查看断点信息"><a href="#8-i-b命令-查看断点信息" class="headerlink" title="8.i b命令,查看断点信息:"></a>8.i b命令,查看断点信息:</h3><pre><code>(gdb) i bNum     Type           Disp Enb Address    What2       breakpoint     keep y   0x00401478 in swap at test.c:6    breakpoint already hit 1 time</code></pre><h3 id="9-d命令-删除断点，不加断点位置即删除所有断点"><a href="#9-d命令-删除断点，不加断点位置即删除所有断点" class="headerlink" title="9.d命令,删除断点，不加断点位置即删除所有断点:"></a>9.d命令,删除断点，不加断点位置即删除所有断点:</h3><pre><code>(gdb) d Delete all breakpoints? (y or n) [answered Y; input not from terminal](gdb) i bNo breakpoints or watchpoints.</code></pre><h3 id="10-没有断点后，再试一下r命令，可以看到，执行完了程序："><a href="#10-没有断点后，再试一下r命令，可以看到，执行完了程序：" class="headerlink" title="10.没有断点后，再试一下r命令，可以看到，执行完了程序："></a>10.没有断点后，再试一下r命令，可以看到，执行完了程序：</h3><pre><code>(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) [answered Y; input not from terminal]error return ../../gdb-7.6.1/gdb/windows-nat.c:1275 was 5Starting program: D:\mypro\C/test.exe [New Thread 1976.0x1460][New Thread 1976.0x5e0]a = 2 ,b = 1[Inferior 1 (process 1976) exited normally</code></pre><h3 id="11-q命令，退出gdb："><a href="#11-q命令，退出gdb：" class="headerlink" title="11.q命令，退出gdb："></a>11.q命令，退出gdb：</h3><pre><code>(gdb) q</code></pre>]]></content>
    
    
    <categories>
      
      <category>-notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>remove_list_entry</title>
    <link href="undefined2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/"/>
    <url>2019/12/07/remove_list_entry%EF%BC%88%E6%97%A0%E9%9C%80%20if%20%E9%80%BB%E8%BE%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学习如何写有品味的代码</p><a id="more"></a><h1 id="remove-list-entry（无需-if-逻辑）"><a href="#remove-list-entry（无需-if-逻辑）" class="headerlink" title="remove_list_entry（无需 if 逻辑）"></a>remove_list_entry（无需 if 逻辑）</h1><p>&emsp;&emsp;这是期TED里面的内容，内容是采访linux的之父Linus Torvalds。<br>&emsp;&emsp;Linus Torvalds两次改变了技术，第一次是Linux内核，它帮助互联网的发展，第二次是Git，全球开发者使用的源代码管理系统。在一次TED的采访中，Torvalds以极其开放的态度讨论了他独特的工作方式和性格特点。Torvalds说：“我不是一个空想家，我是一名工程师，我非常乐意跟梦想家在一起，他们行走四方，仰望苍穹，看着满天星辰说，“我想到那儿去。”但我是低头看路的那种人，我只想填好眼前这个坑，不让自己掉进去，这就是我。”***</p><p>&emsp;&emsp;在聊天中CA问道了一个关于代码品味的的问题，这个问题其实很有意思，对于很多写代码的人来说，有好的代码风格和代码品味就好比有了一种审美品味一样。就好比在写代码时你的缩进习惯一样。</p><blockquote><p>第一段代码</p></blockquote><pre><code>remove_list_entry(entry){    prev = NULL;    walk = head;​    // Walk the list​    while (walk != entry)    {        prev = walk;        walk = walk-&gt;next;    }    // Remove the entry by updating the     // head or the previous entry    if(!prev)    {        head = entry-&gt;next;    }    else    {        prev-&gt;next = entry-&gt;next;    } }</code></pre><blockquote><p>第二段代码</p></blockquote><pre><code>remove_list_entry(entry){    // The &quot;indirect&quot; pointer points to the    // *address* of the thing we&#39;ll update    indirect = &amp;head;​    // Walk the list, looking for the thing that    // points to the entry we want to remove     while ((*indirect) != entry))    {        indirect = &amp;(*indirect)-&gt;next;    }​    // .. and just remove it    *indirect = entry-&gt;next;}</code></pre><font color="red" size="2px">这里我注释一下哈，这两段代码都是伪码。所以看起来有点奇怪</font><p>&emsp;&emsp;看起来这两段代码功能上都一样的但是，第一段的最后用了一个if和一个else目的在于处理特殊情况，但是第二段代码很简洁没有if和else来处理特殊情况，这是一种很有意思且巧妙的思想同样<b>Dummy Node链表</b>也是一种处理方式，在这里不讨论，后面我回专门来说这种链表。</p><pre><code>Node *head, *prev, *walk;void remove_list_entry(Node* entry){    prev = NULL;    // walk 这一变量名，十分巧妙，    // 变量命名的不二法门就是对应其物理（实际）意义    walk = head;    while (walk != entry)    {        prev = walk;        walk = walk-&gt;next;    }    // 也即没有执行 while 循环，walk == entry，entry == head    if (!prev)        head = entry-&gt;next;    else        prev-&gt;next = entry-&gt;next;}</code></pre><pre><code>void remove_list_entry(Node* entry){    Node **indirect;    indirect = &amp;head;    while ((*indirect) != entry)        indirect = &amp;(*indirect)-&gt;next;    *indirect = entry-&gt;next;}</code></pre><font color="#24495e" size="2"><p>&emsp;&emsp;这是两段代码的表准形式</p></font><p>&emsp;&emsp;为什么要区分是头指针呢，因为整个程序的逻辑是找到被删除指针的前一个指针，如果被删除的指针为头指针，显然其没有前一个指针。显然这种的代码不具很好的 taste，话说 Jobs 也很爱讲 taste（Windows 最大的特点就是 has no taste）。<b>这两段代码的显著区别就是第二段代码省略了 if 语句，</b>对头指针和前一个指针做了统一化处理。头指针没有前一个指针，但有自己的地址，自己的地址自然还是指向自己。</p>]]></content>
    
    
    <categories>
      
      <category>-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/12/06/hello-world/"/>
    <url>2019/12/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>first txt<br><a id="more"></a></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>